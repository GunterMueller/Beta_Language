ORIGIN 'gbetacfl';
BODY 'gbetatraversebody';

(* Skeleton file for traversal of ASTs based on
 * grammar 'gbeta'.
 * Take a copy of this file and fill out the do-parts.
 * Do NOT edit this file directly as it will be overwritten
 * when the grammar is processed again.
 *)
--LIB: attributes--

gbeta_traverse: 
  (# ast: @astInterface (* An instance of the AST interface *);
     gbeta: @ast.gbeta;

     do_BetaForm: (* alternation *)
       (# B: ^gbeta.BetaForm
       enter B[]
       <<SLOT do_BetaForm_body: DoPart>>
       #);
     do_DescriptorForm: (* cons *)
       (# D: ^gbeta.DescriptorForm
       enter D[]
       <<SLOT do_DescriptorForm_body: DoPart>>
       #);
     do_AttributesForm: (* cons *)
       (# A: ^gbeta.AttributesForm
       enter A[]
       <<SLOT do_AttributesForm_body: DoPart>>
       #);
     do_ObjectDescriptor: (* cons *)
       (# O: ^gbeta.ObjectDescriptor
       enter O[]
       <<SLOT do_ObjectDescriptor_body: DoPart>>
       #);
     do_MainPart: (* alternation *)
       (# M: ^gbeta.MainPart
       enter M[]
       <<SLOT do_MainPart_body: DoPart>>
       #);
     do_LongMainPart: (* cons *)
       (# L: ^gbeta.LongMainPart
       enter L[]
       <<SLOT do_LongMainPart_body: DoPart>>
       #);
     do_ShortMainPart: (* cons *)
       (# S: ^gbeta.ShortMainPart
       enter S[]
       <<SLOT do_ShortMainPart_body: DoPart>>
       #);
     do_Attributes: (* list *)
       (# A: ^gbeta.Attributes
       enter A[]
       <<SLOT do_Attributes_body: DoPart>>
       #);
     do_PrefixOpt: (* optional *)
       (# a: ^astinterface.ast;
       enter a[]
       <<SLOT do_PrefixOpt_body: DoPart>>
       #);
     do_Prefix: (* alternation *)
       (# P: ^gbeta.Prefix
       enter P[]
       <<SLOT do_Prefix_body: DoPart>>
       #);
     do_SimplePrefix: (* cons *)
       (# S: ^gbeta.SimplePrefix
       enter S[]
       <<SLOT do_SimplePrefix_body: DoPart>>
       #);
     do_CompositePrefix: (* cons *)
       (# C: ^gbeta.CompositePrefix
       enter C[]
       <<SLOT do_CompositePrefix_body: DoPart>>
       #);
     do_AttributeDeclOpt: (* optional *)
       (# a: ^astinterface.ast;
       enter a[]
       <<SLOT do_AttributeDeclOpt_body: DoPart>>
       #);
     do_AttributeDecl: (* alternation *)
       (# A: ^gbeta.AttributeDecl
       enter A[]
       <<SLOT do_AttributeDecl_body: DoPart>>
       #);
     do_PatternDecl: (* cons *)
       (# P: ^gbeta.PatternDecl
       enter P[]
       <<SLOT do_PatternDecl_body: DoPart>>
       #);
     do_SimpleDecl: (* cons *)
       (# S: ^gbeta.SimpleDecl
       enter S[]
       <<SLOT do_SimpleDecl_body: DoPart>>
       #);
     do_RepetitionDecl: (* cons *)
       (# R: ^gbeta.RepetitionDecl
       enter R[]
       <<SLOT do_RepetitionDecl_body: DoPart>>
       #);
     do_VirtualDecl: (* cons *)
       (# V: ^gbeta.VirtualDecl
       enter V[]
       <<SLOT do_VirtualDecl_body: DoPart>>
       #);
     do_BindingDecl: (* cons *)
       (# B: ^gbeta.BindingDecl
       enter B[]
       <<SLOT do_BindingDecl_body: DoPart>>
       #);
     do_FinalDecl: (* cons *)
       (# F: ^gbeta.FinalDecl
       enter F[]
       <<SLOT do_FinalDecl_body: DoPart>>
       #);
     do_DisownOpt: (* optional *)
       (# a: ^astinterface.ast;
       enter a[]
       <<SLOT do_DisownOpt_body: DoPart>>
       #);
     do_Disown: (* cons *)
       (# D: ^gbeta.Disown
       enter D[]
       <<SLOT do_Disown_body: DoPart>>
       #);
     do_SwapOpt: (* optional *)
       (# a: ^astinterface.ast;
       enter a[]
       <<SLOT do_SwapOpt_body: DoPart>>
       #);
     do_Swap: (* cons *)
       (# S: ^gbeta.Swap
       enter S[]
       <<SLOT do_Swap_body: DoPart>>
       #);
     do_RestrictionOpt: (* optional *)
       (# a: ^astinterface.ast;
       enter a[]
       <<SLOT do_RestrictionOpt_body: DoPart>>
       #);
     do_RestrictionPart: (* cons *)
       (# R: ^gbeta.RestrictionPart
       enter R[]
       <<SLOT do_RestrictionPart_body: DoPart>>
       #);
     do_Restrictions: (* list *)
       (# R: ^gbeta.Restrictions
       enter R[]
       <<SLOT do_Restrictions_body: DoPart>>
       #);
     do_Restriction: (* cons *)
       (# R: ^gbeta.Restriction
       enter R[]
       <<SLOT do_Restriction_body: DoPart>>
       #);
     do_VariablePattern: (* cons *)
       (# V: ^gbeta.VariablePattern
       enter V[]
       <<SLOT do_VariablePattern_body: DoPart>>
       #);
     do_ReferenceSpecification: (* alternation *)
       (# R: ^gbeta.ReferenceSpecification
       enter R[]
       <<SLOT do_ReferenceSpecification_body: DoPart>>
       #);
     do_StaticItem: (* cons *)
       (# S: ^gbeta.StaticItem
       enter S[]
       <<SLOT do_StaticItem_body: DoPart>>
       #);
     do_VirtualStaticItem: (* cons *)
       (# V: ^gbeta.VirtualStaticItem
       enter V[]
       <<SLOT do_VirtualStaticItem_body: DoPart>>
       #);
     do_FinalStaticItem: (* cons *)
       (# F: ^gbeta.FinalStaticItem
       enter F[]
       <<SLOT do_FinalStaticItem_body: DoPart>>
       #);
     do_DynamicItem: (* cons *)
       (# D: ^gbeta.DynamicItem
       enter D[]
       <<SLOT do_DynamicItem_body: DoPart>>
       #);
     do_ExactOpt: (* optional *)
       (# a: ^astinterface.ast;
       enter a[]
       <<SLOT do_ExactOpt_body: DoPart>>
       #);
     do_Exact: (* cons *)
       (# E: ^gbeta.Exact
       enter E[]
       <<SLOT do_Exact_body: DoPart>>
       #);
     do_StaticComponent: (* cons *)
       (# S: ^gbeta.StaticComponent
       enter S[]
       <<SLOT do_StaticComponent_body: DoPart>>
       #);
     do_DynamicComponent: (* cons *)
       (# D: ^gbeta.DynamicComponent
       enter D[]
       <<SLOT do_DynamicComponent_body: DoPart>>
       #);
     do_ObjectSpecification: (* alternation *)
       (# O: ^gbeta.ObjectSpecification
       enter O[]
       <<SLOT do_ObjectSpecification_body: DoPart>>
       #);
     do_Merge: (* list *)
       (# M: ^gbeta.Merge
       enter M[]
       <<SLOT do_Merge_body: DoPart>>
       #);
     do_Index: (* alternation *)
       (# I: ^gbeta.Index
       enter I[]
       <<SLOT do_Index_body: DoPart>>
       #);
     do_NamedIndex: (* cons *)
       (# N: ^gbeta.NamedIndex
       enter N[]
       <<SLOT do_NamedIndex_body: DoPart>>
       #);
     do_ActionPart: (* cons *)
       (# A: ^gbeta.ActionPart
       enter A[]
       <<SLOT do_ActionPart_body: DoPart>>
       #);
     do_EnterPartOpt: (* optional *)
       (# a: ^astinterface.ast;
       enter a[]
       <<SLOT do_EnterPartOpt_body: DoPart>>
       #);
     do_DoPartOpt: (* optional *)
       (# a: ^astinterface.ast;
       enter a[]
       <<SLOT do_DoPartOpt_body: DoPart>>
       #);
     do_ExitPartOpt: (* optional *)
       (# a: ^astinterface.ast;
       enter a[]
       <<SLOT do_ExitPartOpt_body: DoPart>>
       #);
     do_EnterPart: (* cons *)
       (# E: ^gbeta.EnterPart
       enter E[]
       <<SLOT do_EnterPart_body: DoPart>>
       #);
     do_DoPart: (* cons *)
       (# D: ^gbeta.DoPart
       enter D[]
       <<SLOT do_DoPart_body: DoPart>>
       #);
     do_ExitPart: (* cons *)
       (# E: ^gbeta.ExitPart
       enter E[]
       <<SLOT do_ExitPart_body: DoPart>>
       #);
     do_Imperatives: (* list *)
       (# I: ^gbeta.Imperatives
       enter I[]
       <<SLOT do_Imperatives_body: DoPart>>
       #);
     do_ImpOpt: (* optional *)
       (# a: ^astinterface.ast;
       enter a[]
       <<SLOT do_ImpOpt_body: DoPart>>
       #);
     do_Imp: (* alternation *)
       (# I: ^gbeta.Imp
       enter I[]
       <<SLOT do_Imp_body: DoPart>>
       #);
     do_LabelledImp: (* cons *)
       (# L: ^gbeta.LabelledImp
       enter L[]
       <<SLOT do_LabelledImp_body: DoPart>>
       #);
     do_ForImp: (* cons *)
       (# F: ^gbeta.ForImp
       enter F[]
       <<SLOT do_ForImp_body: DoPart>>
       #);
     do_RepDo: (* alternation *)
       (# R: ^gbeta.RepDo
       enter R[]
       <<SLOT do_RepDo_body: DoPart>>
       #);
     do_Rep: (* cons *)
       (# R: ^gbeta.Rep
       enter R[]
       <<SLOT do_Rep_body: DoPart>>
       #);
     do_Doit: (* cons *)
       (# D: ^gbeta.Doit
       enter D[]
       <<SLOT do_Doit_body: DoPart>>
       #);
     do_WhileImp: (* cons *)
       (# W: ^gbeta.WhileImp
       enter W[]
       <<SLOT do_WhileImp_body: DoPart>>
       #);
     do_GeneralIfImp: (* cons *)
       (# G: ^gbeta.GeneralIfImp
       enter G[]
       <<SLOT do_GeneralIfImp_body: DoPart>>
       #);
     do_SimpleIfImp: (* cons *)
       (# S: ^gbeta.SimpleIfImp
       enter S[]
       <<SLOT do_SimpleIfImp_body: DoPart>>
       #);
     do_WhenImp: (* cons *)
       (# W: ^gbeta.WhenImp
       enter W[]
       <<SLOT do_WhenImp_body: DoPart>>
       #);
     do_LeaveImp: (* cons *)
       (# L: ^gbeta.LeaveImp
       enter L[]
       <<SLOT do_LeaveImp_body: DoPart>>
       #);
     do_RestartImp: (* cons *)
       (# R: ^gbeta.RestartImp
       enter R[]
       <<SLOT do_RestartImp_body: DoPart>>
       #);
     do_InnerImp: (* cons *)
       (# I: ^gbeta.InnerImp
       enter I[]
       <<SLOT do_InnerImp_body: DoPart>>
       #);
     do_ScopeSpecOpt: (* optional *)
       (# a: ^astinterface.ast;
       enter a[]
       <<SLOT do_ScopeSpecOpt_body: DoPart>>
       #);
     do_ScopeSpec: (* alternation *)
       (# S: ^gbeta.ScopeSpec
       enter S[]
       <<SLOT do_ScopeSpec_body: DoPart>>
       #);
     do_IntegerScopeSpec: (* cons *)
       (# I: ^gbeta.IntegerScopeSpec
       enter I[]
       <<SLOT do_IntegerScopeSpec_body: DoPart>>
       #);
     do_NameAplScopeSpec: (* cons *)
       (# N: ^gbeta.NameAplScopeSpec
       enter N[]
       <<SLOT do_NameAplScopeSpec_body: DoPart>>
       #);
     do_SuspendImp: (* cons *)
       (# S: ^gbeta.SuspendImp
       enter S[]
       <<SLOT do_SuspendImp_body: DoPart>>
       #);
     do_CodeImp: (* cons *)
       (# C: ^gbeta.CodeImp
       enter C[]
       <<SLOT do_CodeImp_body: DoPart>>
       #);
     do_Alternatives: (* list *)
       (# A: ^gbeta.Alternatives
       enter A[]
       <<SLOT do_Alternatives_body: DoPart>>
       #);
     do_Alternative: (* cons *)
       (# A: ^gbeta.Alternative
       enter A[]
       <<SLOT do_Alternative_body: DoPart>>
       #);
     do_Selections: (* list *)
       (# S: ^gbeta.Selections
       enter S[]
       <<SLOT do_Selections_body: DoPart>>
       #);
     do_Selection: (* alternation *)
       (# S: ^gbeta.Selection
       enter S[]
       <<SLOT do_Selection_body: DoPart>>
       #);
     do_CaseSelection: (* cons *)
       (# C: ^gbeta.CaseSelection
       enter C[]
       <<SLOT do_CaseSelection_body: DoPart>>
       #);
     do_WhenAlternatives: (* list *)
       (# W: ^gbeta.WhenAlternatives
       enter W[]
       <<SLOT do_WhenAlternatives_body: DoPart>>
       #);
     do_WhenAlternative: (* cons *)
       (# W: ^gbeta.WhenAlternative
       enter W[]
       <<SLOT do_WhenAlternative_body: DoPart>>
       #);
     do_ElsePartOpt: (* optional *)
       (# a: ^astinterface.ast;
       enter a[]
       <<SLOT do_ElsePartOpt_body: DoPart>>
       #);
     do_ElsePart: (* cons *)
       (# E: ^gbeta.ElsePart
       enter E[]
       <<SLOT do_ElsePart_body: DoPart>>
       #);
     do_Evaluations: (* list *)
       (# E: ^gbeta.Evaluations
       enter E[]
       <<SLOT do_Evaluations_body: DoPart>>
       #);
     do_Evaluation: (* alternation *)
       (# E: ^gbeta.Evaluation
       enter E[]
       <<SLOT do_Evaluation_body: DoPart>>
       #);
     do_AssignmentEvaluation: (* cons *)
       (# A: ^gbeta.AssignmentEvaluation
       enter A[]
       <<SLOT do_AssignmentEvaluation_body: DoPart>>
       #);
     do_Transaction: (* alternation *)
       (# T: ^gbeta.Transaction
       enter T[]
       <<SLOT do_Transaction_body: DoPart>>
       #);
     do_Reference: (* alternation *)
       (# R: ^gbeta.Reference
       enter R[]
       <<SLOT do_Reference_body: DoPart>>
       #);
     do_DynamicObjectGeneration: (* alternation *)
       (# D: ^gbeta.DynamicObjectGeneration
       enter D[]
       <<SLOT do_DynamicObjectGeneration_body: DoPart>>
       #);
     do_ObjectDenotation: (* cons *)
       (# O: ^gbeta.ObjectDenotation
       enter O[]
       <<SLOT do_ObjectDenotation_body: DoPart>>
       #);
     do_ComputedObjectEvaluation: (* cons *)
       (# C: ^gbeta.ComputedObjectEvaluation
       enter C[]
       <<SLOT do_ComputedObjectEvaluation_body: DoPart>>
       #);
     do_ObjectReference: (* cons *)
       (# O: ^gbeta.ObjectReference
       enter O[]
       <<SLOT do_ObjectReference_body: DoPart>>
       #);
     do_StructureReference: (* cons *)
       (# S: ^gbeta.StructureReference
       enter S[]
       <<SLOT do_StructureReference_body: DoPart>>
       #);
     do_EvalList: (* cons *)
       (# E: ^gbeta.EvalList
       enter E[]
       <<SLOT do_EvalList_body: DoPart>>
       #);
     do_DynamicItemGeneration: (* cons *)
       (# D: ^gbeta.DynamicItemGeneration
       enter D[]
       <<SLOT do_DynamicItemGeneration_body: DoPart>>
       #);
     do_DynamicComponentGeneration: (* cons *)
       (# D: ^gbeta.DynamicComponentGeneration
       enter D[]
       <<SLOT do_DynamicComponentGeneration_body: DoPart>>
       #);
     do_Primitive: (* cons *)
       (# P: ^gbeta.Primitive
       enter P[]
       <<SLOT do_Primitive_body: DoPart>>
       #);
     do_Address: (* cons *)
       (# A: ^gbeta.Address
       enter A[]
       <<SLOT do_Address_body: DoPart>>
       #);
     do_AttributeDenotation: (* alternation *)
       (# A: ^gbeta.AttributeDenotation
       enter A[]
       <<SLOT do_AttributeDenotation_body: DoPart>>
       #);
     do_Remote: (* cons *)
       (# R: ^gbeta.Remote
       enter R[]
       <<SLOT do_Remote_body: DoPart>>
       #);
     do_ComputedRemote: (* cons *)
       (# C: ^gbeta.ComputedRemote
       enter C[]
       <<SLOT do_ComputedRemote_body: DoPart>>
       #);
     do_Indexed: (* cons *)
       (# I: ^gbeta.Indexed
       enter I[]
       <<SLOT do_Indexed_body: DoPart>>
       #);
     do_ThisObject: (* cons *)
       (# T: ^gbeta.ThisObject
       enter T[]
       <<SLOT do_ThisObject_body: DoPart>>
       #);
     do_QualifiedAttrDen: (* cons *)
       (# Q: ^gbeta.QualifiedAttrDen
       enter Q[]
       <<SLOT do_QualifiedAttrDen_body: DoPart>>
       #);
     do_RemotePrimitive: (* cons *)
       (# R: ^gbeta.RemotePrimitive
       enter R[]
       <<SLOT do_RemotePrimitive_body: DoPart>>
       #);
     do_Expression: (* alternation *)
       (# E: ^gbeta.Expression
       enter E[]
       <<SLOT do_Expression_body: DoPart>>
       #);
     do_RelationalExp: (* alternation *)
       (# R: ^gbeta.RelationalExp
       enter R[]
       <<SLOT do_RelationalExp_body: DoPart>>
       #);
     do_SimpleExp: (* alternation *)
       (# S: ^gbeta.SimpleExp
       enter S[]
       <<SLOT do_SimpleExp_body: DoPart>>
       #);
     do_AddExp: (* alternation *)
       (# A: ^gbeta.AddExp
       enter A[]
       <<SLOT do_AddExp_body: DoPart>>
       #);
     do_SignedTerm: (* alternation *)
       (# S: ^gbeta.SignedTerm
       enter S[]
       <<SLOT do_SignedTerm_body: DoPart>>
       #);
     do_Term: (* alternation *)
       (# T: ^gbeta.Term
       enter T[]
       <<SLOT do_Term_body: DoPart>>
       #);
     do_MulExp: (* alternation *)
       (# M: ^gbeta.MulExp
       enter M[]
       <<SLOT do_MulExp_body: DoPart>>
       #);
     do_EqExp: (* cons *)
       (# E: ^gbeta.EqExp
       enter E[]
       <<SLOT do_EqExp_body: DoPart>>
       #);
     do_LtExp: (* cons *)
       (# L: ^gbeta.LtExp
       enter L[]
       <<SLOT do_LtExp_body: DoPart>>
       #);
     do_LeExp: (* cons *)
       (# L: ^gbeta.LeExp
       enter L[]
       <<SLOT do_LeExp_body: DoPart>>
       #);
     do_GtExp: (* cons *)
       (# G: ^gbeta.GtExp
       enter G[]
       <<SLOT do_GtExp_body: DoPart>>
       #);
     do_GeExp: (* cons *)
       (# G: ^gbeta.GeExp
       enter G[]
       <<SLOT do_GeExp_body: DoPart>>
       #);
     do_NeExp: (* cons *)
       (# N: ^gbeta.NeExp
       enter N[]
       <<SLOT do_NeExp_body: DoPart>>
       #);
     do_PlusExp: (* cons *)
       (# P: ^gbeta.PlusExp
       enter P[]
       <<SLOT do_PlusExp_body: DoPart>>
       #);
     do_MinusExp: (* cons *)
       (# M: ^gbeta.MinusExp
       enter M[]
       <<SLOT do_MinusExp_body: DoPart>>
       #);
     do_OrExp: (* cons *)
       (# O: ^gbeta.OrExp
       enter O[]
       <<SLOT do_OrExp_body: DoPart>>
       #);
     do_XorExp: (* cons *)
       (# X: ^gbeta.XorExp
       enter X[]
       <<SLOT do_XorExp_body: DoPart>>
       #);
     do_UnaryPlusExp: (* cons *)
       (# U: ^gbeta.UnaryPlusExp
       enter U[]
       <<SLOT do_UnaryPlusExp_body: DoPart>>
       #);
     do_UnaryMinusExp: (* cons *)
       (# U: ^gbeta.UnaryMinusExp
       enter U[]
       <<SLOT do_UnaryMinusExp_body: DoPart>>
       #);
     do_TimesExp: (* cons *)
       (# T: ^gbeta.TimesExp
       enter T[]
       <<SLOT do_TimesExp_body: DoPart>>
       #);
     do_RealDivExp: (* cons *)
       (# R: ^gbeta.RealDivExp
       enter R[]
       <<SLOT do_RealDivExp_body: DoPart>>
       #);
     do_IntDivExp: (* cons *)
       (# I: ^gbeta.IntDivExp
       enter I[]
       <<SLOT do_IntDivExp_body: DoPart>>
       #);
     do_ModExp: (* cons *)
       (# M: ^gbeta.ModExp
       enter M[]
       <<SLOT do_ModExp_body: DoPart>>
       #);
     do_AndExp: (* cons *)
       (# A: ^gbeta.AndExp
       enter A[]
       <<SLOT do_AndExp_body: DoPart>>
       #);
     do_PrimitiveExp: (* cons *)
       (# P: ^gbeta.PrimitiveExp
       enter P[]
       <<SLOT do_PrimitiveExp_body: DoPart>>
       #);
     do_Factor: (* alternation *)
       (# F: ^gbeta.Factor
       enter F[]
       <<SLOT do_Factor_body: DoPart>>
       #);
     do_RepetitionSlice: (* cons *)
       (# R: ^gbeta.RepetitionSlice
       enter R[]
       <<SLOT do_RepetitionSlice_body: DoPart>>
       #);
     do_NotExp: (* cons *)
       (# N: ^gbeta.NotExp
       enter N[]
       <<SLOT do_NotExp_body: DoPart>>
       #);
     do_NoneExp: (* cons *)
       (# N: ^gbeta.NoneExp
       enter N[]
       <<SLOT do_NoneExp_body: DoPart>>
       #);
     do_UnaryPrimitiveExp: (* cons *)
       (# U: ^gbeta.UnaryPrimitiveExp
       enter U[]
       <<SLOT do_UnaryPrimitiveExp_body: DoPart>>
       #);
     do_Names: (* list *)
       (# N: ^gbeta.Names
       enter N[]
       <<SLOT do_Names_body: DoPart>>
       #);
     do_NameDcl: (* cons *)
       (# N: ^gbeta.NameDcl
       enter N[]
       <<SLOT do_NameDcl_body: DoPart>>
       #);
     do_NameApl: (* cons *)
       (# N: ^gbeta.NameApl
       enter N[]
       <<SLOT do_NameApl_body: DoPart>>
       #);
     do_SimpleEntry: (* optional *)
       (# a: ^astinterface.ast;
       enter a[]
       <<SLOT do_SimpleEntry_body: DoPart>>
       #);
     do_TextConst: (* cons *)
       (# T: ^gbeta.TextConst
       enter T[]
       <<SLOT do_TextConst_body: DoPart>>
       #);
     do_IntegerConst: (* cons *)
       (# I: ^gbeta.IntegerConst
       enter I[]
       <<SLOT do_IntegerConst_body: DoPart>>
       #);
     do_SimpleIndex: (* cons *)
       (# S: ^gbeta.SimpleIndex
       enter S[]
       <<SLOT do_SimpleIndex_body: DoPart>>
       #);
     do_CodeItems: (* list *)
       (# C: ^gbeta.CodeItems
       enter C[]
       <<SLOT do_CodeItems_body: DoPart>>
       #);
     do_CodeItem: (* alternation *)
       (# C: ^gbeta.CodeItem
       enter C[]
       <<SLOT do_CodeItem_body: DoPart>>
       #);
     do_CodeString: (* cons *)
       (# C: ^gbeta.CodeString
       enter C[]
       <<SLOT do_CodeString_body: DoPart>>
       #);
     do_CodeConst: (* cons *)
       (# C: ^gbeta.CodeConst
       enter C[]
       <<SLOT do_CodeConst_body: DoPart>>
       #);
     do_ErrorDecl: (* cons *)
       (# E: ^gbeta.ErrorDecl
       enter E[]
       <<SLOT do_ErrorDecl_body: DoPart>>
       #);
     do_ErrorImp: (* cons *)
       (# E: ^gbeta.ErrorImp
       enter E[]
       <<SLOT do_ErrorImp_body: DoPart>>
       #);

     do_nameDecl: (* lexem *)
       (# n: ^astinterface.nameDecl;
          getText: (# exit n.getText #);
       enter n[] 
       do INNER;
       #);
     do_nameAppl: (* lexem *)
       (# n: ^astinterface.nameAppl;
          getText: (# exit n.getText #);
       enter n[] 
       do INNER;
       #);
     do_const: (* lexem *)
       (# c: ^astinterface.const;
          getText: (# exit c.getText #);
          getValue: (# exit c.getValue #);
       enter c[] 
       do INNER;
       #);
     do_string: (* lexem *)
       (# s: ^astinterface.string;
          getText: (# exit s.getText #);
       enter s[] 
       do INNER;
       #);
     init: (* Initialization of astLevel and parser *)
       (# 
       <<SLOT gbeta_init_body: DoPart>>
       #);
  #);
