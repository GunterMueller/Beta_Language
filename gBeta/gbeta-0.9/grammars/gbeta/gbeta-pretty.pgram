--- gbeta : prettyprint : prettyprint --- 
PrettyPrintScheme gbetaSpec
for gbeta:
BetaForm	=  N:1 ;
DescriptorForm	=  N:1;
AttributesForm	=  N:1;
ObjectDescriptor	= [c  N:1 $1,2 N:2];
MainPart	=  N:1 ;
LongMainPart	= [c  T:1 $1,0 * $1,2 N:1 $1,2 N:2 $1,0 T:2];
ShortMainPart	= [c  T:1 $1,0 * $1,2 N:1 $1,2 N:2 $1,0 T:2];
Attributes	=  ( {c T:1 $1,0 } );
PrefixOpt	=  N:1 ;
Prefix	=  N:1 ;
SimplePrefix	=  N:1;
CompositePrefix	= [c  T:1 $1,0 * $1,0 T:2 $1,2 N:1 $1,0 T:3 $1,0 T:4];
AttributeDeclOpt	=  N:1 ;
AttributeDecl	=  N:1 ;
PatternDecl	= [c  N:1 $1,0 T:1 $1,0 * $1,2 N:2];
SimpleDecl	= [c  N:1 $1,0 T:1 $1,0 * $1,2 N:2];
RepetitionDecl	= [c  N:1 $1,0 T:1 $1,0 * $1,0 T:2 $1,2 N:2 $1,0 T:3 $1,2 N:3];
VirtualDecl	= [c  N:1 $1,0 T:1 $1,0 * $1,0 T:2 $1,2 N:2 $1,2 N:3 $1,2 N:4];
BindingDecl	= [c  N:1 $1,0 T:1 $1,0 * $1,0 T:2 $1,0 T:3 $1,2 N:2 $1,2 N:3 $1,2 N:4 $1,2 N:5];
FinalDecl	= [c  N:1 $1,0 T:1 $1,0 * $1,0 T:2 $1,2 N:2 $1,2 N:3];
DisownOpt	=  N:1 ;
Disown	=  T:1 $1,0 *;
SwapOpt	=  N:1 ;
Swap	=  T:1 $1,0 *;
RestrictionOpt	=  N:1 ;
RestrictionPart	= [c  T:1 $1,0 * $1,0 T:2 $1,2 N:1];
Restrictions	=  ( {c T:1 $1,0 } );
Restriction	=  N:1;
VariablePattern	= [c  T:1 $1,0 * $1,2 N:1];
ReferenceSpecification	=  N:1 ;
StaticItem	= [c  T:1 $1,0 * $1,2 N:1];
VirtualStaticItem	= [c  T:1 $1,0 * $1,2 N:1 $1,0 T:2 $1,2 N:2];
FinalStaticItem	= [c  T:1 $1,0 * $1,0 T:2 $1,2 N:1];
DynamicItem	= [c  T:1 $1,0 * $1,2 N:1 $1,2 N:2];
ExactOpt	=  N:1 ;
Exact	=  T:1 $1,0 *;
StaticComponent	= [c  T:1 $1,0 * $1,0 T:2 $1,2 N:1];
DynamicComponent	= [c  T:1 $1,0 * $1,0 T:2 $1,2 N:1 $1,2 N:2];
ObjectSpecification	=  N:1 ;
Merge	=  ( {c T:1 $1,0 } );
Index	=  N:1 ;
NamedIndex	= [c  N:1 $1,0 T:1 $1,0 * $1,2 N:2];
ActionPart	= [c  N:1 $1,2 N:2 $1,2 N:3];
EnterPartOpt	=  N:1 ;
DoPartOpt	=  N:1 ;
ExitPartOpt	=  N:1 ;
EnterPart	= [c  T:1 $1,0 * $1,2 N:1];
DoPart	= [c  T:1 $1,0 * $1,2 N:1];
ExitPart	= [c  T:1 $1,0 * $1,2 N:1];
Imperatives	=  ( {c T:1 $1,0 } );
ImpOpt	=  N:1 ;
Imp	=  N:1 ;
LabelledImp	= [c  N:1 $1,0 T:1 $1,0 * $1,2 N:2];
ForImp	= [c  T:1 $1,0 * $1,0 T:2 $1,2 N:1 $1,2 N:2 $1,2 N:3 $1,0 T:3 $1,0 T:4];
RepDo	=  N:1 ;
Rep	=  T:1 $1,0 *;
Doit	=  T:1 $1,0 *;
WhileImp	= [c  T:1 $1,0 * $1,0 T:2 $1,2 N:1 $1,2 N:2 $1,2 N:3 $1,0 T:3 $1,0 T:4];
GeneralIfImp	= [c  T:1 $1,0 * $1,0 T:2 $1,2 N:1 $1,2 N:2 $1,2 N:3 $1,0 T:3 $1,0 T:4];
SimpleIfImp	= [c  T:1 $1,0 * $1,0 T:2 $1,2 N:1 $1,0 T:3 $1,2 N:2 $1,2 N:3 $1,0 T:4 $1,0 T:5];
WhenImp	= [c  T:1 $1,0 * $1,0 T:2 $1,2 N:1 $1,0 T:3 $1,2 N:2 $1,2 N:3 $1,2 N:4 $1,0 T:4 $1,0 T:5];
LeaveImp	= [c  T:1 $1,0 * $1,2 N:1];
RestartImp	= [c  T:1 $1,0 * $1,2 N:1];
InnerImp	= [c  T:1 $1,0 * $1,2 N:1];
ScopeSpecOpt	=  N:1 ;
ScopeSpec	=  N:1 ;
IntegerScopeSpec	=  N:1;
NameAplScopeSpec	=  N:1;
SuspendImp	=  T:1 $1,0 *;
CodeImp	= [c  T:1 $1,0 * $1,0 T:2 $1,2 N:1 $1,0 T:3 $1,0 T:4];
Alternatives	=  ( {c $1,0 } );
Alternative	= [c  N:1 $1,0 T:1 $1,0 * $1,2 N:2];
Selections	=  ( {c $1,0 } );
Selection	=  N:1 ;
CaseSelection	= [c  T:1 $1,0 * $1,2 N:1];
WhenAlternatives	=  ( {c $1,0 } );
WhenAlternative	= [c  T:1 $1,0 * $1,2 N:1 $1,2 N:2 $1,0 T:2 $1,2 N:3];
ElsePartOpt	=  N:1 ;
ElsePart	= [c  T:1 $1,0 * $1,2 N:1];
Evaluations	=  ( {c T:1 $1,0 } );
Evaluation	=  N:1 ;
AssignmentEvaluation	= [c  N:1 $1,0 T:1 $1,0 * $1,2 N:2];
Transaction	=  N:1 ;
Reference	=  N:1 ;
DynamicObjectGeneration	=  N:1 ;
ObjectDenotation	=  N:1;
ComputedObjectEvaluation	= [c  N:1 $1,0 T:1 $1,0 *];
ObjectReference	= [c  N:1 $1,0 T:1 $1,0 *];
StructureReference	= [c  N:1 $1,0 T:1 $1,0 *];
EvalList	= [c  T:1 $1,0 * $1,2 N:1 $1,0 T:2];
DynamicItemGeneration	= [c  T:1 $1,0 * $1,2 N:1];
DynamicComponentGeneration	= [c  T:1 $1,0 * $1,0 T:2 $1,2 N:1];
Primitive	= [c  T:1 $1,0 * $1,2 N:1];
Address	= [c  T:1 $1,0 * $1,2 N:1];
AttributeDenotation	=  N:1 ;
Remote	= [c  N:1 $1,0 T:1 $1,0 * $1,2 N:2];
ComputedRemote	= [c  T:1 $1,0 * $1,2 N:1 $1,0 T:2 $1,0 T:3 $1,2 N:2];
Indexed	= [c  N:1 $1,0 T:1 $1,0 * $1,2 N:2 $1,0 T:2];
ThisObject	= [c  T:1 $1,0 * $1,0 T:2 $1,2 N:1 $1,0 T:3];
QualifiedAttrDen	= [c  N:1 $1,0 T:1 $1,0 * $1,0 T:2 $1,2 N:2 $1,0 T:3 $1,0 T:4];
RemotePrimitive	= [c  N:1 $1,0 T:1 $1,0 * $1,2 N:2];
Expression	=  N:1 ;
RelationalExp	=  N:1 ;
SimpleExp	=  N:1 ;
AddExp	=  N:1 ;
SignedTerm	=  N:1 ;
Term	=  N:1 ;
MulExp	=  N:1 ;
EqExp	= [c  N:1 $1,0 T:1 $1,0 * $1,2 N:2];
LtExp	= [c  N:1 $1,0 T:1 $1,0 * $1,2 N:2];
LeExp	= [c  N:1 $1,0 T:1 $1,0 * $1,2 N:2];
GtExp	= [c  N:1 $1,0 T:1 $1,0 * $1,2 N:2];
GeExp	= [c  N:1 $1,0 T:1 $1,0 * $1,2 N:2];
NeExp	= [c  N:1 $1,0 T:1 $1,0 * $1,2 N:2];
PlusExp	= [c  N:1 $1,0 T:1 $1,0 * $1,2 N:2];
MinusExp	= [c  N:1 $1,0 T:1 $1,0 * $1,2 N:2];
OrExp	= [c  N:1 $1,0 T:1 $1,0 * $1,2 N:2];
XorExp	= [c  N:1 $1,0 T:1 $1,0 * $1,2 N:2];
UnaryPlusExp	= [c  T:1 $1,0 * $1,2 N:1];
UnaryMinusExp	= [c  T:1 $1,0 * $1,2 N:1];
TimesExp	= [c  N:1 $1,0 T:1 $1,0 * $1,2 N:2];
RealDivExp	= [c  N:1 $1,0 T:1 $1,0 * $1,2 N:2];
IntDivExp	= [c  N:1 $1,0 T:1 $1,0 * $1,2 N:2];
ModExp	= [c  N:1 $1,0 T:1 $1,0 * $1,2 N:2];
AndExp	= [c  N:1 $1,0 T:1 $1,0 * $1,2 N:2];
PrimitiveExp	= [c  N:1 $1,0 T:1 $1,0 * $1,2 N:2 $1,2 N:3];
Factor	=  N:1 ;
RepetitionSlice	= [c  N:1 $1,0 T:1 $1,0 * $1,2 N:2 $1,0 T:2 $1,2 N:3 $1,0 T:3];
NotExp	= [c  T:1 $1,0 * $1,2 N:1];
NoneExp	=  T:1 $1,0 *;
UnaryPrimitiveExp	= [c  T:1 $1,0 * $1,2 N:1 $1,2 N:2];
Names	=  ( {c T:1 $1,0 } );
NameDcl	=  N:1;
NameApl	=  N:1;
SimpleEntry	=  N:1 ;
TextConst	=  N:1;
IntegerConst	=  N:1;
SimpleIndex	=  N:1;
CodeItems	=  ( {c T:1 $1,0 } );
CodeItem	=  N:1 ;
CodeString	=  N:1;
CodeConst	=  N:1;
ErrorDecl	= ;
ErrorImp	= 
