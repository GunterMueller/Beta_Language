(* FILE "./private/ibetaVirtualMachinelib.bet"
 *
 * Copyright (C) 1997-2001 Erik Ernst
 *
 * This file is part of "gbeta" -- a generalized version of the
 * programming language BETA.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is destributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * Among other things, the copyright notice and this notice must be
 * preserved on all copies.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program, probably in a file named COPYING; if not,
 * write to the Free Software Foundation, Inc., 675 Mass Ave,
 * Cambridge, MA 02139, USA.
 *
 * To contact the author by email: eernst@cs.auc.dk
 *
 * To contact the author by snail-mail:
 *    Erik Ernst
 *    Department of Computer Science
 *    University of Aalborg
 *    DK-9220 Aalborg OE
 *    Denmark
 *
 * $Id: ibetaVirtualMachinelib.bet,v 1.57 2001/07/01 21:44:11 eernst Exp $
 *)

ORIGIN '../basicinterp';
INCLUDE '../ibetaCommon';
INCLUDE '../ibetaTwo';
INCLUDE '../ibetaOne';
INCLUDE '../ibetaSType';
BODY 'ibetaVirtualMachinelibbody';
BODY 'ibetaVirtualMachineli2body';
BODY 'ibetaVirtualMachineli3body';
BODY 'ibetaVirtualMachineli4body'

-- interpreterBaseLib:attributes --

(************************************************************
 *                                                          *
 *                   BETA Virtual Machine                   *
 *                                                          *
 ************************************************************)

callDoCode: betaByteCode
  (* Byte code for the execution of a dopart of an object *)
  (# <<SLOT CallDoCodeLib:attributes>>;
     selfType::callDoCode;
     init::(# enter where[] #);
     typename::(# do 'CALL'->value.puttext #);
     shortTypename::(# do 'call'->value.puttext #);
     print::(# <<SLOT CallDoCodePrint:dopart>> #);
     printShort::(# <<SLOT CallDoCodePrintShort:dopart>> #);
     printCode::(# <<SLOT CallDoCodePrintCode:dopart>> #);
     execute::
       (# fail:
            (* this would be a 'for/when/whenalt/label/rep' substance, 
             * hence nothing we expect to execute from bytecode *)
            (# msg: ^text
            do 'Unexpected kind of substance executed from byte-code ('->msg[];
               target.typename->msg.puttext;
               ')'->msg.puttext;
               msg[]->internalError
            #);
          target: ^substanceSlice;
          l1ent: ^l1Entity;
          oSlice: ^objectSlice;
          lstep: ^runtimeLookupStep;
          listep: ^runtimeLookupIndirectStep;
          tstep: ^runtimeTmpStep
       <<SLOT CallDoCodeExecute:dopart>> 
       #);
     where: ^runtimePath
  #);

literalBooleanCode: betaByteCode
  (* Byte code for putting a literal boolean value on the stack *)
  (# <<SLOT LiteralBooleanCodeLib:attributes>>;
     selfType::literalBooleanCode;
     init::(# enter value #);
     typename::(# do 'PUSHI-boolean'->value.puttext #);
     shortTypename::(# do 'lb'->value.puttext #);
     print::(# <<SLOT LiteralBooleanCodePrint:dopart>> #);
     printShort::(# <<SLOT LiteralBooleanCodePrintShort:dopart>> #);
     printCode::(# <<SLOT LiteralBooleanCodePrintCode:dopart>> #);
     execute::(# <<SLOT LiteralBooleanCodeExecute:dopart>> #);
     value: @boolean
  #);

literalCharCode: betaByteCode
  (* Byte code for putting a literal char value on the stack *)
  (# <<SLOT LiteralCharCodeLib:attributes>>;
     selfType::literalCharCode;
     init::(# enter value #);
     typename::(# do 'PUSHI-char'->value.puttext #);
     shortTypename::(# do 'lc'->value.puttext #);
     print::(# <<SLOT LiteralCharCodePrint:dopart>> #);
     printShort::(# <<SLOT LiteralCharCodePrintShort:dopart>> #);
     printCode::(# <<SLOT LiteralCharCodePrintCode:dopart>> #);
     execute::(# <<SLOT LiteralCharCodeExecute:dopart>> #);
     value: @char
  #);

literalIntegerCode: betaByteCode
  (* Byte code for putting a literal integer value on the stack *)
  (# <<SLOT LiteralIntegerCodeLib:attributes>>;
     selfType::literalIntegerCode;
     init::(# enter value #);
     typename::(# do 'PUSHI-integer'->value.puttext #);
     shortTypename::(# do 'li'->value.puttext #);
     print::(# <<SLOT LiteralIntegerCodePrint:dopart>> #);
     printShort::(# <<SLOT LiteralIntegerCodePrintShort:dopart>> #);
     printCode::(# <<SLOT LiteralIntegerCodePrintCode:dopart>> #);
     execute::(# <<SLOT LiteralIntegerCodeExecute:dopart>> #);
     value: @integer
  #);

literalRealCode: betaByteCode
  (* Byte code for putting a literal real value on the stack *)
  (# <<SLOT LiteralRealCodeLib:attributes>>;
     selfType::literalRealCode;
     init::(# enter value #);
     typename::(# do 'PUSHI-real'->value.puttext #);
     shortTypename::(# do 'lr'->value.puttext #);
     print::(# <<SLOT LiteralRealCodePrint:dopart>> #);
     printShort::(# <<SLOT LiteralRealCodePrintShort:dopart>> #);
     printCode::(# <<SLOT LiteralRealCodePrintCode:dopart>> #);
     execute::(# <<SLOT LiteralRealCodeExecute:dopart>> #);
     value: @real
  #);

literalStringCode: betaByteCode
  (* Byte code for putting a literal string value on the stack *)
  (# <<SLOT LiteralStringCodeLib:attributes>>;
     selfType::literalStringCode;
     init::(# enter value[] #);
     typename::(# do 'PUSHI-string'->value.puttext #);
     shortTypename::(# do 'ls'->value.puttext #);
     print::(# <<SLOT LiteralStringCodePrint:dopart>> #);
     printShort::(# <<SLOT LiteralStringCodePrintShort:dopart>> #);
     printCode::(# <<SLOT LiteralStringCodePrintCode:dopart>> #);
     execute::(# <<SLOT LiteralStringCodeExecute:dopart>> #);
     value: ^text
  #);

noneObjectCode: betaByteCode
  (* Byte code for putting the value NONE on the 'objRefs' stack *)
  (# <<SLOT NoneObjectCodeLib:attributes>>;
     selfType::noneObjectCode;
     typename::(# do 'PUSHI_NONE(obj)'->value.puttext #);
     shortTypename::(# do 'none(o)'->value.puttext #);
     execute::(# <<SLOT NoneObjectCodeExecute:dopart>> #)
  #);

nonePatternCode: betaByteCode
  (* Byte code for putting the value NONE on the 'patterns' stack *)
  (# <<SLOT NonePatternCodeLib:attributes>>;
     selfType::nonePatternCode;
     typename::(# do 'PUSHI_NONE(ptn)'->value.puttext #);
     shortTypename::(# do 'none(p)'->value.puttext #);
     execute::(# <<SLOT NonePatternCodeExecute:dopart>> #)
  #);

accessCode: betaByteCode
  (* Byte codes for getting or putting the state 
   * of an entity reachable via the 'where' path *)
  (# <<SLOT AccessCodeLib:attributes>>;
     selfType::< accessCode;
     init::< (# enter where[] do INNER #);
     print::< (# <<SLOT AccessCodePrint:dopart>> #);
     printShort::< (# <<SLOT AccessCodePrintShort:dopart>> #);
     printCode::< (# <<SLOT AccessCodePrintCode:dopart>> #);
     execute::< 
       (# fail: (# <<SLOT AccessCodeFail:dopart>> #);
          targetContext: ^substanceSlice
       <<SLOT AccessCodeExecute:dopart>>
       #);
     where: ^runtimePath
  #);

getCode: accessCode
  (* Byte code for getting state from a reachable entity *)
  (# <<SLOT GetCodeLib:attributes>>;
     selfType::< getCode;
     typename::< (# do 'PUSH-'->value.puttext; INNER #);
     shortTypename::< (# do 'g'->value.puttext; INNER #);
  #);

getBooleanCode: getCode
  (# <<SLOT GetBooleanCodeLib:attributes>>;
     selfType::getBooleanCode;
     typename::(# do 'boolean'->value.puttext #);
     shortTypename::(# do 'b'->value.puttext #);
     execute::(# <<SLOT GetBooleanCodeExecute:dopart>> #);
     boSlice: ^booleanObjectSlice
  #);

getCharCode: getCode
  (# <<SLOT GetCharCodeLib:attributes>>;
     selfType::getCharCode;
     typename::(# do 'char'->value.puttext #);
     shortTypename::(# do 'c'->value.puttext #);
     execute::(# <<SLOT GetCharCodeExecute:dopart>> #);
     coSlice: ^charObjectSlice
  #);

getIntegerCode: getCode
  (# <<SLOT GetIntegerCodeLib:attributes>>;
     selfType::getIntegerCode;
     typename::(# do 'integer'->value.puttext #);
     shortTypename::(# do 'i'->value.puttext #);
     execute::(# <<SLOT GetIntegerCodeExecute:dopart>> #);
     ioSlice: ^integerObjectSlice
  #);

getRealCode: getCode
  (# <<SLOT GetRealCodeLib:attributes>>;
     selfType::getRealCode;
     typename::(# do 'real'->value.puttext #);
     shortTypename::(# do 'r'->value.puttext #);
     execute::(# <<SLOT GetRealCodeExecute:dopart>> #);
     roSlice: ^realObjectSlice
  #);

getStringCode: getCode
  (# <<SLOT GetStringCodeLib:attributes>>;
     selfType::getStringCode;
     typename::(# do 'string'->value.puttext #);
     shortTypename::(# do 's'->value.puttext #);
     execute::(# <<SLOT GetStringCodeExecute:dopart>> #);
     soSlice: ^stringObjectSlice
  #);

getObjectCode: getCode
  (# <<SLOT GetObjectCodeLib:attributes>>;
     selfType::getObjectCode;
     init::(# enter sptype[] #);
     typename::(# do 'obj'->value.puttext #);
     shortTypename::(# do 'o'->value.puttext #);
     print::(# <<SLOT GetObjectCodePrint:dopart>> #);
     printShort::(# <<SLOT GetObjectCodePrintShort:dopart>> #);
     printCode::(# <<SLOT GetObjectCodePrintCode:dopart>> #);
     execute::
       (# oSlice: ^objectSlice;
          lstep: ^runtimeLookupStep;
          listep: ^runtimeLookupIndirectStep;
          l1oref: ^l1ObjectRefEntity
       <<SLOT GetObjectCodeExecute:dopart>> 
       #);
     sptype: ^staticPatternType         (* static type of object *)
  #);

getObjectRefCode: getCode
  (# <<SLOT GetObjectRefCodeLib:attributes>>;
     selfType::getObjectRefCode;
     init::(# enter sptype[] #);
     typename::(# do 'objref'->value.puttext #);
     shortTypename::(# do 'or'->value.puttext #);
     print::(# <<SLOT GetObjectRefCodePrint:dopart>> #);
     printShort::(# <<SLOT GetObjectRefCodePrintShort:dopart>> #);
     printCode::(# <<SLOT GetObjectRefCodePrintCode:dopart>> #);
     execute::
       (# oSlice: ^objectSlice;
          coSlice: ^compositeObjectSlice;
          listep: ^runtimeLookupIndirectStep;
          l1oref: ^l1ObjectRefEntity
       <<SLOT GetObjectRefCodeExecute:dopart>> 
       #);
     sptype: ^staticPatternType         (* static qual. of object *)
  #);

checkNoneOrefCode: betaByteCode
  (# <<SLOT checkNoneOrefCodeLib:attributes>>;
     selfType::checkNoneOrefCode;
     typename::(# do 'CHK_NONE'->value.puttext #);
     shortTypename::(# do 'none?'->value.puttext #);
     execute::(# <<SLOT CheckNoneOrefCodeExecute:dopart>> #)
  #);

getQualificationCode: getCode
  (# <<SLOT GetQualificationCodeLib:attributes>>;
     selfType::getQualificationCode;
     init::(# enter (l2ndcl[],sptype[]) #);
     typename::(# do 'qual'->value.puttext #);
     shortTypename::(# do 'orq'->value.puttext #);
     print::(# <<SLOT GetQualificationCodePrint:dopart>> #);
     printShort::(# <<SLOT GetQualificationCodePrintShort:dopart>> #);
     printCode::(# <<SLOT GetQualificationCodePrintCode:dopart>> #);
     execute::
       (# l1oref: ^l1ObjectRefEntity
       <<SLOT GetQualificationCodeExecute:dopart>> 
       #);
     l2ndcl: ^l2NameDcl;                (* declares the ref.attr. *)
     sptype: ^staticPatternType         (* static qual. of object *)
  #);

getPatternCode: getCode
  (# <<SLOT GetPatternCodeLib:attributes>>;
     selfType::getPatternCode;
     init::(# enter sptype[] #);
     typename::(# do 'ptn'->value.puttext #);
     shortTypename::(# do 'p'->value.puttext #);
     print::(# <<SLOT GetPatternCodePrint:dopart>> #);
     printShort::(# <<SLOT GetPatternCodePrintShort:dopart>> #);
     printCode::(# <<SLOT GetPatternCodePrintCode:dopart>> #);
     execute::(# <<SLOT GetPatternCodeExecute:dopart>> #);
     sptype: ^staticPatternType         (* statically known value *)
  #);

getStaticPatternCode: betaByteCode
  (# <<SLOT GetStaticPatternCodeLib:attributes>>;
     selfType::getStaticPatternCode;
     init::(# enter sptype[] <<SLOT GetStaticPatternCodeInit:dopart>> #);
     typename::(# do 'PUSH-static-ptn'->value[] #);
     shortTypename::(# do 'sp'->value.puttext #);
     print::(# <<SLOT GetStaticPatternCodePrint:dopart>> #);
     printShort::(# <<SLOT GetStaticPatternCodePrintShort:dopart>> #);
     printCode::(# <<SLOT GetStaticPatternCodePrintCode:dopart>> #);
     printStaticPattern::(# <<SLOT GetStaticPatternCodePrintSP:dopart>> #);
     execute::
       (# l1pat: ^l1PatternEntity
       <<SLOT GetStaticPatternCodeExecute:dopart>> 
       #);
     sptype: ^staticPatternType;        (* static. known val & run-time val *)
     mark: @integer
  #);

getPatternRefCode: getCode
  (# <<SLOT GetPatternRefCodeLib:attributes>>;
     selfType::getPatternRefCode;
     init::(# enter sptype[] #);
     typename::(# do 'ptnref'->value.puttext #);
     shortTypename::(# do 'pr'->value.puttext #);
     print::(# <<SLOT GetPatternRefCodePrint:dopart>> #);
     printShort::(# <<SLOT GetPatternRefCodePrintShort:dopart>> #);
     printCode::(# <<SLOT GetPatternRefCodePrintCode:dopart>> #);
     execute::(# <<SLOT GetPatternRefCodeExecute:dopart>> #);
     sptype: ^staticPatternType         (* statically known value *)
  #);

getObjectPatternCode: betaByteCode
  (# <<SLOT GetObjectPatternCodeLib:attributes>>;
     selfType::getObjectPatternCode;
     typename::(# do 'PUSH-ptn_"object"'->value.puttext #);
     shortTypename::(# do '"object"'->value.puttext #);
     execute::(# <<SLOT GetObjectPatternCodeExecute:dopart>> #)
  #);

getBooleanPatternCode: betaByteCode
  (# <<SLOT GetBooleanPatternCodeLib:attributes>>;
     selfType::getBooleanPatternCode;
     typename::(# do 'PUSH-ptn_"boolean"'->value.puttext #);
     shortTypename::(# do '"boolean"'->value.puttext #);
     execute::(# <<SLOT GetBooleanPatternCodeExecute:dopart>> #)
  #);

getCharPatternCode: betaByteCode
  (# <<SLOT GetCharPatternCodeLib:attributes>>;
     selfType::getCharPatternCode;
     typename::(# do 'PUSH-ptn_"char"'->value.puttext #);
     shortTypename::(# do '"char"'->value.puttext #);
     execute::(# <<SLOT GetCharPatternCodeExecute:dopart>> #)
  #);

getIntegerPatternCode: betaByteCode
  (# <<SLOT GetIntegerPatternCodeLib:attributes>>;
     selfType::getIntegerPatternCode;
     typename::(# do 'PUSH-ptn_"integer"'->value.puttext #);
     shortTypename::(# do '"integer"'->value.puttext #);
     execute::(# <<SLOT GetIntegerPatternCodeExecute:dopart>> #)
  #);

getRealPatternCode: betaByteCode
  (# <<SLOT GetRealPatternCodeLib:attributes>>;
     selfType::getRealPatternCode;
     typename::(# do 'PUSH-ptn_"real"'->value.puttext #);
     shortTypename::(# do '"real"'->value.puttext #);
     execute::(# <<SLOT GetRealPatternCodeExecute:dopart>> #)
  #);

getStringPatternCode: betaByteCode
  (# <<SLOT GetStringPatternCodeLib:attributes>>;
     selfType::getStringPatternCode;
     typename::(# do 'PUSH-ptn_"string"'->value.puttext #);
     shortTypename::(# do '"string"'->value.puttext #);
     execute::(# <<SLOT GetStringPatternCodeExecute:dopart>> #)
  #);

getComponentPatternCode: betaByteCode
  (# <<SLOT GetComponentPatternCodeLib:attributes>>;
     selfType::getComponentPatternCode;
     typename::(# do 'PUSH-ptn_"component"'->value.puttext #);
     shortTypename::(# do '"component"'->value.puttext #);
     execute::(# <<SLOT GetComponentPatternCodeExecute:dopart>> #)
  #);

getSemaphorePatternCode: betaByteCode
  (# <<SLOT GetSemaphorePatternCodeLib:attributes>>;
     selfType::getSemaphorePatternCode;
     typename::(# do 'PUSH-ptn_"semaphore"'->value.puttext #);
     shortTypename::(# do '"semaphore"'->value.puttext #);
     execute::(# <<SLOT GetSemaphorePatternCodeExecute:dopart>> #)
  #);

getObjectObjectCode: betaByteCode
  (# <<SLOT GetObjectObjectCodeLib:attributes>>;
     selfType::getObjectObjectCode;
     typename::(# do 'PUSH-obj_"object"'->value.puttext #);
     shortTypename::(# do 'obj-"object"'->value.puttext #);
     execute::(# <<SLOT GetObjectObjectCodeExecute:dopart>> #)
  #);

getBooleanObjectCode: betaByteCode
  (# <<SLOT GetBooleanObjectCodeLib:attributes>>;
     selfType::getBooleanObjectCode;
     typename::(# do 'PUSH-obj_"boolean"'->value.puttext #);
     shortTypename::(# do 'obj-"boolean"'->value.puttext #);
     execute::(# <<SLOT GetBooleanObjectCodeExecute:dopart>> #)
  #);

getCharObjectCode: betaByteCode
  (# <<SLOT GetCharObjectCodeLib:attributes>>;
     selfType::getCharObjectCode;
     typename::(# do 'PUSH-obj_"char"'->value.puttext #);
     shortTypename::(# do 'obj-"char"'->value.puttext #);
     execute::(# <<SLOT GetCharObjectCodeExecute:dopart>> #)
  #);

getIntegerObjectCode: betaByteCode
  (# <<SLOT GetIntegerObjectCodeLib:attributes>>;
     selfType::getIntegerObjectCode;
     typename::(# do 'PUSH-obj_"integer"'->value.puttext #);
     shortTypename::(# do 'obj-"integer"'->value.puttext #);
     execute::(# <<SLOT GetIntegerObjectCodeExecute:dopart>> #)
  #);

getRealObjectCode: betaByteCode
  (# <<SLOT GetRealObjectCodeLib:attributes>>;
     selfType::getRealObjectCode;
     typename::(# do 'PUSH-obj_"real"'->value.puttext #);
     shortTypename::(# do 'obj-"real"'->value.puttext #);
     execute::(# <<SLOT GetRealObjectCodeExecute:dopart>> #)
  #);

getStringObjectCode: betaByteCode
  (# <<SLOT GetStringObjectCodeLib:attributes>>;
     selfType::getStringObjectCode;
     typename::(# do 'PUSH-obj_"string"'->value.puttext #);
     shortTypename::(# do 'obj-"string"'->value.puttext #);
     execute::(# <<SLOT GetStringObjectCodeExecute:dopart>> #)
  #);

getComponentObjectCode: betaByteCode
  (# <<SLOT GetComponentObjectCodeLib:attributes>>;
     selfType::getComponentObjectCode;
     typename::(# do 'PUSH-obj_"component"'->value.puttext #);
     shortTypename::(# do 'obj-"component"'->value.puttext #);
     execute::(# <<SLOT GetComponentObjectCodeExecute:dopart>> #)
  #);

getSemaphoreObjectCode: betaByteCode
  (# <<SLOT GetSemaphoreObjectCodeLib:attributes>>;
     selfType::getSemaphoreObjectCode;
     typename::(# do 'PUSH-obj_"semaphore"'->value.puttext #);
     shortTypename::(# do 'obj-"semaphore"'->value.puttext #);
     execute::(# <<SLOT GetSemaphoreObjectCodeExecute:dopart>> #)
  #);

getStaticTmpCode: betaByteCode
  (# <<SLOT GetStaticTmpCodeLib:attributes>>;
     selfType::< getStaticTmpCode;
     init::(# enter tmpLevel #);
     printCode::(# <<SLOT GetStaticTmpCodePrintCode:dopart>> #);
     tmpLevel: @integer
  #);

getObjectTmpCode: getStaticTmpCode
  (# <<SLOT GetObjectTmpCodeLib:attributes>>;
     selfType::getObjectTmpCode;
     typename::(# do 'PUSH-tmp_"object"'->value.puttext #);
     shortTypename::(# do 'tmp-"object"'->value.puttext #);
     execute::(# <<SLOT GetObjectTmpCodeExecute:dopart>> #)
  #);

getBooleanTmpCode: getStaticTmpCode
  (# <<SLOT GetBooleanTmpCodeLib:attributes>>;
     selfType::getBooleanTmpCode;
     typename::(# do 'PUSH-tmp_"boolean"'->value.puttext #);
     shortTypename::(# do 'tmp-"boolean"'->value.puttext #);
     execute::(# <<SLOT GetBooleanTmpCodeExecute:dopart>> #)
  #);

getCharTmpCode: getStaticTmpCode
  (# <<SLOT GetCharTmpCodeLib:attributes>>;
     selfType::getCharTmpCode;
     typename::(# do 'PUSH-tmp_"char"'->value.puttext #);
     shortTypename::(# do 'tmp-"char"'->value.puttext #);
     execute::(# <<SLOT GetCharTmpCodeExecute:dopart>> #)
  #);

getIntegerTmpCode: getStaticTmpCode
  (# <<SLOT GetIntegerTmpCodeLib:attributes>>;
     selfType::getIntegerTmpCode;
     typename::(# do 'PUSH-tmp_"integer"'->value.puttext #);
     shortTypename::(# do 'tmp-"integer"'->value.puttext #);
     execute::(# <<SLOT GetIntegerTmpCodeExecute:dopart>> #)
  #);

getRealTmpCode: getStaticTmpCode
  (# <<SLOT GetRealTmpCodeLib:attributes>>;
     selfType::getRealTmpCode;
     typename::(# do 'PUSH-tmp_"real"'->value.puttext #);
     shortTypename::(# do 'tmp-"real"'->value.puttext #);
     execute::(# <<SLOT GetRealTmpCodeExecute:dopart>> #)
  #);

getStringTmpCode: getStaticTmpCode
  (# <<SLOT GetStringTmpCodeLib:attributes>>;
     selfType::getStringTmpCode;
     typename::(# do 'PUSH-tmp_"string"'->value.puttext #);
     shortTypename::(# do 'tmp-"string"'->value.puttext #);
     execute::(# <<SLOT GetStringTmpCodeExecute:dopart>> #)
  #);

getComponentTmpCode: getStaticTmpCode
  (# <<SLOT GetComponentTmpCodeLib:attributes>>;
     selfType::getComponentTmpCode;
     typename::(# do 'PUSH-tmp_"component"'->value.puttext #);
     shortTypename::(# do 'tmp-"component"'->value.puttext #);
     execute::(# <<SLOT GetComponentTmpCodeExecute:dopart>> #)
  #);

getSemaphoreTmpCode: getStaticTmpCode
  (# <<SLOT GetSemaphoreTmpCodeLib:attributes>>;
     selfType::getSemaphoreTmpCode;
     typename::(# do 'PUSH-tmp_"semaphore"'->value.puttext #);
     shortTypename::(# do 'tmp-"semaphore"'->value.puttext #);
     execute::(# <<SLOT GetSemaphoreTmpCodeExecute:dopart>> #)
  #);

getIndexCode: accessCode
  (# <<SLOT GetIndexCodeLib:attributes>>;
     selfType::getIndexCode;
     typename::(# do 'PUSH-index'->value.puttext #);
     shortTypename::(# do 'inx'->value.puttext #);
     execute::
       (# fsSlice: ^forSubstanceSlice
       <<SLOT GetIndexCodeExecute:dopart>> 
       #)
  #);

checkNonePrefCode: betaByteCode
  (# <<SLOT checkNonePrefCodeLib:attributes>>;
     selfType::checkNonePrefCode;
     typename::(# do 'CHK_PTN_NONE'->value.puttext #);
     shortTypename::(# do 'none?'->value.puttext #);
     execute::(# <<SLOT CheckNonePrefCodeExecute:dopart>> #)
  #);

putCode: accessCode
  (* Byte code for putting state into a reachable entity *)
  (# <<SLOT PutCodeLib:attributes>>;
     selfType::< putCode;
     typename::< (# do 'POP-'->value.puttext; INNER #);
     shortTypename::< (# do 'p'->value.puttext; INNER #)
  #);

putBooleanCode: putCode
  (# <<SLOT PutBooleanCodeLib:attributes>>;
     selfType::putBooleanCode;
     typename::(# do 'boolean'->value.puttext #);
     shortTypename::(# do 'b'->value.puttext #);
     execute::(# <<SLOT PutBooleanCodeExecute:dopart>> #);
     boSlice: ^booleanObjectSlice
  #);

putCharCode: putCode
  (# <<SLOT PutCharCodeLib:attributes>>;
     selfType::putCharCode;
     typename::(# do 'char'->value.puttext #);
     shortTypename::(# do 'c'->value.puttext #);
     execute::(# <<SLOT PutCharCodeExecute:dopart>> #);
     coSlice: ^charObjectSlice
  #);

putIntegerCode: putCode
  (# <<SLOT PutIntegerCodeLib:attributes>>;
     selfType::putIntegerCode;
     typename::(# do 'integer'->value.puttext #);
     shortTypename::(# do 'i'->value.puttext #);
     execute::(# <<SLOT PutIntegerCodeExecute:dopart>> #);
     ioSlice: ^integerObjectSlice
  #);

putRealCode: putCode
  (# <<SLOT PutRealCodeLib:attributes>>;
     selfType::putRealCode;
     typename::(# do 'real'->value.puttext #);
     shortTypename::(# do 'r'->value.puttext #);
     execute::(# <<SLOT PutRealCodeExecute:dopart>> #);
     roSlice: ^realObjectSlice
  #);

putStringCode: putCode
  (# <<SLOT PutStringCodeLib:attributes>>;
     selfType::putStringCode;
     typename::(# do 'string'->value.puttext #);
     shortTypename::(# do 's'->value.puttext #);
     execute::(# <<SLOT PutStringCodeExecute:dopart>> #);
     soSlice: ^stringObjectSlice
  #);

checkObjectQualificationCode: accessCode
  (* A reference assignment to a variable object is just about to
   * happen, but it is not statically known that it is safe; check
   * that the object being assigned is actually qualified, and
   * invoke a run-time error if not; the object to assign is on 
   * the objref stack, and the qualification can be looked up 
   * by following 'where' *)
  (# <<SLOT CheckObjectQualificationCodeLib:attributes>>;
     selfType::checkObjectQualificationCode;
     init::(# enter exact #);
     typename::(# do 'CHK_QUA_OBJ'->value.puttext #);
     shortTypename::(# do 'chkqo'->value.puttext #);
     execute::
       (# l1pat_qua,l1pat_candidate: ^l1PatternEntity;
          listep: ^runtimeLookupIndirectStep;
          oSlice: ^compositeObjectSlice;
          l1oref: ^l1ObjectRefEntity;
          l1obj: ^l1ObjectEntity
       <<SLOT CheckObjectQualificationCodeExecute:dopart>>
       #);
     exact: @boolean
  #);

putObjectRefCode: putCode
  (# <<SLOT PutObjectRefCodeLib:attributes>>;
     selfType::putObjectRefCode;
     init::(# enter sptype[] #);
     typename::(# do 'objref'->value.puttext #);
     shortTypename::(# do 'or'->value.puttext #);
     print::(# <<SLOT PutObjectRefCodePrint:dopart>> #);
     printShort::(# <<SLOT PutObjectRefCodePrintShort:dopart>> #);
     printCode::(# <<SLOT PutObjectRefCodePrintCode:dopart>> #);
     execute::
       (# fail:
            (# 
            do ('Qualification error in reference assignment'
               ,thrd[],unwind##)->qualificationError
            #);
          listep: ^runtimeLookupIndirectStep;
          oSlice: ^compositeObjectSlice;
          l1obj: ^l1ObjectEntity;
          l1oref: ^l1ObjectRefEntity
       <<SLOT PutObjectRefCodeExecute:dopart>> 
       #);
     sptype: ^staticPatternType;        (* qualification of ref.attr *)
  #);

putKeepObjectRefCode: accessCode
  (# <<SLOT PutKeepObjectRefCodeLib:attributes>>;
     selfType::putKeepObjectRefCode;
     init::(# enter sptype[] #);
     typename::(# do 'PEEK-objref'->value.puttext #);
     shortTypename::(# do 'kor'->value.puttext #);
     print::(# <<SLOT PutKeepObjectRefCodePrint:dopart>> #);
     printShort::(# <<SLOT PutKeepObjectRefCodePrintShort:dopart>> #);
     printCode::(# <<SLOT PutKeepObjectRefCodePrintCode:dopart>> #);
     execute::
       (# listep: ^runtimeLookupIndirectStep;
          oSlice: ^compositeObjectSlice;
          l1obj: ^l1ObjectEntity;
          l1oref: ^l1ObjectRefEntity
       <<SLOT PutKeepObjectRefCodeExecute:dopart>> 
       #);
     sptype: ^staticPatternType;        (* qualification of ref.attr *)
  #);

putKeepTmpRefCode: accessCode
  (# <<SLOT PutKeepTmpRefCodeLib:attributes>>;
     selfType::putKeepTmpRefCode;
     init::(# enter (sptype[],tmpLevel) #);
     typename::(# do 'PEEK-tmpref'->value.puttext #);
     shortTypename::(# do 'kotr'->value.puttext #);
     print::(# <<SLOT PutKeepTmpRefCodePrint:dopart>> #);
     printShort::(# <<SLOT PutKeepTmpRefCodePrintShort:dopart>> #);
     printCode::(# <<SLOT PutKeepTmpRefCodePrintCode:dopart>> #);
     execute::
       (# listep: ^runtimeLookupIndirectStep;
          oSlice: ^compositeObjectSlice;
          l1obj: ^l1ObjectEntity;
          l1oref: ^l1ObjectRefEntity
       <<SLOT PutKeepTmpRefCodeExecute:dopart>> 
       #);
     sptype: ^staticPatternType;        (* qualification of ref.attr *)
     tmpLevel: @integer                 (* placement on tmp stack *)
  #);

checkPatternQualificationCode: accessCode
  (* An assignment to a variable pattern is just about to
   * happen, but it is not statically known that it is safe; check
   * that the pattern being assigned is actually qualified, and
   * invoke a run-time error if not; the pattern to assign 
   * is on the pattern stack, and the qualification can be looked 
   * up by following 'where' *)
  (# <<SLOT CheckPatternQualificationCodeLib:attributes>>;
     selfType::checkPatternQualificationCode;
     typename::(# do 'CHK_QUA_PTN'->value.puttext #);
     shortTypename::(# do 'chkqp'->value.puttext #);
     execute::
       (# l1pat_qua,l1pat_candidate: ^l1PatternEntity;
          listep: ^runtimeLookupIndirectStep;
          oSlice: ^compositeObjectSlice;
          l1pref: ^l1PatternRefEntity
       <<SLOT CheckPatternQualificationCodeExecute:dopart>>
       #)
  #);

putPatternCode: putCode
  (# <<SLOT PutPatternCodeLib:attributes>>;
     selfType::putPatternCode;
     init::(# enter sptype[] #);
     typename::(# do 'ptnref'->value.puttext #);
     shortTypename::(# do 'p'->value.puttext #);
     print::(# <<SLOT PutPatternCodePrint:dopart>> #);
     printShort::(# <<SLOT PutPatternCodePrintShort:dopart>> #);
     printCode::(# <<SLOT PutPatternCodePrintCode:dopart>> #);
     execute::
       (# listep: ^runtimeLookupIndirectStep;
          oSlice: ^compositeObjectSlice;
          l1pat: ^l1PatternEntity;
          l1pref: ^l1PatternRefEntity
       <<SLOT PutPatternCodeExecute:dopart>> 
       #);
     sptype: ^staticPatternType;        (* stat. known qualification *)
  #);

createObjectCode: betaByteCode
  (* Byte code for the creation of a new object, 
   * located in the 'objRefs' stack as an instance of the
   * pattern found at the top of the pattern value stack;
   * pops the pattern off the stack, too *)
  (# <<SLOT CreateObjectCodeLib:attributes>>;
     selfType::createObjectCode;
     typename::(# do 'NEW,_ptn->obj'->value.puttext #);
     shortTypename::(# do '&obj'->value.puttext #);
     execute::
       (# l1pat: ^l1PatternEntity
       <<SLOT CreateObjectCodeExecute:dopart>> 
       #)
  #);

createStaticObjectCode: betaByteCode
  (* Byte code for the creation of a new object described
   * by means of a static pattern type; pushes the new 
   * object on the 'objRefs' stack *)
  (# <<SLOT CreateStaticObjectCodeLib:attributes>>;
     selfType::createStaticObjectCode;
     init::(# enter sptype[] <<SLOT CreateStaticObjectCodeInit:dopart>> #);
     typename::(# do 'NEW,_static-ptn->obj'->value.puttext #);
     shortTypename::(# do '&sobj'->value.puttext #);
     printCode::(# <<SLOT CreateStaticObjectCodePrintCode:dopart>> #);
     printStaticPattern::(# <<SLOT CreateStaticObjectCodePrintSP:dopart>> #);
     execute::
       (# l1obj: ^l1ObjectEntity;
          l1pat: ^l1PatternEntity
       <<SLOT CreateStaticObjectCodeExecute:dopart>>
       #);
     sptype: ^staticPatternType;        (* static & actual pattern of object *)
     mark: @integer
  #);

discardCode: betaByteCode
  (* pop an entity off the stack determined by 'bck' *)
  (# <<SLOT DiscardCodeLib:attributes>>;
     selfType::discardCode;
     init::(# enter stran[] #);
     typename::(# <<SLOT DiscardCodeTypename:dopart>> #);
     shortTypename::(# do 'drop'->value.puttext #);
     execute::(# <<SLOT DiscardCodeExecute:dopart>> #);
     stran: ^staticTransient
  #);

createTmpCode: betaByteCode
  (* Byte code for the creation of a temporary object, 
   * located in the temp. stack as an instance of the
   * pattern found at the top of the pattern value stack;
   * pops the pattern off the stack, too *)
  (# <<SLOT CreateTmpCodeLib:attributes>>;
     selfType::createTmpCode;
     typename::(# do 'NEW,_ptn->tmp'->value.puttext #);
     init::(# enter tmpLevel #);
     shortTypename::(# do '&tmp'->value.puttext #);
     print::(# <<SLOT CreateTmpCodePrint:dopart>> #);
     printCode::(# <<SLOT CreateTmpCodePrintCode:dopart>> #);
     execute::
       (# l1pat: ^l1PatternEntity
       <<SLOT CreateTmpCodeExecute:dopart>> 
       #);
     tmpLevel: @integer                 (* placement on tmp stack *)
  #);

createStaticTmpCode: betaByteCode
  (* Byte code for the creation of a temporary object, 
   * located in the temp. stack as an instance of the
   * pattern described by 'sptype' *)
  (# <<SLOT CreateStaticTmpCodeLib:attributes>>;
     selfType::createStaticTmpCode;
     typename::(# do 'NEW,_static-ptn->tmp'->value.puttext #);
     init::
       (# enter (tmpLevel,sptype[]) <<SLOT CreateStaticTmpCodeInit:dopart>> #);
     shortTypename::(# do '&tmp'->value.puttext #);
     print::(# <<SLOT CreateStaticTmpCodePrint:dopart>> #);
     printCode::(# <<SLOT CreateStaticTmpCodePrintCode:dopart>> #);
     printStaticPattern::(# <<SLOT CreateStaticTmpCodePrintSP:dopart>> #);
     execute::
       (# l1pat: ^l1PatternEntity
       <<SLOT CreateStaticTmpCodeExecute:dopart>> 
       #);
     tmpLevel: @integer;                (* placement on tmp stack *)
     mark: @integer;
     sptype: ^staticPatternType
  #);

getTmpCode: getCode
  (* Byte code for the retrieval of an existing object
   * to the temporary stack *)
  (# <<SLOT GetTmpCodeLib:attributes>>;
     selfType::getTmpCode;
     init::(# enter (sptype[],tmpLevel) #);
     typename::(# do 'tmpobj'->value.puttext #);
     shortTypename::(# do 'ot'->value.puttext #);
     print::(# <<SLOT GetTmpCodePrint:dopart>> #);
     printShort::(# <<SLOT GetTmpCodePrintShort:dopart>> #);
     printCode::(# <<SLOT GetTmpCodePrintCode:dopart>> #);
     execute::
       (# l1obj: ^l1ObjectEntity; oSlice: ^objectSlice
       <<SLOT GetTmpCodeExecute:dopart>> 
       #);
     sptype: ^staticPatternType;        (* static type of object *)
     tmpLevel: @integer                 (* placement on tmp stack *)
  #);

getTmpRefCode: getCode
  (# <<SLOT GetTmpRefCodeLib:attributes>>;
     selfType::getTmpRefCode;
     init::(# enter (sptype[],tmpLevel) #);
     typename::(# do 'tmpobjref'->value.puttext #);
     shortTypename::(# do 'ort'->value.puttext #);
     print::(# <<SLOT GetTmpRefCodePrint:dopart>> #);
     printShort::(# <<SLOT GetTmpRefCodePrintShort:dopart>> #);
     printCode::(# <<SLOT GetTmpRefCodePrintCode:dopart>> #);
     execute::
       (# l1obj: ^l1ObjectEntity
       <<SLOT GetTmpRefCodeExecute:dopart>>
       #);
     sptype: ^staticPatternType;        (* static qual. of object *)
     tmpLevel: @integer                 (* placement on tmp stack *)
  #);

stdioOutCode: betaByteCode
  (# <<SLOT StdioOutCodeLib:attributes>>;
     selfType::stdioOutCode;
     typename::(# do 'stdio/out'->value.puttext #);
     shortTypename::(# do 'i/O'->value.puttext #);
     execute::(# <<SLOT StdioOutCodeExecute:dopart>> #)
  #);

stdioInCode: betaByteCode
  (# <<SLOT StdioInCodeLib:attributes>>;
     selfType::stdioInCode;
     typename::(# do 'stdio/in'->value.puttext #);
     shortTypename::(# do 'I/o'->value.puttext #);
     execute::(# <<SLOT StdioInCodeExecute:dopart>> #)
  #);

coerceObjectPatternCode: betaByteCode
  (* Obtain the pattern of the object at the top of the 'objRefs' 
   * stack, pop that object, and push the pattern *)
  (# <<SLOT CoerceObjectPatternCodeLib:attributes>>;
     selfType::coerceObjectPatternCode;
     typename::(# do 'POP-obj,_O-->P,_PUSH-ptn'->value.puttext #);
     shortTypename::(# do 'O->P'->value.puttext #);
     execute::
       (# l1obj: ^l1ObjectEntity
       <<SLOT CoerceObjectPatternCodeExecute:dopart>>
       #)
  #);

moveObjectTmpCode: betaByteCode
  (* pop an object from 'objRefs' and put it on 'tmpObjs' *)
  (# <<SLOT MoveObjectTmpCodeLib:attributes>>;
     selfType::moveObjectTmpCode;
     init::(# enter tmpLevel #);
     typename::(# do 'POP-obj,_PUSH-tmp'->value.puttext #);
     shortTypename::(# do 'O->tmp'->value.puttext #);
     print::(# <<SLOT MoveObjectTmpCodePrint:dopart>> #);
     printCode::(# <<SLOT MoveObjectTmpCodePrintCode:dopart>> #);
     execute::(# <<SLOT MoveObjectTmpCodeExecute:dopart>> #);
     tmpLevel: @integer                 (* placement on tmp stack *)
  #);

coerceCharIntegerCode: betaByteCode
  (# <<SLOT CoerceCharIntegerCodeLib:attributes>>;
     selfType::coerceCharIntegerCode;
     typename::(# do 'POP-char,_C-->I,_PUSH-integer'->value.puttext #);
     shortTypename::(# do 'C->I'->value.puttext #);
     execute::(# <<SLOT CoerceCharIntegerCodeExecute:dopart>> #)
  #);

coerceCharRealCode: betaByteCode
  (# <<SLOT CoerceCharRealCodeLib:attributes>>;
     selfType::coerceCharRealCode;
     typename::(# do 'POP-char,_C-->R,_PUSH-real'->value.puttext #);
     shortTypename::(# do 'C->R'->value.puttext #);
     execute::(# i: @integer <<SLOT CoerceCharRealCodeExecute:dopart>> #)
  #);

coerceCharStringCode: betaByteCode
  (# <<SLOT CoerceCharStringCodeLib:attributes>>;
     selfType::coerceCharStringCode;
     typename::(# do 'POP-char,_C-->S,_PUSH-string'->value.puttext #);
     shortTypename::(# do 'C->S'->value.puttext #);
     execute::(# t: ^text <<SLOT CoerceCharStringCodeExecute:dopart>> #)
  #);

coerceIntegerCharCode: betaByteCode
  (# <<SLOT CoerceIntegerCharCodeLib:attributes>>;
     selfType::coerceIntegerCharCode;
     typename::(# do 'POP-integer,_I-->C,_PUSH-char'->value.puttext #);
     shortTypename::(# do 'I->C'->value.puttext #);
     execute::(# <<SLOT CoerceIntegerCharCodeExecute:dopart>> #)
  #);

coerceIntegerRealCode: betaByteCode
  (# <<SLOT CoerceIntegerRealCodeLib:attributes>>;
     selfType::coerceIntegerRealCode;
     typename::(# do 'POP-integer,_I-->R,_PUSH-real'->value.puttext #);
     shortTypename::(# do 'I->R'->value.puttext #);
     execute::(# <<SLOT CoerceIntegerRealCodeExecute:dopart>> #)
  #);

coerceRealIntegerCode: betaByteCode
  (# <<SLOT CoerceRealIntegerCodeLib:attributes>>;
     selfType::coerceRealIntegerCode;
     typename::(# do 'POP-real,_R-->I,_PUSH-integer'->value.puttext #);
     shortTypename::(# do 'R->I'->value.puttext #);
     execute::(# <<SLOT CoerceRealIntegerCodeExecute:dopart>> #)
  #);

coerceString1CharCode: betaByteCode
  (# <<SLOT CoerceString1CharCodeLib:attributes>>;
     selfType::coerceString1CharCode;
     typename::(# do 'POP-string1,_S1-->C,_PUSH-char'->value.puttext #);
     shortTypename::(# do 'S1->C'->value.puttext #);
     execute::(# <<SLOT CoerceString1CharCodeExecute:dopart>> #)
  #);

coerceString1IntegerCode: betaByteCode
  (# <<SLOT CoerceString1IntegerCodeLib:attributes>>;
     selfType::coerceString1IntegerCode;
     typename::(# do 'POP-string1,_S1-->I,_PUSH-integer'->value.puttext #);
     shortTypename::(# do 'S1->I'->value.puttext #);
     execute::(# <<SLOT CoerceString1IntegerCodeExecute:dopart>> #)
  #);

coerceString1RealCode: betaByteCode
  (# <<SLOT CoerceString1RealCodeLib:attributes>>;
     selfType::coerceString1RealCode;
     typename::(# do 'POP-string1,_S1-->R,_PUSH-real'->value.puttext #);
     shortTypename::(# do 'S1->R'->value.puttext #);
     execute::(# <<SLOT CoerceString1RealCodeExecute:dopart>> #)
  #);

mergePatternCode: betaByteCode
  (# <<SLOT MergePatternCodeLib:attributes>>;
     selfType::mergePatternCode;
     typename::(# do 'MERGE-ptn'->value.puttext #);
     shortTypename::(# do 'P&Q'->value.puttext #);
     execute::
       (# l1pat2,l1pat1: ^l1PatternEntity
       <<SLOT MergePatternCodeExecute:dopart>> 
       #)
  #);

swapMergePatternCode: betaByteCode
  (# <<SLOT SwapMergePatternCodeLib:attributes>>;
     selfType::swapMergePatternCode;
     typename::(# do 'SWAPMERGE-ptn'->value.puttext #);
     shortTypename::(# do 'Q&P'->value.puttext #);
     execute::
       (# l1pat2,l1pat1: ^l1PatternEntity
       <<SLOT SwapMergePatternCodeExecute:dopart>> 
       #)
  #);

addMainpartCode: betaByteCode
  (# <<SLOT AddMainpartCodeLib:attributes>>;
     selfType::addMainpartCode;
     init::(# enter (originPath[],l2mpar[]) #);
     typename::(# do 'ADD-mainpart'->value.puttext #);
     shortTypename::(# do '+(##)'->value.puttext #);
     print::(# <<SLOT AddMainPartCodePrint:dopart>> #);
     printCode::(# <<SLOT AddMainPartCodePrintCode:dopart>> #);
     execute::
       (# l1pat: ^l1PatternEntity;
          originContext: ^substanceSlice
       <<SLOT AddMainpartCodeExecute:dopart>> 
       #);
     l2mpar: ^l2MainPart;
     originPath: ^runtimePath
  #);

ensureComponentCode: betaByteCode
  (* Check out the pattern at the top of 'patterns' 
   * and add a component slice if none is present;
   * perhaps a hack which is to be removed .. *)
  (# <<SLOT EnsureComponentCodeLib:attributes>>;
     selfType::ensureComponentCode;
     typename::(# do 'ENSURE-component'->value.puttext #);
     shortTypename::(# do '<=|'->value.puttext #);
     print::(# <<SLOT EnsureComponentCodePrint:dopart>> #);
     printCode::(# <<SLOT EnsureComponentCodePrintCode:dopart>> #);
     execute::(# <<SLOT EnsureComponentCodeExecute:dopart>> #)
  #);

specializeObjectCode: accessCode
  (# <<SLOT SpecializeObjectCodeLib:attributes>>;
     selfType::specializeObjectCode;
     init::(# enter sptype[] #);
     typename::(# do 'POP-ptn,_SPECIALIZE-obj'->value.puttext #);
     shortTypename::(# do 'dyn.obj.spec.'->value.puttext #);
     execute::
       (# oSlice: ^objectSlice;
          l1obj: ^l1ObjectEntity;
          new_pat: ^l1PatternEntity;
          new_obj: ^l1ObjectEntity
       <<SLOT SpecializeObjectCodeExecute:dopart>> 
       #);
     sptype: ^staticPatternType
  #);

(* ---------- Expression Evaluation: relational operators ---------- *)

booleanByteCodeKind:   (# exit 3121 #);
charByteCodeKind:      (# exit 3122 #);
integerByteCodeKind:   (# exit 3123 #);
realByteCodeKind:      (# exit 3124 #);
stringByteCodeKind:    (# exit 3125 #);
string1ByteCodeKind:   (# exit 3126 #); (* literal string of length 1 *)
orefByteCodeKind:      (# exit 3127 #);
ptnByteCodeKind:       (# exit 3128 #);
noneByteCodeKind:      (# exit 3129 #);

byteCodeKindName: textValue
  (# bck: @integer;
  enter bck
  <<SLOT ByteCodeKindName:dopart>>
  #);

byteCodeKindShortName: textValue
  (# bck: @integer;
  enter bck
  <<SLOT ByteCodeKindShortName:dopart>>
  #);

relopCode: betaByteCode
  (# <<SLOT RelopCodeLib:attributes>>;
     selfType::< relopCode;
     init::< (# enter stran[] do INNER #);
     typename::< (# do 'RELOP(_'->value.puttext; INNER; '_)'->value.puttext #);
     shortTypename::< (# do 'OP'->value.puttext; INNER #);
     print::(# <<SLOT RelopCodePrint:dopart>> #);
     printShort::(# <<SLOT RelopCodePrintShort:dopart>> #);
     printCode::(# <<SLOT RelopCodePrintCode:dopart>> #);
     execute::(# <<SLOT RelopCodeExecute:dopart>> #);
     stran: ^staticTransient;
     impl:
       (# thrd: ^thread;
          unwind: ##stackUnwinder;
          dContext: ^substanceSlice
       enter (thrd[],unwind##,dContext[])
       do INNER
       #);
     executor: ##impl
  #);

relopEqExpCode: relopCode
  (# <<SLOT RelopEqExpCodeLib:attributes>>;
     selfType::relopEqExpCode;
     init::(# <<SLOT RelopEqExpCodeInit:dopart>> #);
     typename::(# do '='->value.puttext #);
     shortTypename::(# do '='->value.puttext #)
  #);

relopLtExpCode: relopCode
  (# <<SLOT RelopLtExpCodeLib:attributes>>;
     selfType::relopLtExpCode;
     init::(# <<SLOT RelopLtExpCodeInit:dopart>> #);
     typename::(# do '<'->value.puttext #);
     shortTypename::(# do '<'->value.puttext #)
  #);

relopLeExpCode: relopCode
  (# <<SLOT RelopLeExpCodeLib:attributes>>;
     selfType::relopLeExpCode;
     init::(# <<SLOT RelopLeExpCodeInit:dopart>> #);
     typename::(# do '<='->value.puttext #);
     shortTypename::(# do '<='->value.puttext #)
  #);

relopGtExpCode: relopCode
  (# <<SLOT RelopGtExpCodeLib:attributes>>;
     selfType::relopGtExpCode;
     init::(# <<SLOT RelopGtExpCodeInit:dopart>> #);
     typename::(# do '>'->value.puttext #);
     shortTypename::(# do '>'->value.puttext #)
  #);

relopGeExpCode: relopCode
  (# <<SLOT RelopGeExpCodeLib:attributes>>;
     selfType::relopGeExpCode;
     init::(# <<SLOT RelopGeExpCodeInit:dopart>> #);
     typename::(# do '>='->value.puttext #);
     shortTypename::(# do '>='->value.puttext #)
  #);

relopNeExpCode: relopCode
  (# <<SLOT RelopNeExpCodeLib:attributes>>;
     selfType::relopNeExpCode;
     init::(# <<SLOT RelopNeExpCodeInit:dopart>> #);
     typename::(# do '<>'->value.puttext #);
     shortTypename::(# do '<>'->value.puttext #)
  #);

(* ---------- Expression Evaluation: addition operators ---------- *)

addopCode: betaByteCode
  (# <<SLOT AddopCodeLib:attributes>>;
     selfType::< addopCode;
     init::(# enter stran[] #);
     typename::< (# do 'ADDOP(_'->value.puttext; INNER; '_)'->value.puttext #);
     shortTypename::< (# do 'OP'->value.puttext; INNER #);
     print::(# <<SLOT AddopCodePrint:dopart>> #);
     printShort::(# <<SLOT AddopCodePrintShort:dopart>> #);
     printCode::(# <<SLOT AddopCodePrintCode:dopart>> #);
     stran: ^staticTransient
  #);

addopPlusExpCode: addopCode
  (# <<SLOT AddopPlusExpCodeLib:attributes>>;
     selfType::addopPlusExpCode;
     typename::(# do '+'->value.puttext #);
     shortTypename::(# do '+'->value.puttext #);
     execute::(# <<SLOT AddopPlusExpCodeExecute:dopart>> #)
  #);

addopMinusExpCode: addopCode
  (# <<SLOT AddopMinusExpCodeLib:attributes>>;
     selfType::addopMinusExpCode;
     typename::(# do '-'->value.puttext #);
     shortTypename::(# do '-'->value.puttext #);
     execute::(# <<SLOT AddopMinusExpCodeExecute:dopart>> #)
  #);

addopOrExpCode: addopCode
  (# <<SLOT AddopOrExpCodeLib:attributes>>;
     selfType::addopOrExpCode;
     typename::(# do 'or'->value.puttext #);
     shortTypename::(# do 'or'->value.puttext #);
     execute::(# <<SLOT AddopOrExpCodeExecute:dopart>> #)
  #);

addopXorExpCode: addopCode
  (# <<SLOT AddopXorExpCodeLib:attributes>>;
     selfType::addopXorExpCode;
     typename::(# do 'xor'->value.puttext #);
     shortTypename::(# do 'xor'->value.puttext #);
     execute::(# <<SLOT AddopXorExpCodeExecute:dopart>> #)
  #);

(* ---------- Expression Evaluation: multiplication operators ---------- *)

mulopCode: betaByteCode
  (# <<SLOT MulopCodeLib:attributes>>;
     selfType::< mulopCode;
     init::(# enter stran[] #);
     typename::< (# do 'MULOP(_'->value.puttext; INNER; '_)'->value.puttext #);
     shortTypename::< (# do 'OP'->value.puttext; INNER #);
     print::(# <<SLOT MulopCodePrint:dopart>> #);
     printShort::(# <<SLOT MulopCodePrintShort:dopart>> #);
     printCode::(# <<SLOT MulopCodePrintCode:dopart>> #);
     stran: ^staticTransient
  #);

mulopTimesExpCode: mulopCode
  (# <<SLOT MulopTimesExpCodeLib:attributes>>;
     selfType::mulopTimesExpCode;
     typename::(# do '*'->value.puttext #);
     shortTypename::(# do '*'->value.puttext #);
     execute::(# <<SLOT MulopTimesExpCodeExecute:dopart>> #)
  #);

mulopRealDivExpCode: mulopCode
  (# <<SLOT MulopRealDivExpCodeLib:attributes>>;
     selfType::mulopRealDivExpCode;
     typename::(# do '/'->value.puttext #);
     shortTypename::(# do '/'->value.puttext #);
     execute::
       (# op1,op2: @real
       <<SLOT MulopRealDivExpCodeExecute:dopart>> 
       #)
  #);

mulopIntDivExpCode: mulopCode
  (# <<SLOT MulopIntDivExpCodeLib:attributes>>;
     selfType::mulopIntDivExpCode;
     typename::(# do 'div'->value.puttext #);
     shortTypename::(# do 'div'->value.puttext #);
     execute::
       (# op1,op2: @integer
       <<SLOT MulopIntDivExpCodeExecute:dopart>> 
       #)
  #);

mulopModExpCode: mulopCode
  (# <<SLOT MulopModExpCodeLib:attributes>>;
     selfType::mulopModExpCode;
     typename::(# do 'mod'->value.puttext #);
     shortTypename::(# do 'mod'->value.puttext #);
     execute::
       (# op1,op2: @integer
       <<SLOT MulopModExpCodeExecute:dopart>> 
       #)
  #);

mulopAndExpCode: mulopCode
  (# <<SLOT MulopAndExpCodeLib:attributes>>;
     selfType::mulopAndExpCode;
     typename::(# do 'and'->value.puttext #);
     shortTypename::(# do 'and'->value.puttext #);
     execute::(# <<SLOT MulopAndExpCodeExecute:dopart>> #)
  #);

(* ---------- Expression Evaluation: unary operators ---------- *)

negateBooleanCode: betaByteCode
  (* Byte code for the negation of the top level element 
   * of the boolean stack of the beta virtual machine *)
  (# <<SLOT NegateBooleanCodeLib:attributes>>;
     selfType::negateBooleanCode;
     typename::(# do 'NOT'->value.puttext #);
     shortTypename::(# do '~'->value.puttext #);
     execute::(# <<SLOT NegateBooleanCodeExecute:dopart>> #)
  #);

negateIntegerCode: betaByteCode
  (* Byte code for the negation of the top level element 
   * of the integer stack of the beta virtual machine *)
  (# <<SLOT NegateIntegerCodeLib:attributes>>;
     selfType::negateIntegerCode;
     typename::(# do 'NEG(integer)'->value.puttext #);
     shortTypename::(# do '-'->value.puttext #);
     execute::(# <<SLOT NegateIntegerCodeExecute:dopart>> #)
  #);

negateRealCode: betaByteCode
  (* Byte code for the negation of the top level element 
   * of the real stack of the beta virtual machine *)
  (# <<SLOT NegateRealCodeLib:attributes>>;
     selfType::negateRealCode;
     typename::(# do 'NEG(real)'->value.puttext #);
     shortTypename::(# do '-.'->value.puttext #);
     execute::(# <<SLOT NegateRealCodeExecute:dopart>> #)
  #);

(* ---------- Control Structures ---------- *)

simpleIfCode: betaByteCode
  (# <<SLOT SimpleIfCodeLib:attributes>>;
     selfType::simpleIfCode;
     init::(# enter l2sif[] #);
     typename::(# do 'simpleIf'->value.puttext #);
     shortTypename::(# do 'if'->value.puttext #);
     print::(# <<SLOT SimpleIfCodePrint:dopart>> #);
     printShort::(# <<SLOT SimpleIfCodePrintShort:dopart>> #);
     printCode::(# <<SLOT SimpleIfCodePrintCode:dopart>> #);
     execute::(# <<SLOT SimpleIfCodeExecute:dopart>> #);
     l2sif: ^l2SimpleIfImp
  #);

locatedSimpleIfCode: betaByteCode
  (# <<SLOT LocatedSimpleIfCodeLib:attributes>>;
     selfType::locatedSimpleIfCode;
     init::
       (# enter (l2sif[],where[],thenProgram[],elseProgram[],entering)
       do thenBody.init; elseBody.init
       #);
     typename::(# do 'locatedSimpleIf'->value.puttext #);
     shortTypename::(# do 'lif'->value.puttext #);
     print::(# <<SLOT LocatedSimpleIfCodePrint:dopart>> #);
     printShort::(# <<SLOT LocatedSimpleIfCodePrintShort:dopart>> #);
     printCode::(# <<SLOT LocatedSimpleIfCodePrintCode:dopart>> #);
     execute::
       (# fail: (# <<SLOT LocatedSimpleIfCodeFail:dopart>> #);
          targetContext: ^substanceSlice
       <<SLOT LocatedSimpleIfCodeExecute:dopart>> 
       #);
     l2sif: ^l2SimpleIfImp;
     thenProgram,elseProgram: ^betaByteCodeList;
     thenBody,elseBody: @list(# element::l2Imp #);
     entering: @boolean; (* true if created by enterCplr, false - exitCplr *)
     where: ^runtimePath
  #);

generalIfCode: betaByteCode
  (# <<SLOT GeneralIfCodeLib:attributes>>;
     selfType::generalIfCode;
     init::(# enter (l2gif[],stran[]) #);
     typename::(# do 'generalIf'->value.puttext #);
     shortTypename::(# do 'g_if'->value.puttext #);
     print::(# <<SLOT GeneralIfCodePrint:dopart>> #);
     printShort::(# <<SLOT GeneralIfCodePrintShort:dopart>> #);
     printCode::(# <<SLOT GeneralIfCodePrintCode:dopart>> #);
     execute::(# <<SLOT GeneralIfCodeExecute:dopart>> #);
     l2gif: ^l2GeneralIfImp;
     stran: ^staticTransient
  #);

whileCode: betaByteCode
  (# <<SLOT WhileCodeLib:attributes>>;
     selfType::whileCode;
     init::(# enter l2wimp[] #);
     typename::(# do 'while'->value.puttext #);
     shortTypename::(# do 'while'->value.puttext #);
     print::(# <<SLOT WhileCodePrint:dopart>> #);
     printShort::(# <<SLOT WhileCodePrintShort:dopart>> #);
     printCode::(# <<SLOT WhileCodePrintCode:dopart>> #);
     execute::(# <<SLOT WhileCodeExecute:dopart>> #);
     l2wimp: ^l2WhileImp
  #);

simpleForCode: betaByteCode
  (# <<SLOT SimpleForCodeLib:attributes>>;
     selfType::simpleForCode;
     init::(# enter l2sfimp[] #);
     typename::(# do 'simpleFor'->value.puttext #);
     shortTypename::(# do 'sfor'->value.puttext #);
     print::(# <<SLOT SimpleForCodePrint:dopart>> #);
     printShort::(# <<SLOT SimpleForCodePrintShort:dopart>> #);
     printCode::(# <<SLOT SimpleForCodePrintCode:dopart>> #);
     execute::(# count: @integer <<SLOT SimpleForCodeExecute:dopart>> #);
     l2sfimp: ^l2SimpleForImp
  #);

namedForCode: betaByteCode
  (# <<SLOT NamedForCodeLib:attributes>>;
     selfType::namedForCode;
     init::(# enter l2nfimp[] #);
     typename::(# do 'namedFor'->value.puttext #);
     shortTypename::(# do 'nfor'->value.puttext #);
     print::(# <<SLOT NamedForCodePrint:dopart>> #);
     printShort::(# <<SLOT NamedForCodePrintShort:dopart>> #);
     printCode::(# <<SLOT NamedForCodePrintCode:dopart>> #);
     execute::
       (# fsSlice: ^forSubstanceSlice;
          count: @integer
       <<SLOT NamedForCodeExecute:dopart>> 
       #);
     l2nfimp: ^l2NamedForImp
  #);

whenCode: betaByteCode
  (# <<SLOT WhenCodeLib:attributes>>;
     selfType::whenCode;
     init::(# enter l2wimp[] #);
     typename::(# do 'when'->value.puttext #);
     shortTypename::(# do 'when'->value.puttext #);
     print::(# <<SLOT WhenCodePrint:dopart>> #);
     printShort::(# <<SLOT WhenCodePrintShort:dopart>> #);
     printCode::(# <<SLOT WhenCodePrintCode:dopart>> #);
     execute::(# <<SLOT WhenCodeExecute:dopart>> #);
     l2wimp: ^l2WhenImp
  #);

(* ---------- Entitites in Repetitions ---------- *)

indexedAccessCode: betaByteCode
  (* Byte codes for getting or putting the state 
   * of an entity reachable at the position computed 
   * by evaluating 'l2eval' in a repetition which is
   * itself located at the end of the 'where' path *)
  (# <<SLOT IndexedAccessCodeLib:attributes>>;
     selfType::< indexedAccessCode;
     init::< (# enter (where[],l2eval[],evalWhere[]) do INNER #);
     print::< (# <<SLOT IndexedAccessCodePrint:dopart>> #);
     printShort::< (# <<SLOT IndexedAccessCodePrintShort:dopart>> #);
     printCode::< (# <<SLOT IndexedAccessCodePrintCode:dopart>> #);
     execute::< 
       (# targetContext: ^substanceSlice;
          evalContext: ^substanceSlice;
          lstep: ^runtimeLookupStep;
          listep: ^runtimeLookupIndirectStep;
          attr: ^l1MapElement;
          targetRep: ^l1RepetitionEntity;
          targetInx: @integer
       <<SLOT IndexedAccessCodeExecute:dopart>>
       #);
     where: ^runtimePath;
     l2eval: ^l2Evaluation;
     evalWhere: ^runtimePath
  #);

indexedGetCode: indexedAccessCode
  (# <<SLOT IndexedGetCodeLib:attributes>>;
     selfType::< indexedGetCode;
     typename::< (# do 'PUSH-inx-'->value.puttext; INNER #);
     shortTypename::< (# do 'gi'->value.puttext; INNER #)
  #);

indexedGetTmpCode: indexedGetCode
  (# <<SLOT IndexedGetTmpCodeLib:attributes>>;
     selfType::indexedGetTmpCode;
     init::(# enter (sptype[],tmpLevel) #);
     typename::(# do 'tmpobj'->value.puttext #);
     shortTypename::(# do 'ot'->value.puttext #);
     print::(# <<SLOT IndexedGetTmpCodePrint:dopart>> #);
     printShort::(# <<SLOT IndexedGetTmpCodePrintShort:dopart>> #);
     printCode::(# <<SLOT IndexedGetTmpCodePrintCode:dopart>> #);
     execute::(# <<SLOT IndexedGetTmpCodeExecute:dopart>> #);
     sptype: ^staticPatternType;        (* static type of object *)
     tmpLevel: @integer                 (* placement on tmp stack *)
  #);

indexedGetTmpRefCode: indexedGetCode
  (# <<SLOT IndexedGetTmpRefCodeLib:attributes>>;
     selfType::indexedGetTmpRefCode;
     init::(# enter (sptype[],tmpLevel) #);
     typename::(# do 'tmpobjref'->value.puttext #);
     shortTypename::(# do 'ort'->value.puttext #);
     print::(# <<SLOT IndexedGetTmpRefCodePrint:dopart>> #);
     printShort::(# <<SLOT IndexedGetTmpRefCodePrintShort:dopart>> #);
     printCode::(# <<SLOT IndexedGetTmpRefCodePrintCode:dopart>> #);
     execute::
       (# l1oref: ^l1ObjectRefEntity
       <<SLOT IndexedGetTmpRefCodeExecute:dopart>> 
       #);
     sptype: ^staticPatternType;        (* static qual. of object *)
     tmpLevel: @integer                 (* placement on tmp stack *)
  #);

indexedGetObjectCode: indexedGetCode
  (# <<SLOT IndexedGetObjectCodeLib:attributes>>;
     selfType::indexedGetObjectCode;
     init::(# enter sptype[] #);
     typename::(# do 'obj'->value.puttext #);
     shortTypename::(# do 'o'->value.puttext #);
     print::(# <<SLOT IndexedGetObjectCodePrint:dopart>> #);
     printShort::(# <<SLOT IndexedGetObjectCodePrintShort:dopart>> #);
     printCode::(# <<SLOT IndexedGetObjectCodePrintCode:dopart>> #);
     execute::(# <<SLOT IndexedGetObjectCodeExecute:dopart>> #);
     sptype: ^staticPatternType         (* static type of object *)
  #);

indexedGetObjectRefCode: indexedGetCode
  (# <<SLOT IndexedGetObjectRefCodeLib:attributes>>;
     selfType::indexedGetObjectRefCode;
     init::(# enter sptype[] #);
     typename::(# do 'objref'->value.puttext #);
     shortTypename::(# do 'or'->value.puttext #);
     print::(# <<SLOT IndexedGetObjectRefCodePrint:dopart>> #);
     printShort::(# <<SLOT IndexedGetObjectRefCodePrintShort:dopart>> #);
     printCode::(# <<SLOT IndexedGetObjectRefCodePrintCode:dopart>> #);
     execute::
       (# l1oref: ^l1ObjectRefEntity
       <<SLOT IndexedGetObjectRefCodeExecute:dopart>> 
       #);
     sptype: ^staticPatternType         (* static qual. of object *)
  #);

indexedGetQualificationCode: indexedGetCode
  (# <<SLOT IndexedGetQualificationCodeLib:attributes>>;
     selfType::indexedGetQualificationCode;
     init::(# enter sptype[] #);
     typename::(# do 'qual'->value.puttext #);
     shortTypename::(# do 'orq'->value.puttext #);
     print::(# <<SLOT IndexedGetQualificationCodePrint:dopart>> #);
     printShort::(# <<SLOT IndexedGetQualificationCodePrintShort:dopart>> #);
     printCode::(# <<SLOT IndexedGetQualificationCodePrintCode:dopart>> #);
     execute::(# <<SLOT IndexedGetQualificationCodeExecute:dopart>> #);
     sptype: ^staticPatternType         (* statically known qual. of object *)
  #);

indexedGetPatternCode: indexedGetCode
  (# <<SLOT IndexedGetPatternCodeLib:attributes>>;
     selfType::indexedGetPatternCode;
     init::(# enter sptype[] #);
     typename::(# do 'ptn'->value.puttext #);
     shortTypename::(# do 'p'->value.puttext #);
     print::(# <<SLOT IndexedGetPatternCodePrint:dopart>> #);
     printShort::(# <<SLOT IndexedGetPatternCodePrintShort:dopart>> #);
     printCode::(# <<SLOT IndexedGetPatternCodePrintCode:dopart>> #);
     execute::(# <<SLOT IndexedGetPatternCodeExecute:dopart>> #);
     sptype: ^staticPatternType         (* statically known value *)
  #);

indexedGetPatternRefCode: indexedGetCode
  (# <<SLOT IndexedGetPatternRefCodeLib:attributes>>;
     selfType::indexedGetPatternRefCode;
     init::(# enter sptype[] #);
     typename::(# do 'ptnref'->value.puttext #);
     shortTypename::(# do 'pr'->value.puttext #);
     print::(# <<SLOT IndexedGetPatternRefCodePrint:dopart>> #);
     printShort::(# <<SLOT IndexedGetPatternRefCodePrintShort:dopart>> #);
     printCode::(# <<SLOT IndexedGetPatternRefCodePrintCode:dopart>> #);
     execute::
       (# l1pref: ^l1PatternRefEntity
       <<SLOT IndexedGetPatternRefCodeExecute:dopart>> 
       #);
     sptype: ^staticPatternType         (* statically known qual. *)
  #);

indexedPutCode: indexedAccessCode
  (# <<SLOT IndexedPutCodeLib:attributes>>;
     selfType::< indexedPutCode;
     typename::< (# do 'POP-inx-'->value.puttext; INNER #);
     shortTypename::< (# do 'pi'->value.puttext; INNER #)
  #);

checkIndexedObjectQualificationCode: indexedAccessCode
  (* A reference assignment to a variable object is just about to
   * happen, but it is not statically known that it is safe; check
   * that the object being assigned is actually qualified, and
   * invoke a run-time error if not; the object to assign is on 
   * the objref stack, and the qualification can be looked up 
   * by following 'where' *)
  (# <<SLOT CheckIndexedObjectQualificationCodeLib:attributes>>;
     selfType::checkIndexedObjectQualificationCode;
     init::(# enter exact #);
     typename::(# do 'CHK_QUA_OBJ-inx'->value.puttext #);
     shortTypename::(# do 'chkqoi'->value.puttext #);
     execute::
       (# l1pat_qua,l1pat_candidate: ^l1PatternEntity;
          listep: ^runtimeLookupIndirectStep;
          oSlice: ^compositeObjectSlice;
          l1oref: ^l1ObjectRefEntity;
          l1obj: ^l1ObjectEntity
       <<SLOT CheckIndexedObjectQualificationCodeExecute:dopart>>
       #);
     exact: @boolean
  #);

indexedPutObjectRefCode: indexedPutCode
  (# <<SLOT IndexedPutObjectRefCode:attributes>>;
     selfType::indexedPutObjectRefCode;
     init::(# enter sptype[] #);
     typename::(# do 'objref'->value.puttext #);
     shortTypename::(# do 'or'->value.puttext #);
     print::(# <<SLOT IndexedPutObjectRefCodePrint:dopart>> #);
     printShort::(# <<SLOT IndexedPutObjectRefCodePrintShort:dopart>> #);
     printCode::(# <<SLOT IndexedPutObjectRefCodePrintCode:dopart>> #);
     execute::
       (# fail:
            (# 
            do ('Qualification error in reference assignment'
               ,thrd[],unwind##)->qualificationError
            #);
          l1oref: ^l1ObjectRefEntity;
          l1obj: ^l1ObjectEntity
       <<SLOT IndexedPutObjectRefCodeExecute:dopart>> 
       #);
     sptype: ^staticPatternType         (* qualification of ref.attr *)
  #);

indexedPutKeepObjectRefCode: indexedAccessCode
  (# <<SLOT IndexedPutKeepObjectRefCode:attributes>>;
     selfType::indexedPutKeepObjectRefCode;
     init::(# enter sptype[] #);
     typename::(# do 'PEEK-inx-objref'->value.puttext #);
     shortTypename::(# do 'kor'->value.puttext #);
     print::(# <<SLOT IndexedPutKeepObjectRefCodePrint:dopart>> #);
     printShort::(# <<SLOT IndexedPutKeepObjectRefCodePrintShort:dopart>> #);
     printCode::(# <<SLOT IndexedPutKeepObjectRefCodePrintCode:dopart>> #);
     execute::
       (# fail:
            (# 
            do ('Qualification error in reference assignment'
               ,thrd[],unwind##)->qualificationError
            #);
          l1oref: ^l1ObjectRefEntity;
          l1obj: ^l1ObjectEntity
       <<SLOT IndexedPutKeepObjectRefCodeExecute:dopart>> 
       #);
     sptype: ^staticPatternType         (* qualification of ref.attr *)
  #);

indexedPutKeepTmpRefCode: indexedAccessCode
  (# <<SLOT IndexedPutKeepTmpRefCode:attributes>>;
     selfType::indexedPutKeepTmpRefCode;
     init::(# enter (sptype[],tmpLevel) #);
     typename::(# do 'PEEK-inx-tmpref'->value.puttext #);
     shortTypename::(# do 'ktr'->value.puttext #);
     print::(# <<SLOT IndexedPutKeepTmpRefCodePrint:dopart>> #);
     printShort::(# <<SLOT IndexedPutKeepTmpRefCodePrintShort:dopart>> #);
     printCode::(# <<SLOT IndexedPutKeepTmpRefCodePrintCode:dopart>> #);
     execute::
       (# fail:
            (# 
            do ('Qualification error in reference assignment'
               ,thrd[],unwind##)->qualificationError
            #);
          l1oref: ^l1ObjectRefEntity;
          l1obj: ^l1ObjectEntity
       <<SLOT IndexedPutKeepTmpRefCodeExecute:dopart>> 
       #);
     sptype: ^staticPatternType;        (* qualification of ref.attr *)
     tmpLevel: @integer                 (* placement on tmp stack *)
  #);

checkIndexedPatternQualificationCode: indexedAccessCode
  (* A pattern assignment to a variable pattern is just about to
   * happen, but it is not statically known that it is safe; check
   * that the pattern being assigned is actually qualified, and
   * invoke a run-time error if not; the pattern to assign is on
   * the pattern stack, and the qualification can be looked up
   * by following 'where' *)
  (# <<SLOT CheckIndexedPatternQualificationCodeLib:attributes>>;
     selfType::checkIndexedPatternQualificationCode;
     typename::(# do 'CHK_QUA_PTN-inx'->value.puttext #);
     shortTypename::(# do 'chkqpi'->value.puttext #);
     execute::
       (# l1pat_qua,l1pat_candidate: ^l1PatternEntity;
          listep: ^runtimeLookupIndirectStep;
          oSlice: ^compositeObjectSlice;
          l1pref: ^l1PatternRefEntity;
          l1pat: ^l1PatternEntity
       <<SLOT CheckIndexedPatternQualificationCodeExecute:dopart>>
       #)
  #);

indexedPutPatternCode: indexedPutCode
  (# <<SLOT IndexedPutPatternCode:attributes>>;
     selfType::indexedPutPatternCode;
     init::(# enter sptype[] #);
     typename::(# do 'ptnref'->value.puttext #);
     shortTypename::(# do 'p'->value.puttext #);
     print::(# <<SLOT IndexedPutPatternCodePrint:dopart>> #);
     printShort::(# <<SLOT IndexedPutPatternCodePrintShort:dopart>> #);
     printCode::(# <<SLOT IndexedPutPatternCodePrintCode:dopart>> #);
     execute::
       (# l1pref: ^l1PatternRefEntity;
          l1pat: ^l1PatternEntity
       <<SLOT IndexedPutPatternCodeExecute:dopart>> 
       #);
     sptype: ^staticPatternType         (* stat. known qualification *)
  #);

(* ---------- Repetitions ---------- *)

accessRepCode: betaByteCode
  (# <<SLOT AccessRepCodeLib:attributes>>;
     selfType::< accessRepCode;
     init::< (# enter (where[],l2rdecl[]) do INNER #);
     print::< (# <<SLOT AccessRepCodePrint:dopart>> #);
     printShort::< (# <<SLOT AccessRepCodePrintShort:dopart>> #);
     printCode::< (# <<SLOT AccessRepCodePrintCode:dopart>> #);
     execute::< 
       (# <<SLOT AccessRepCodeExecuteLib:attributes>>;
          targetContext: ^substanceSlice;
          lstep: ^runtimeLookupStep;
          listep: ^runtimeLookupIndirectStep;
          attr: ^l1MapElement;
          targetRep: ^l1RepetitionEntity;
          evalContext: ^substanceSlice
       <<SLOT AccessRepCodeExecute:dopart>>
       #);
     l2rdecl: ^l2RepetitionDecl;        (* decl. of the target rep. *)
     where: ^runtimePath                (* where is the repetition? *)
  #);

callRepCode: accessRepCode
  (# <<SLOT CallRepCodeLib:attributes>>;
     selfType::callRepCode;
     init::(# enter typeKind #);
     typename::(# do 'CALL-rep'->value.puttext #);
     shortTypename::(# do 'calr'->value.puttext #);
     print::(# <<SLOT CallRepCodePrint:dopart>> #);
     printCode::(# <<SLOT CallRepCodePrintCode:dopart>> #);
     execute::
       (# l1oref: ^l1ObjectRefEntity;
          l1pref: ^l1PatternRefEntity;
          l1obj: ^l1ObjectEntity
       <<SLOT CallRepCodeExecute:dopart>> 
       #);
     typeKind: @integer (* one of .*TypeKind, describing the entries *)
  #);

callRepSliceCode: accessRepCode
  (# <<SLOT CallRepSliceCodeLib:attributes>>;
     selfType::callRepSliceCode;
     init::(# enter (lo[],hi[],typeKind) #);
     typename::(# do 'CALL-repsl'->value.puttext #);
     shortTypename::(# do 'clrs'->value.puttext #);
     print::(# <<SLOT CallRepSliceCodePrint:dopart>> #);
     printCode::(# <<SLOT CallRepSliceCodePrintCode:dopart>> #);
     execute::
       (# offset,last: @integer;
          l1oref: ^l1ObjectRefEntity;
          l1pref: ^l1PatternRefEntity;
          l1obj: ^l1ObjectEntity
       <<SLOT CallRepSliceCodeExecute:dopart>> 
       #);
     lo,hi: ^l2Evaluation;
     typeKind: @integer
  #);

getsizeRepCode: accessRepCode
  (* Look up the length of the target repetition 
   * and push that value on the 'integers' stack *)
  (# <<SLOT GetsizeRepCodeLib:attributes>>;
     selfType::getsizeRepCode; 
     typename::(# do 'GETSIZE-rep'->value.puttext #);
     shortTypename::(# do 'gsz'->value.puttext #);
     execute::(# <<SLOT GetsizeRepCodeExecute:dopart>> #)
  #);

resizeRepCode: accessRepCode
  (* Force the target repetition at 'where' to have the length 
   * which is obtained by popping a value off the 'integers' stack *)
  (# <<SLOT ResizeRepCodeLib:attributes>>;
     selfType::resizeRepCode;
     typename::(# do 'RESIZE-rep'->value.puttext #);
     shortTypename::(# do 'rsz'->value.puttext #);
     execute::
       (# count,oldrange: @integer 
       <<SLOT ResizeRepCodeExecute:dopart>> 
       #)
  #);

newRepCode: accessRepCode
  (# <<SLOT NewRepCodeLib:attributes>>;
     selfType::newRepCode;
     typename::(# do 'NEW-rep'->value.puttext #);
     shortTypename::(# do 'newrep'->value.puttext #);
     execute::(# count: @integer <<SLOT NewRepCodeExecute:dopart>> #)
  #);

extendRepCode: accessRepCode
  (# <<SLOT ExtendRepCodeLib:attributes>>;
     selfType::extendRepCode;
     typename::(# do 'EXTEND-rep'->value.puttext #);
     shortTypename::(# do 'ext'->value.puttext #);
     execute::(# count: @integer <<SLOT ExtendRepCodeExecute:dopart>> #)
  #);

transferRepCode: betaByteCode
  (* base pattern for transferring values between two repetitions *)
  (# <<SLOT TransferRepCodeLib:attributes>>;
     selfType::< transferRepCode;
     init::< 
       (# enter
          (from_where[],from_rdecl[]
          ,to_where[],to_rdecl[]
          ,from_lo[],from_hi[],from_evalWhere[]
          ,to_lo[],to_hi[],to_evalWhere[]
          ,to_execute)
       do INNER
       #);
     print::< (# <<SLOT TransferRepCodePrint:dopart>> #);
     printShort::< (# <<SLOT TransferRepCodePrintShort:dopart>> #);
     printCode::< (# <<SLOT TransferRepCodePrintCode:dopart>> #);
     execute::<
       (# from_targetContext,to_targetContext: ^substanceSlice;
          from_lstep,to_lstep: ^runtimeLookupStep; 
          from_listep,to_listep: ^runtimeLookupIndirectStep; 
          from_ndcl,to_ndcl: ^l2NameDcl;
          from_attr,to_attr: ^l1MapElement;
          from_targetRep,to_targetRep: ^l1RepetitionEntity;
          from_evalContext,to_evalContext: ^substanceSlice;
          from_l,from_h,to_l,to_h: @integer (* values of {from,to}_{lo,hi} *)
       <<SLOT TransferRepCodeExecute:dopart>>
       #);
     from_rdecl,to_rdecl: ^l2RepetitionDecl; (* decls of involved reps *)
     from_where,to_where: ^runtimePath; (* where are the repetitions? *)
     from_evalWhere,to_evalWhere: ^runtimePath; (* where to compute bounds *)
     from_lo,from_hi,to_lo,to_hi: ^l2Evaluation; (* bound expressions *)
     to_execute: @boolean
  #);

transferRepHomCode: transferRepCode
  (* transfer values between repetitions directly, when no coercion needed *)
  (# <<SLOT TransferRepHomCodeLib:attributes>>;
     selfType::transferRepHomCode;
     init::
       (# usageAst: ^l2AstNode
       enter (kind,byReference,usageAst[])
       <<SLOT TransferRepHomCodeInit:dopart>>
       #);
     print::(# do kind->byteCodeKindName->output #);
     printShort::(# do kind->byteCodeKindShortName->output #);
     printCode::(# do kind->byteCodeKindName->output #);
     execute::(# <<SLOT TransferRepHomCodeExecute:dopart>> #);
     impl:
       (# thrd: ^thread;
          unwind: ##stackUnwinder;
          from_targetRep,to_targetRep: ^l1RepetitionEntity;
          from_offset,to_offset,length: @integer
       enter
          (thrd[],unwind##
          ,from_targetRep[],to_targetRep[]
          ,from_offset,to_offset,length)
       do INNER
       #);
     executor: ##impl; (* some specialization for the object/ref/ptn used *)
     kind: @integer; (* type of value transferred; one of .*ByteCodeKind *)
     byReference: @boolean (* true: both reps byRef; false: both byVal *)
  #);

splitAccessRepCode: accessRepCode
  (* Handling coercions between 'string' values and repetitions of 'char' *)
  (# <<SLOT SplitAccessRepCodeLib:attributes>>;
     selfType::< splitAccessRepCode;
     init::< (# enter (bound_where[],bound_lo[],bound_hi[]) do INNER #);
     execute::<
       (# t: ^text;
          bound_context: ^substanceSlice;
          bound_l,bound_h,length: @integer
       <<SLOT SplitAccessRepCodeExecute:dopart>>
       #);
     impl: 
       (# thrd: ^thread;
          unwind: ##stackUnwinder;
          t: ^text;
          targetRep: ^l1RepetitionEntity;
          offset,length: @integer
       enter (thrd[],unwind##,targetRep[],t[],offset,length)
       do INNER
       #);
     bound_where: ^runtimePath;		(* where to eval 'bound_{lo,hi}'? *)
     bound_lo,bound_hi: ^l2Evaluation;	(* bounds [X:Y]; NONE: all *)
     executor: ##impl
  #);

getStringCRepCode: splitAccessRepCode
  (# <<SLOT GetStringCRepCodeLib:attributes>>;
     selfType::getStringCRepCode;
     init::(# <<SLOT GetStringCRepCodeInit:dopart>> #);
     typename::(# do 'POP-string_-->_[char]'->value.puttext #);
     shortTypename::(# do 'S->CR'->value.puttext #);
     execute::(# <<SLOT GetStringCRepCodeExecute:dopart>> #)
  #);

putCRepStringCode: splitAccessRepCode
  (# <<SLOT PutCRepStringCodeLib:attributes>>;
     selfType::putCRepStringCode;
     init::(# <<SLOT PutCRepStringCodeInit:dopart>> #);
     typename::(# do 'PUSH-string_<--_[char]'->value.puttext #);
     shortTypename::(# do 'S->CR'->value.puttext #);
     execute::(# <<SLOT PutCRepStringCodeExecute:dopart>> #)
  #);

(* ---------- Primitives ---------- *)

stringLengthCode: accessCode 
  (# <<SLOT StringLengthCodeLib:attributes>>;
     selfType::stringLengthCode;
     typename::(# do 'PUSH-str-len'->value.puttext #);
     shortTypename::(# do 'slen'->value.puttext #);
     execute::
       (# soSlice: ^stringObjectSlice
       <<SLOT StringLengthCodeExecute:dopart>> 
       #)
  #);

stringAtCode: accessCode
  (# <<SLOT StringAtCodeLib:attributes>>;
     selfType::stringAtCode;
     typename::(# do 'POP-int,_PUSH-char-at-inx'->value.puttext #);
     shortTypename::(# do 'at'->value.puttext #);
     execute::
       (# soSlice: ^stringObjectSlice;
          inx: @integer
       <<SLOT StringAtCodeExecute:dopart>> 
       #)
  #);

forkCode: accessCode
  (# <<SLOT ForkCodeLib:attributes>>;
     selfType::forkCode;
     typename::(# do 'FORK'->value.puttext #);
     shortTypename::(# do 'fork'->value.puttext #);
     execute::
       (# coSlice: ^componentObjectSlice
       <<SLOT ForkCodeExecute:dopart>> 
       #)
  #);

killCode: accessCode
  (# <<SLOT KillCodeLib:attributes>>;
     selfType::killCode;
     typename::(# do 'KILL'->value.puttext #);
     shortTypename::(# do 'kill'->value.puttext #);
     execute::
       (# coSlice: ^componentObjectSlice
       <<SLOT KillCodeExecute:dopart>> 
       #)
  #);

suspendCode: accessCode
  (# <<SLOT SuspendCodeLib:attributes>>;
     selfType::suspendCode;
     typename::(# do 'SUSPEND'->value.puttext #);
     shortTypename::(# do 'sus'->value.puttext #);
     execute::
       (# coSlice: ^componentObjectSlice
       <<SLOT SuspendCodeExecute:dopart>> 
       #)
  #);

semPCode: accessCode
  (# <<SLOT SemPCodeLib:attributes>>;
     selfType::semPCode;
     typename::(# do 'SEM-P'->value.puttext #);
     shortTypename::(# do 'p'->value.puttext #);
     execute::
       (# soSlice: ^semaphoreObjectSlice
       <<SLOT SemPCodeExecute:dopart>> 
       #)
  #);

semVCode: accessCode
  (# <<SLOT SemVCodeLib:attributes>>;
     selfType::semVCode;
     typename::(# do 'SEM-V'->value.puttext #);
     shortTypename::(# do 'v'->value.puttext #);
     execute::
       (# soSlice: ^semaphoreObjectSlice
       <<SLOT SemVCodeExecute:dopart>> 
       #)
  #);

semTryPCode: accessCode
  (# <<SLOT SemTryPCodeLib:attributes>>;
     selfType::semTryPCode;
     typename::(# do 'SEM-TryP'->value.puttext #);
     shortTypename::(# do 'try'->value.puttext #);
     execute::
       (# soSlice: ^semaphoreObjectSlice
       <<SLOT SemTryPCodeExecute:dopart>> 
       #)
  #);

semCountCode: accessCode
  (# <<SLOT SemCountCodeLib:attributes>>;
     selfType::semCountCode;
     typename::(# do 'SEM-Count'->value.puttext #);
     shortTypename::(# do 'count'->value.puttext #);
     execute::
       (# soSlice: ^semaphoreObjectSlice
       <<SLOT SemCountCodeExecute:dopart>> 
       #)
  #);

osSystemInCode: betaByteCode
  (# <<SLOT OsSystemInCodeLib:attributes>>;
     selfType::osSystemInCode;
     typename::(# do 'osSystem/in'->value.puttext #);
     shortTypename::(# do 'os/i'->value.puttext #);
     execute::(# <<SLOT OsSystemInCodeExecute:dopart>> #)
  #);

osSystemInOutCode: betaByteCode
  (# <<SLOT OsSystemInOutCodeLib:attributes>>;
     selfType::osSystemInOutCode;
     typename::(# do 'osSystem/inout'->value.puttext #);
     shortTypename::(# do 'os/io'->value.puttext #);
     execute::(# <<SLOT OsSystemInOutCodeExecute:dopart>> #)
  #);
     
evalInCode: betaByteCode
  (# <<SLOT EvalInCodeLib:attributes>>;
     selfType::evalInCode;
     typename::(# do 'eval/in'->value.puttext #);
     shortTypename::(# do 'ev/i'->value.puttext #);
     execute::(# <<SLOT EvalInCodeExecute:dopart>> #)
  #);

evalInOutCode: betaByteCode
  (# <<SLOT EvalInOutCodeLib:attributes>>;
     selfType::evalInOutCode;
     typename::(# do 'eval/inout'->value.puttext #);
     shortTypename::(# do 'ev/io'->value.puttext #);
     execute::(# <<SLOT EvalInOutCodeExecute:dopart>> #)
  #);

(* ---------- Attribute Initializiation ---------- *)

installCode: betaByteCode
  (* Abstract super-pattern for other install.*Code patterns *)
  (# <<SLOT InstallCodeLib:attributes>>;
     selfType::< installCode;
     init::< (# enter l2adcl[] do INNER #);
     print::< (# <<SLOT InstallCodePrint:dopart>> #);
     printCode::< (# <<SLOT InstallCodePrintCode:dopart>> #);
     execute::< (# attr: ^l1MapElement do INNER #);
     offset: @integer; (* in part object; NB: ugly hack used to set this *)
     l2adcl: ^l2AttributeDecl (* used to get more readable 'print' *)
  #);

installPatternCode: installCode
  (* Pop a pattern and install it as the value of 
   * the topmost attribute, then pop the attribute; 
   * this is used to initialize a pattern-valued 
   * attribute *)
  (# <<SLOT InstallPatternCodeLib:attributes>>;
     selfType::installPatternCode;
     typename::(# do 'INSTALL-ptn'->value.puttext #);
     shortTypename::(# do 'in/p'->value.puttext #);
     execute::
       (# l1pat: ^l1PatternEntity
       <<SLOT InstallPatternCodeExecute:dopart>> 
       #)
  #);

installStaticPatternCode: installCode
  (* Create a pattern according to sptype and install
   * it as the value of the topmost attribute, then pop
   * the attribute; this is used to initialize a
   * pattern-valued attribute *)
  (# <<SLOT InstallStaticPatternCodeLib:attributes>>;
     selfType::installStaticPatternCode;
     init::(# enter sptype[] <<SLOT InstallStaticPatternCodeInit:dopart>> #);
     typename::(# do 'INSTALL-static-ptn'->value.puttext #);
     shortTypename::(# do 'in/sp'->value.puttext #);
     printCode::(# <<SLOT InstallStaticPatternCodePrintCode:dopart>> #);
     printStaticPattern::(# <<SLOT InstallStaticPatternCodePrintSP:dopart>> #);
     execute::
       (# l1pat: ^l1PatternEntity
       <<SLOT InstallStaticPatternCodeExecute:dopart>>
       #);
     sptype: ^staticPatternType;
     mark: @integer
  #);

installObjectCode: installCode
  (* Pop an object from Objrefs and install it as the value
   * of the topmost attribute, then pop the attribute; this 
   * is useful to initialize an object-valued attribute *)
  (# <<SLOT InstallObjectCodeLib:attributes>>;
     selfType::installObjectCode;
     typename::(# do 'INSTALL-obj'->value.puttext #);
     shortTypename::(# do 'in/o'->value.puttext #);
     execute::
       (# l1obj: ^l1ObjectEntity
       <<SLOT InstallObjectCodeExecute:dopart>>
       #)
  #);

installStaticObjectCode: installCode
  (* Create an object according to 'sptype' and install it as the
   * value of the topmost attribute, then pop the attribute; this
   * is useful to initialize an object-valued attribute *)
  (# <<SLOT InstallStaticObjectCodeLib:attributes>>;
     selfType::installStaticObjectCode;
     init::(# enter sptype[] <<SLOT InstallStaticObjectCodeInit:dopart>> #);
     typename::(# do 'INSTALL-static-obj'->value.puttext #);
     shortTypename::(# do 'in/so'->value.puttext #);
     printCode::(# <<SLOT InstallStaticObjectCodePrintCode:dopart>> #);
     printStaticPattern::(# <<SLOT InstallStaticObjectCodePrintSP:dopart>> #);
     execute::
       (# l1obj: ^l1ObjectEntity;
          l1pat: ^l1PatternEntity;
          oofo: ^stackableObject
       <<SLOT InstallStaticObjectCodeExecute:dopart>>
       #);
     sptype: ^staticPatternType;
     mark: @integer
  #);

installQuaPatternCode: installCode
  (* Pop a pattern and make it the qualification of a fresh
   * l1PatternRefEntity, then install the ref. entity as the
   * value of the topmost attribute and finally pop that 
   * attribute; this is useful to initialize a variable pattern *)
  (# <<SLOT InstallQuaPatternCodeLib:attributes>>;
     selfType::installQuaPatternCode;
     typename::(# do 'INSTALL-qua-ptn'->value.puttext #);
     shortTypename::(# do 'in/qp'->value.puttext #);
     execute::
       (# l1pat: ^l1PatternEntity
       <<SLOT InstallQuaPatternCodeExecute:dopart>> 
       #)
  #);

installQuaStaticPatternCode: installCode
  (* Create a pattern according to 'sptype' and make it the 
   * qualification of a fresh l1PatternRefEntity, then install 
   * the ref. entity as the value of the topmost attribute and 
   * finally pop that attribute; this is useful to initialize 
   * a variable pattern *)
  (# <<SLOT InstallQuaStaticPatternCodeLib:attributes>>;
     selfType::installQuaStaticPatternCode;
     init::(# enter sptype[] <<SLOT InstallQuaStaticPatternCodeInit:dopart>> #);
     typename::(# do 'INSTALL-qua-static-ptn'->value.puttext #);
     shortTypename::(# do 'in/qsp'->value.puttext #);
     printCode::(# <<SLOT InstallQuaStaticPatternCodePrintCode:dopart>> #);
     printStaticPattern::(#<<SLOT InstallQuaStaticPatternCodePrintSP:dopart>>#);
     execute::
       (# l1pat: ^l1PatternEntity
       <<SLOT InstallQuaStaticPatternCodeExecute:dopart>> 
       #);
     sptype: ^staticPatternType;
     mark: @integer
  #);

installQuaObjectCode: installCode
  (* Pop a pattern and make it the qualification of a fresh 
   * l1ObjectRefEntity, then install the ref. entity as the 
   * value of the topmost attribute and finally pop that 
   * attribute; this is useful to initialize a dynamic 
   * object reference attribute *)
  (# <<SLOT InstallQuaObjectCodeLib:attributes>>;
     selfType::installQuaObjectCode;
     init::(# enter exact #);
     typename::(# do 'INSTALL-qua-obj'->value.puttext #);
     shortTypename::(# do 'in/qo'->value.puttext #);
     execute::
       (# l1pat: ^l1PatternEntity
       <<SLOT InstallQuaObjectCodeExecute:dopart>> 
       #);
     exact: @boolean
  #);

installQuaStaticObjectCode: installCode
  (* Create a pattern according to 'sptype' and make it the 
   * qualification of a fresh l1ObjectRefEntity, then install
   * the ref. entity as the value of the topmost attribute 
   * and finally pop that attribute; this is useful to 
   * initialize a dynamic object reference attribute *)
  (# <<SLOT InstallQuaStaticObjectCodeLib:attributes>>;
     selfType::installQuaStaticObjectCode;
     init::
       (# enter (exact,sptype[])
       <<SLOT InstallQuaStaticObjectCodeInit:dopart>>
       #);
     typename::(# do 'INSTALL-qua-static-obj'->value.puttext #);
     shortTypename::(# do 'in/qso'->value.puttext #);
     printCode::(# <<SLOT InstallQuaStaticObjectCodePrintCode:dopart>> #);
     printStaticPattern::(#<<SLOT InstallQuaStaticObjectCodePrintSP:dopart>>#);
     execute::
       (# l1pat: ^l1PatternEntity
       <<SLOT InstallQuaStaticObjectCodeExecute:dopart>> 
       #);
     exact: @boolean;
     sptype: ^staticPatternType;
     mark: @integer
  #);

installVirtualItemCode: installCode
  (* Find the object denoted by this virtual static item, then
   * install it in the given attr; NBNBNB: we need to find the
   * pattern of the virt.stat.item decl if there is no final
   * stat.item - that is what 'defaultProgram' is used for, and
   * it is the responsibility of the creator of this bytecode to
   * put some code into 'defaultProgram'.  Don`t forget that! *)
  (# <<SLOT InstallVirtualItemCodeLib:attributes>>;
     selfType::installVirtualItemCode;
     init::(# enter l2vsit[] <<SLOT InstallVirtualItemCodeInit:dopart>> #);
     typename::(# do 'INSTALL-v-item'->value.puttext #);
     shortTypename::(# do 'in/vi'->value.puttext #);
     print::(# <<SLOT InstallVirtualItemCodePrint:dopart>> #);
     printCode::(# <<SLOT InstallVirtualItemCodePrintCode:dopart>> #);
     execute::(# <<SLOT InstallVirtualItemCodeExecute:dopart>> #);
     l2vsit: ^l2VirtualStaticItem;
     defaultProgram: @betaByteCodeList (* final not found - use l2vsit ptn *)
  #);

installRepetitionCode: installCode
  (* Create a repetition entity, l1rep, to be installed later;
   * pop a pattern and make it the qualification of the fresh
   * repetition entity, pop an integer and make the rep.entity
   * carry that number of entries; then INNER (for subclasses 
   * to create the actual entries); then install the new 
   * repetition into the given attr *)
  (# <<SLOT InstallRepetitionCodeLib:attributes>>;
     selfType::installRepetitionCode;
     typename::(# do 'INSTALL-rep'->value.puttext #);
     shortTypename::(# do 'in/r'->value.puttext #);
     execute::<
       (# l1pat: ^l1PatternEntity;
          l1rep: ^l1RepetitionEntity;
          len: @integer
       <<SLOT InstallRepetitionCodeExecute:dopart>>
       #)
  #);

installStaticItemRepCode: installRepetitionCode
  (# <<SLOT InstallStaticItemRepCodeLib:attributes>>;
     execute::(# <<SLOT InstallStaticItemRepCodeExecute:dopart>> #)
  #);

installDynamicItemRepCode: installRepetitionCode
  (# <<SLOT InstallDynamicItemRepCodeLib:attributes>>;
     init::(# enter exact #);
     execute::(# <<SLOT InstallDynamicItemRepCodeExecute:dopart>> #);
     exact: @boolean
  #);

installStaticComponentRepCode: installRepetitionCode
  (# <<SLOT InstallStaticComponentRepCodeLib:attributes>>;
     execute::(# <<SLOT InstallStaticComponentRepCodeExecute:dopart>> #)
  #);

installDynamicComponentRepCode: installRepetitionCode
  (# <<SLOT InstallDynamicComponentRepCodeLib:attributes>>;
     init::(# enter exact #);
     execute::(# <<SLOT InstallDynamicComponentRepCodeExecute:dopart>> #);
     exact: @boolean
  #);
     
installVariablePatternRepCode: installRepetitionCode
  (# <<SLOT InstallVariablePatternRepCodeLib:attributes>>;
     execute::(# <<SLOT InstallVariablePatternRepCodeExecute:dopart>> #)
  #);

installObjectPatternCode: installCode
  (# <<SLOT InstallObjectPatternCodeLib:attributes>>;
     selfType::installObjectPatternCode;
     typename::(# do 'INSTALL-ptn_"object"'->value.puttext #);
     shortTypename::(# do 'ip_"object"'->value.puttext #);
     execute::(# <<SLOT InstallObjectPatternCodeExecute:dopart>> #)
  #);

installBooleanPatternCode: installCode
  (# <<SLOT InstallBooleanPatternCodeLib:attributes>>;
     selfType::installBooleanPatternCode;
     typename::(# do 'INSTALL-ptn_"boolean"'->value.puttext #);
     shortTypename::(# do 'ip_"boolean"'->value.puttext #);
     execute::(# <<SLOT InstallBooleanPatternCodeExecute:dopart>> #)
  #);

installCharPatternCode: installCode
  (# <<SLOT InstallCharPatternCodeLib:attributes>>;
     selfType::installCharPatternCode;
     typename::(# do 'INSTALL-ptn_"char"'->value.puttext #);
     shortTypename::(# do 'ip_"char"'->value.puttext #);
     execute::(# <<SLOT InstallCharPatternCodeExecute:dopart>> #)
  #);

installIntegerPatternCode: installCode
  (# <<SLOT InstallIntegerPatternCodeLib:attributes>>;
     selfType::installIntegerPatternCode;
     typename::(# do 'INSTALL-ptn_"integer"'->value.puttext #);
     shortTypename::(# do 'ip_"integer"'->value.puttext #);
     execute::(# <<SLOT InstallIntegerPatternCodeExecute:dopart>> #)
  #);

installRealPatternCode: installCode
  (# <<SLOT InstallRealPatternCodeLib:attributes>>;
     selfType::installRealPatternCode;
     typename::(# do 'INSTALL-ptn_"real"'->value.puttext #);
     shortTypename::(# do 'ip_"real"'->value.puttext #);
     execute::(# <<SLOT InstallRealPatternCodeExecute:dopart>> #)
  #);

installStringPatternCode: installCode
  (# <<SLOT InstallStringPatternCodeLib:attributes>>;
     selfType::installStringPatternCode;
     typename::(# do 'INSTALL-ptn_"string"'->value.puttext #);
     shortTypename::(# do 'ip_"string"'->value.puttext #);
     execute::(# <<SLOT InstallStringPatternCodeExecute:dopart>> #)
  #);

installComponentPatternCode: installCode
  (# <<SLOT InstallComponentPatternCodeLib:attributes>>;
     selfType::installComponentPatternCode;
     typename::(# do 'INSTALL-ptn_"component"'->value.puttext #);
     shortTypename::(# do 'ip_"component"'->value.puttext #);
     execute::(# <<SLOT InstallComponentPatternCodeExecute:dopart>> #)
  #);

installSemaphorePatternCode: installCode
  (# <<SLOT InstallSemaphorePatternCodeLib:attributes>>;
     selfType::installSemaphorePatternCode;
     typename::(# do 'INSTALL-ptn_"semaphore"'->value.puttext #);
     shortTypename::(# do 'ip_"semaphore"'->value.puttext #);
     execute::(# <<SLOT InstallSemaphorePatternCodeExecute:dopart>> #)
  #);

installObjectObjectCode: installCode
  (# <<SLOT InstallObjectObjectCodeLib:attributes>>;
     selfType::installObjectObjectCode;
     typename::(# do 'INSTALL-obj_"object"'->value.puttext #);
     shortTypename::(# do 'io_"object"'->value.puttext #);
     execute::(# <<SLOT InstallObjectObjectCodeExecute:dopart>> #)
  #);

installBooleanObjectCode: installCode
  (# <<SLOT InstallBooleanObjectCodeLib:attributes>>;
     selfType::installBooleanObjectCode;
     typename::(# do 'INSTALL-obj_"boolean"'->value.puttext #);
     shortTypename::(# do 'io_"boolean"'->value.puttext #);
     execute::(# <<SLOT InstallBooleanObjectCodeExecute:dopart>> #)
  #);

installCharObjectCode: installCode
  (# <<SLOT InstallCharObjectCodeLib:attributes>>;
     selfType::installCharObjectCode;
     typename::(# do 'INSTALL-obj_"char"'->value.puttext #);
     shortTypename::(# do 'io_"char"'->value.puttext #);
     execute::(# <<SLOT InstallCharObjectCodeExecute:dopart>> #)
  #);

installIntegerObjectCode: installCode
  (# <<SLOT InstallIntegerObjectCodeLib:attributes>>;
     selfType::installIntegerObjectCode;
     typename::(# do 'INSTALL-obj_"integer"'->value.puttext #);
     shortTypename::(# do 'io_"integer"'->value.puttext #);
     execute::(# <<SLOT InstallIntegerObjectCodeExecute:dopart>> #)
  #);

installRealObjectCode: installCode
  (# <<SLOT InstallRealObjectCodeLib:attributes>>;
     selfType::installRealObjectCode;
     typename::(# do 'INSTALL-obj_"real"'->value.puttext #);
     shortTypename::(# do 'io_"real"'->value.puttext #);
     execute::(# <<SLOT InstallRealObjectCodeExecute:dopart>> #)
  #);

installStringObjectCode: installCode
  (# <<SLOT InstallStringObjectCodeLib:attributes>>;
     selfType::installStringObjectCode;
     typename::(# do 'INSTALL-obj_"string"'->value.puttext #);
     shortTypename::(# do 'io_"string"'->value.puttext #);
     execute::(# <<SLOT InstallStringObjectCodeExecute:dopart>> #)
  #);

installComponentObjectCode: installCode
  (# <<SLOT InstallComponentObjectCodeLib:attributes>>;
     selfType::installComponentObjectCode;
     typename::(# do 'INSTALL-obj_"component"'->value.puttext #);
     shortTypename::(# do 'io_"component"'->value.puttext #);
     execute::(# <<SLOT InstallComponentObjectCodeExecute:dopart>> #)
  #);

installSemaphoreObjectCode: installCode
  (# <<SLOT InstallSemaphoreObjectCodeLib:attributes>>;
     selfType::installSemaphoreObjectCode;
     typename::(# do 'INSTALL-obj_"semaphore"'->value.puttext #);
     shortTypename::(# do 'io_"semaphore"'->value.puttext #);
     execute::(# <<SLOT InstallSemaphoreObjectCodeExecute:dopart>> #)
  #);

l1PatternList: list(# element::l1PatternEntity #);

gatherVirtualCode: betaByteCode
  (* !!! NB: This should probably at some point be replaced 
   * by a number of lower level instructions, but for now it 
   * allows us to jump into compiled object creation sooner 
   * than it would otherwise have been possible; this instruction
   * gathers and merges the contributions to a virtual *)
  (# <<SLOT GatherVirtualCodeLib:attributes>>;
     selfType::gatherVirtualCode;
     init::(# enter l2virtdcl[] #);
     typename::(# do 'GATHER-virt'->value.puttext #);
     shortTypename::(# do 'gv'->value.puttext #);
     print::(# <<SLOT GatherVirtualCodePrint:dopart>>#);
     printShort::(# <<SLOT GatherVirtualCodePrintShort:dopart>> #);
     printCode::(# <<SLOT GatherVirtualCodePrintCode:dopart>>#);
     execute::
       (# oSlice: ^compositeObjectSlice; (* the context of l2virtdcl *)
          l2fdcl: ^l2FinalDecl; (* used when checking finals *)
          maxlen,actualLen: @integer; (* to check final-caused restrictions *)
          checkSlice,checkVChain: @boolean; (* how to check them *)
          restrs: ^l1PatternList
       <<SLOT GatherVirtualCodeExecute:dopart>> 
       #);
     l2virtdcl: ^l2VirtualDecl
  #);

(* 
 * local variables:
 * ee-beta-main-file: "~/gbeta-0.9/src/main/gbeta.bet"
 * end:
 *)
