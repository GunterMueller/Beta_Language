(* FILE "./private/ibetaCommonlibbody.bet"
 *
 * Copyright (C) 1997-2001 Erik Ernst
 *
 * This file is part of "gbeta" -- a generalized version of the
 * programming language BETA.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is destributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * Among other things, the copyright notice and this notice must be
 * preserved on all copies.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program, probably in a file named COPYING; if not,
 * write to the Free Software Foundation, Inc., 675 Mass Ave,
 * Cambridge, MA 02139, USA.
 *
 * To contact the author by email: eernst@cs.auc.dk
 *
 * To contact the author by snail-mail:
 *    Erik Ernst
 *    Department of Computer Science
 *    University of Aalborg
 *    DK-9220 Aalborg OE
 *    Denmark
 *
 * $Id: ibetaCommonlibbody.bet,v 1.105 2001/07/01 21:44:11 eernst Exp $
 *)

ORIGIN 'ibetaCommonlib';
INCLUDE 'basicinterplib';
INCLUDE 'ibetaOnelib';
INCLUDE 'ibetaSlicelib'

(************************************************************
 *                                                          *
 *                Controlled Stack Unwinding                *
 *                                                          *
 ************************************************************)

-- UnwindScope:dopart --
do
   (* ensure that 'theEC[]<>NONE' means that 'unwindHereTo' ran *)
   NONE->theEC[];

   (* normal execution happens in here *)
   L: (# unwindHereTo: stackUnwinder(# do ec[]->theEC[]; leave L #)
      do unwindHereTo##->unwind##;
         INNER unwindScope
      #);

   (* normal execution terminated; check _how_ *)
   (if theEC[]<>NONE then
       (* unwinding the stack *)
       (if true
        // theEC## <= exitLeave## then theEC[]->onLeave
        // theEC## <= exitRestart## then theEC[]->onRestart
        // theEC## <= exitKill## then theEC[]->onKill
        // theEC## <= exitError## then theEC[]->onError
        else
           'unrecognized exit code'
             ->internalError
       if)
    (* else: normal execution, no action *)
   if)

-- LeastCommonSuperPattern:dopart --
do
   (* a common superpattern is a sublist of both 'left'
    * and 'right' *)
   &l1PatternEntity[]->lcsp[];
   'ibetaCommonlibbody.bet/81'->notyet; (* !!! *)

(*************************************************************
 *                                                           *
 *                        l0Transient                        *
 *                                                           *
 *************************************************************)

-- TransientTrace:dopart --
do
   (this(interpreterBase).private.traceStream[],indentation,false)
     ->print

-- TransientKindFailure:dopart --
do
   'Comparing '->msg[];
   t1[]->msg.puttext;
   ' with '->msg.puttext;
   t2[]->msg.puttext;
   (msg[],thrd[],unwind##)->incomparableError

(************************************************************
 *                                                          *
 *                       iteratorBase                       *
 *                                                          *
 ************************************************************)

-- IteratorBaseTrace:dopart --
do
   (this(interpreterBase).private.traceStream[],indentation,false)
     ->printShort

(************************************************************
 *                                                          *
 *                          l2Libs                          *
 *                                                          *
 ************************************************************)

-- ObjectSpecificationListLocalType:dopart --
do
   (if stype_cache[]<>NONE then
       stype_cache[]->stype[];
    else
       (if empty then
           predefinedSyntax.predefinedNames.private.objectSType.copy
             ->stype_cache[]
             ->stype[]
        else
           (* create the local context ("context,world,usageAst"),
            * and then use the general getStaticType  *)
           (# context: ^staticContext;
              theScope: ^scopeNode
           do (head).elm.scope[]->theScope[];
              (NONE,NONE,theScope.location)->position.init;
              (* we cannot do the Right Thing here, this list is
               * not an l2AstNode, so we announce the first element
               * of the list as "current ast" *)
              (head).elm[]->theScope.world.setAst;
              (position[],theScope.world[],(head).elm[])
                ->theScope.getInitialContext
                ->context[];
              (context[],theScope.world[],(head).elm[])
                ->getStaticType
                ->stype_cache[]
                ->stype[];
              (*test-obs ('localStaticType of','l')->observe; *)
              (*test-obs ('','l')->stype.observe; *)
           #)
       if)
   if)

-- ObjectSpecificationListGetType:dopart --
do
   (if true
    // size=1 then
       (* normal, simple ospec. *)
       (context[],world[],usageAst[])
         ->(head).elm.getStaticType
         ->stype[]

    // size=0 then
       (* empty; this is possible if, e.g., SLOT program:merge is missing *)
       predefinedSyntax.predefinedNames.private.objectSType.copy
         ->stype[]

    else
       (* multiple object specification: always a pattern type; also
        * covers the "object" case where size=0 *)
       (# current_sptype,pattern_sptype,accum_sptype: ^staticPatternType;
          stocp: ^staticOCP
       do
          (* start out with an empty type for accumulation *)
          (context.getInitialSyntax,patternTypeKind)
            ->(&staticPatternType[]).init
            ->accum_sptype[];
          (* it is statically known until somebody spoils it *)
          accum_sptype.makeKnownStatically;
          (* accumulate all contributions, merging them one-by-one *)
          scan
          (# tmp_stype: ^staticType
          do (* get the next contribution *)
             (context[],world[],usageAst[])
               ->current.getStaticType
               ->tmp_stype[];
             (if tmp_stype##<=staticPatternType## then
                 tmp_stype[]->current_sptype[];
                 (* by the run-time semantics, all contributions
                  * are coerced into patterns *)
                 (if current_sptype.kind=patternTypeKind then
                     current_sptype[]->pattern_sptype[]
                  else
                     (patternTypeKind,usageAst[])
                       ->current_sptype.coerce
                       ->pattern_sptype[];
                     (* TYPE_COERCION: 'current_sptype' describes the value
                      * of the 'current' object specification, i.e., it
                      * describes the pattern value of ptn.ref attributes
                      * and the pattern of the object value of object or
                      * object ref. attributes; hence, we already have a
                      * description of the pattern that is being extracted
                      * from whatever that 'current' obj.spec. is and
                      * the coercion is a NO-OP *)
                 if);
                 (* merge it *)
                 (pattern_sptype[],current[],usageAst[])
                   ->accum_sptype.mergeMustSucceed
              else
                 (* a contribution _must_ be of a pattern type *)
                 (# msg: ^text
                 do 'Attempt to perform a type merge '->msg[];
                    (tmp_stype.typename).withIndefArticle->msg.puttext;
                    (msg[]
                    ,'Use only patterns for merging'
                    ,usageAst[])->staticError
                 #)
             if)
          #);
          (* deliver result *)
          accum_sptype[]->stype[]
       #)
   if)

-- ObjectSpecificationListGetRawType:dopart --
do
   (if true
    // size=1 then
       (* normal, simple ospec. *)
       (context[],world[],usageAst[])
         ->(head).elm.getRawStaticType
         ->stype[]

    // size=0 then
       (* empty; this is possible if, e.g., SLOT program:merge is missing *)
       predefinedSyntax.predefinedNames.private.objectSType.copy
         ->stype[]

    else
       (* multiple object specification: always a pattern type; also
        * covers the "object" case where size=0 *)
       (# current_sptype,pattern_sptype,accum_sptype: ^staticPatternType;
          stocp: ^staticOCP
       do
          (* start out with an empty type for accumulation *)
          (context.getInitialSyntax,patternTypeKind)
            ->(&staticPatternType[]).init
            ->accum_sptype[];
          (* it is statically known until somebody spoils it *)
          accum_sptype.makeKnownStatically;
          (* accumulate all contributions, merging them one-by-one *)
          scan
          (# tmp_stype: ^staticType
          do 
             (* get the next contribution *)
             (context[],world[],usageAst[])
               ->current.getRawStaticType
               ->tmp_stype[];

             (* check and use it *)
             (if tmp_stype##<=staticPatternType## then
                 tmp_stype[]->current_sptype[];
                 (* by the run-time semantics, all contributions
                  * are coerced into patterns *)
                 (if current_sptype.kind=patternTypeKind then
                     current_sptype[]->pattern_sptype[]
                  else
                     (patternTypeKind,usageAst[])
                       ->current_sptype.coerce
                       ->pattern_sptype[];
                     (* TYPE_COERCION: 'current_sptype' describes the value
                      * of the 'current' object specification, i.e., it
                      * describes the pattern value of ptn.ref attributes
                      * and the pattern of the object value of object or
                      * object ref. attributes; hence, we already have a
                      * description of the pattern that is being extracted
                      * from whatever that 'current' obj.spec. is and
                      * the coercion is a NO-OP *)
                 if);
                 (* merge it *)
                 (pattern_sptype[],current[],usageAst[])
                   ->accum_sptype.mergeMustSucceed
              else
                 (* a contribution _must_ be of a pattern type *)
                 (# msg: ^text
                 do 'Attempt to perform a type merge '->msg[];
                    (tmp_stype.typename).withIndefArticle->msg.puttext;
                    (msg[]
                    ,'Use only patterns for merging'
                    ,usageAst[])->staticError
                 #)
             if)
          #);
          (* deliver result *)
          accum_sptype[]->stype[]
       #)
   if)

-- ObjectSpecificationListGetSub:dopart --
do
   (if true
    // size=1 then
       (* normal, simple ospec. *)
       (context[],world[],usageAst[])
         ->(head).elm.getStaticSubstance
         ->stsub[]

    // size=0 then
       (* "object" is not as convenient here as for static types *)
       (# sptype: ^staticPatternType;
          scope: ^scopeNode;
          lcount,count: @integer;
          l2ast: ^l2AstNode;
          path: ^runtimePath;
       do (context.getInitialSyntax,patternTypeKind)
            ->(&staticPatternType[]).init
            ->sptype[];
          (* prepare the 'pathTo' *)
          (NONE,NONE,context.getInitialSyntax)
            ->(&runtimePath[]).init
            ->path[];
          (* construct the path to 'object' *)
          (context.getSyntax).getScopeNode->scope[];
          L: (if scope.location<>predefinedSyntax[] then
                 scope.location->l2ast[];
                 (if l2ast##<=l2LabelledImp## then
                     lcount+1->lcount
                  else
                     count+1->count
                 if);
                 scope.enclosing[]->scope[];
                 restart L
             if);
          (predefinedSyntax[],count,lcount)
            ->(&runtimeOutStep[]).init
            ->path.append;
          (predefinedSyntax.predefinedNames.private.objectDcl[],false)
            ->(&runtimeLookupStep[]).init
            ->path.append;
          (* create the substance *)
          (context[],path[],NONE,usageAst[])
            ->sptype.staticInstantiate
            ->stsub[]
       #)

    else
       (* multiple object specification: always a pattern *)
       (# stype: ^staticType;
          path: ^runtimePath;
          sptype: ^staticPatternType
       do (context[],world[],usageAst[])
            ->getStaticType
            ->stype[];
          (if stype##<=staticPatternType## then
              stype[]->sptype[];

              (* getStaticType should have delivered a pattern *)
              (if sptype.kind<>patternTypeKind then
                  'Multiple object specification was not a pattern'
                    ->internalError
              if);

              (* prepare the 'pathTo' *)
              (NONE,NONE,context.getInitialSyntax)
                ->(&runtimePath[]).init
                ->path[];
              (* we cannot go out and find this pattern: it is computed *)
              path.addStepImpossible;

              (* create the substance *)
              (context[],path[],NONE,usageAst[])
                ->sptype.staticInstantiate
                ->stsub[]
           else
              'Got a non-pattern type from a proper merge of types'
                ->internalError
          if)
       #)
   if)

-- ObjectSpecificationListLookup:dopart --
do
   (if true
    // size=1 then
       (* normal, simple ospec. *)
       (# l2ospec: ^l2ObjectSpecification;
          l2aden: ^l2AttributeDenotation;
          l2desc: ^l2ObjectDescriptor
       do (head).elm[]->l2ospec[];
          (* we must distinguish between descriptors and a.deno.s *)
          (if true
           // l2ospec##<=l2AttributeDenotation## then
              (* business as usual *)
              l2ospec[]->l2aden[];
              (thrd[],unwind##,dContext[])
                ->l2aden.lookup
                ->l1ent[]
           // l2ospec##<=l2ObjectDescriptor## then
              (* a descriptor looked up is the pattern it denotes *)
              l2ospec[]->l2desc[];
              (thrd[],unwind##,dContext[],NONE)
                ->l2desc.obtainPattern
                ->l1ent[]
           else
              'unexpected ospec for ospec-list lookup'
                ->internalError
          if)
       #)

    // size=0 then
       (* empty; may be caused by missing SLOT program:merge, et al. *)
       predefinedSubstance.private.objectPattern.copy->l1ent[]

    else
       (* compute the merged pattern denoted by this non-trivial ospec-list *)
       (thrd[],unwind##,dContext[],NONE)
         ->obtainPatternRef
         ->l1ent[]
   if)

-- ObjectSpecificationListObtainPattern:dopart --
do
   (thrd[],unwind##,dContext[],attr[])
     ->obtainPatternRef
     ->l1pat[];
   (if l1pat[]=NONE then
       ('Trying to access a pattern via a NONE reference'
       ,thrd[],unwind##)->refNoneError
   if)

-- ObjectSpecificationListObtainPatternRef:dopart --
do
   (if true
    // size=1 then
       (* normal, simple ospec. *)
       (thrd[],unwind##,dContext[],attr[])
         ->(head).elm.obtainPatternRef
         ->l1pat[]

    // size=0 then
       (* empty; may be caused by missing SLOT program:merge, and elsehow *)
       predefinedSubstance.private.objectPattern.copy->l1pat[]

    else
       (* multiple object specification: always a pattern; each
        * contributor is coerced into a pattern, results merged *)
       predefinedSubstance.private.objectPattern.copy->l1pat[];
       scan
       (# do (thrd[],unwind##
          ,(thrd[],unwind##,dContext[],NONE)->current.obtainPattern)
            ->l1pat.merge
       #);
       (* only after having merged all contributions: announce the result *)
       (if attr[]<>NONE then l1pat[]->attr.to[] if)
   if)

-- ObjectSpecificationListObtainObject:dopart --
do
   (thrd[],unwind##,dContext[],renew,attr[])
     ->obtainObjectRef
     ->l1obj[];
   (if l1obj[]=NONE then
       ('Trying to access an object via a NONE reference'
       ,thrd[],unwind##)->refNoneError
   if)

-- ObjectSpecificationListObtainObjectRef:dopart --
do
   (if true
    // size=1 then
       (* normal, simple ospec. *)
       (thrd[],unwind##,dContext[],renew,attr[])
         ->(head).elm.obtainObjectRef
         ->l1obj[]

    // size=0 then
       (* empty; may be caused by missing SLOT program:merge, and elsehow *)
       (thrd[],unwind##,attr[])
         ->predefinedSubstance.private.objectPattern.instantiate
         ->l1obj[]

    else
       (* multiple object specification: always a pattern; each
        * contributor is coerced into a pattern, results merged,
        * combined result instantiated, ref. returned *)
       (# l1pat: ^l1PatternEntity
       do (thrd[],unwind##,dContext[],NONE)
            ->obtainPattern
            ->l1pat[];
          (thrd[],unwind##,attr[])
            ->l1pat.instantiate
            ->l1obj[]
       #)
   if)

-- ObjectSpecificationListExecute:dopart --
do
   (if true
    // size=1 then
       (* normal, simple ospec. *)
       (thrd[],unwind##,dContext[],renew)
         ->(head).elm.execute

    // size=0 then
       (* empty; may be caused by missing SLOT program:merge, and elsehow;
        * this is a no-op: we should execute an instance of 'object' *)

    else
       (* multiple object specification: always a pattern; each
        * contributor is coerced into a pattern, results merged,
        * combined result instantiated, executed *)
       (# l1pat: ^l1PatternEntity;
          l1obj: ^l1ObjectEntity
       do (thrd[],unwind##,dContext[],renew,NONE)
            ->obtainObject
            ->l1obj[];
          (thrd[],unwind##)
            ->l1obj.execute
       #)
   if)

-- ObjectSpecificationListGetCplr:dopart --
do
   (* we have to deal with each element of the list of specified
    * patterns, because the combined pattern does not exist at
    * run-time: there is no runtime path at the end of which such
    * a combined pattern can be found; so we generate code to look
    * up each of the pre-existing (attribute denotation) patterns,
    * and to create the final pattern by adding any main parts
    * specified as part of this o.spec.list ("inserted items") *)
   (if true
    // size=1 then
       (* no "&" used *)
       &exeCompiler
       (# generate::
            (# l2ospec: ^l2ObjectSpecification;
               l2aden: ^l2AttributeDenotation;
               aden_cplr: ^exeCompiler;
               stocp: ^staticOCP;
               framePos: @integer;
               path: ^runtimePath
            do (head).elm[]->l2ospec[];
               (if true
                // l2ospec##<=l2AttributeDenotation## then
                   (* simplest case: execute an existing entity *)
                   l2ospec[]->l2aden[];
                   (context[],world[],usageAst[])
                     ->l2aden.getCompiler
                     ->aden_cplr[];
                   (program[],cInfo[])
                     ->aden_cplr.generate

                // l2ospec##<=l2ObjectDescriptor## then
                   (* inserted item *)
                   (context[],world[],usageAst[],program[],cInfo[],false)
                     ->generateGetTmpObject
                     ->stocp[];
                   (if not stocp.sptype.doesNothing then
                       ('ibetaCommonlibbody.bet/547',stocp.pathTo[])
                         ->(&callDoCode[]).init
                         ->program.append
                   if)
                else
                   'Unexpected kind of object specification'
                     ->internalError
               if)
            #)
       #)[]->ec[];
       usageAst[]->ec.usageAst[]

    // size=0 then
       (* e.g. an empty prefix *)
       &exeCompiler[]->ec[];
       usageAst[]->ec.usageAst[]

    else
       (* general case, includes merging ("&"); must denote a pattern *)
       &exeCompiler
       (# generate::
            (# framePos: @integer;
               sptype: ^staticPatternType;
               path: ^runtimePath
            do
               (* compute the resulting, merged pattern *)
               (context[],world[],usageAst[],program[],cInfo[],false)
                 ->generateGetPattern
                 ->sptype[];
               (* create and execute the object *)
               cInfo.allocateTmp->framePos;
               ('ibetaCommonlibbody.bet/456',framePos)
                 ->(&createTmpCode[]).init
                 ->program.append;
               (* execute it *)
               (NONE,NONE,context.getInitialSyntax)
                 ->(&runtimePath[]).init
                 ->path[];
               (* we use '(head).elm' to represent this
                * 'objectSpecificationList' because there is no
                * 'l2AstNode' which directly represents the
                * generated temporary, but this choice of
                * "representative" is unique since we choose it in
                * this manner everywhere and the '(head).elm' is
                * never used to generate a temporary on its own *)
               (sptype[],(head).elm[],framePos)
                 ->(&runtimeTmpStep[]).init
                 ->path.append;
               (if not sptype.doesNothing then
                   ('ibetaCommonlibbody.bet/594',path[])
                     ->(&callDoCode[]).init
                     ->program.append
               if)
            #)
       #)[]->ec[];
       usageAst[]->ec.usageAst[]
   if)

-- ObjectSpecificationListGetEnterCplr:dopart --
do
   (if true
    // size=1 then
       (* no "&" used, i.e. simple a construct *)
       &enterCompiler
       (# l2ospec: ^l2ObjectSpecification;
          l2aden: ^l2AttributeDenotation;
          l2desc: ^l2ObjectDescriptor;
          subEnterCplr: ^enterCompiler;
          framePos: @integer;
          desc_stocp: ^staticOCP;
          prepare::
            (# do (head).elm[]->l2ospec[];
               (if true
                // l2ospec##<=l2AttributeDenotation## then
                   (* simplest case: assign to an existing entity *)
                   l2ospec[]->l2aden[];
                   (context[],world[],usageAst[]
                   ,this(getEnterCompiler).execute)
                     ->l2aden.getEnterCompiler
                     ->subEnterCplr[];
                   (program[],cInfo[])
                     ->subEnterCplr.prepare

                // l2ospec##<=l2ObjectDescriptor## then
                   (* inserted item *)
                   l2ospec[]->l2desc[];
                   (* get the object *)
                   (context[],world[],usageAst[],program[],cInfo[],false)
                     ->generateGetTmpObject
                     ->desc_stocp[];
                   (* entry point is always the explicit mainpart *)
                   desc_stocp.sptype.slices.first->desc_stocp.destSlice[];
                   (* create the compiler *)
                   (world[],usageAst[],l2desc[],this(getEnterCompiler).execute)
                     ->desc_stocp.getEnterCompiler
                     ->subEnterCplr[];
                   (program[],cInfo[])
                     ->subEnterCplr.prepare
                else
                   'Unexpected kind of object specification'
                     ->internalError
               if)
            #);
          more::(# do subEnterCplr.more->value #);
          generate::
            (# do (program[],cInfo[])
                 ->subEnterCplr.generate
                 ->stran[]
            #);
          cleanup::(# do (program[],cInfo[])->subEnterCplr.cleanup #)
       #)[]->nc[];
       usageAst[]->nc.usageAst[]

    // size=0 then
       (* cannot have enter-list contributions *)
       &enterEmptyCompiler[]->nc[]

    else
       (* general case, includes merging ("&") *)
       &enterCompiler
       (# framePos: @integer;
          l2ospec: ^l2ObjectSpecification;
          l2desc: ^l2ObjectDescriptor;
          stocp: ^staticOCP;
          subEnterCplr: ^enterCompiler;
          prepare::
            (# do (* compute the resulting, merged pattern *)
               (context[],world[],usageAst[],program[],cInfo[],false)
                 ->generateGetTmpObject
                 ->stocp[];
               (* the entry point is known iff last contribution is an obj.desc.
                * because such one ends in the new mainpart; !! consider:
                * does 'staticallyKnownBottom' already answer
                * exactly this question? *)
               (last).elm[]->l2ospec[];
               (if l2ospec##<=l2ObjectDescriptor## then
                   l2ospec[]->l2desc[];
                   l2desc.MainPart[]
                     ->stocp.sptype.ast2slice
                     ->stocp.destSlice[]
               if);
               (world[],usageAst[],(head).elm[],this(getEnterCompiler).execute)
                 ->stocp.getEnterCompiler
                 ->subEnterCplr[];
               (program[],cInfo[])
                 ->subEnterCplr.prepare
            #);
          more::(# do subEnterCplr.more->value #);
          generate::
            (# do (program[],cInfo[])
                 ->subEnterCplr.generate
                 ->stran[]
            #);
          cleanup::(# do (program[],cInfo[])->subEnterCplr.cleanup #)
       #)[]->nc[];
       usageAst[]->nc.usageAst[]
   if)

-- ObjectSpecificationListGetExitCplr:dopart --
do
   (if true
    // size=1 then
       (* no "&" used, i.e. "normal" case *)
       &exitCompiler
       (# l2ospec: ^l2ObjectSpecification;
          l2aden: ^l2AttributeDenotation;
          l2desc: ^l2ObjectDescriptor;
          desc_stocp: ^staticOCP;
          subExitCplr: ^exitCompiler;
          framePos: @integer;
          prepare::
            (# do (head).elm[]->l2ospec[];
               (if true
                // l2ospec##<=l2AttributeDenotation## then
                   (* simplest case: assign to an existing entity *)
                   l2ospec[]->l2aden[];
                   (context[],world[],usageAst[])
                     ->l2aden.getExitCompiler
                     ->subExitCplr[];
                   (program[],cInfo[])
                     ->subExitCplr.prepare

                // l2ospec##<=l2ObjectDescriptor## then
                   (* inserted item *)
                   l2ospec[]->l2desc[];
                   (* determine and (possibly create and) push the object *)
                   (context[],world[],usageAst[],program[],cInfo[],false)
                     ->generateGetTmpObject
                     ->desc_stocp[];
                   (* entry point is always the explicit mainpart *)
                   desc_stocp.sptype.slices.first->desc_stocp.destSlice[];
                   (* create the compiler *)
                   (world[],l2desc[],usageAst[])
                     ->desc_stocp.getExitCompiler
                     ->subExitCplr[];
                   (program[],cInfo[])
                     ->subExitCplr.prepare
                else
                   'Unexpected kind of object specification'
                     ->internalError
               if)
            #);
          more::(# do subExitCplr.more->value #);
          generate::
            (# do (program[],cInfo[])
                 ->subExitCplr.generate
                 ->stran[]
            #);
          cleanup::(# do (program[],cInfo[])->subExitCplr.cleanup #)
       #)[]->xc[];
       usageAst[]->xc.usageAst[]

    // size=0 then
       (* cannot have exit-list contributions *)
       &exitEmptyCompiler[]->xc[]

    else
       (* general case, includes merging ("&") *)
       &exitCompiler
       (# framePos: @integer;
          l2ospec: ^l2ObjectSpecification;
          l2desc: ^l2ObjectDescriptor;
          stocp: ^staticOCP;
          subExitCplr: ^exitCompiler;
          prepare::
            (# do (* get the object *)
               (context[],world[],usageAst[],program[],cInfo[],false)
                 ->generateGetTmpObject
                 ->stocp[];
               (* the entry point is known iff last contribution is an obj.desc.
                * because such one ends in the new mainpart; !! consider:
                * does 'staticallyKnownBottom' already answer
                * exactly this question? *)
               (last).elm[]->l2ospec[];
               (if l2ospec##<=l2ObjectDescriptor## then
                   l2ospec[]->l2desc[];
                   l2desc.MainPart[]
                     ->stocp.sptype.ast2slice
                     ->stocp.destSlice[]
               if);
               (world[],(head).elm[],usageAst[])
                 ->stocp.getExitCompiler
                 ->subExitCplr[];
               (program[],cInfo[])
                 ->subExitCplr.prepare
            #);
          more::(# do subExitCplr.more->value #);
          generate::
            (# do (program[],cInfo[])
                 ->subExitCplr.generate
                 ->stran[]
            #);
          cleanup::(# do (program[],cInfo[])->subExitCplr.cleanup #)
       #)[]->xc[];
       usageAst[]->xc.usageAst[]
   if)

-- ObjectSpecificationListGetEnterExitCplr:dopart --
do
   (if true
    // size=1 then
       (* no "&" used, the "normal" case *)
       (# l2ospec: ^l2ObjectSpecification;
          l2aden: ^l2AttributeDenotation;
          l2desc: ^l2ObjectDescriptor;
          subExitCplr: ^exitCompiler
       do
          (head).elm[]->l2ospec[];
          (if true
           // l2ospec##<=l2AttributeDenotation## then
              (* simplest case: assign/eval existing entity *)
              l2ospec[]->l2aden[];
              (context[],world[],usageAst[])
                ->l2aden.getEnterExitCompiler
                ->(nc[],xc[])

           // l2ospec##<=l2ObjectDescriptor## then
              (* inserted item *)
              l2ospec[]->l2desc[];

              &enterCompiler
              (# desc_stocp: ^staticOCP;
                 framePos: @integer;
                 subEnterCplr: ^enterCompiler;
                 prepare::
                   (# do (* get the object *)
                      (context[],world[],usageAst[],program[],cInfo[],false)
                        ->generateGetTmpObject
                        ->desc_stocp[];
                      (* entry point is always the explicit mainpart *)
                      desc_stocp.sptype.slices.first->desc_stocp.destSlice[];
                      (* create the compiler *)
                      (world[],l2desc[],usageAst[])
                        ->desc_stocp.getEnterExitCompiler
                        ->(subEnterCplr[],subExitCplr[]);
                      (program[],cInfo[])
                        ->subEnterCplr.prepare
                   #);
                 more::(# do subEnterCplr.more->value #);
                 generate::
                   (# do (program[],cInfo[])
                        ->subEnterCplr.generate
                        ->stran[]
                   #);
                 cleanup::(# do (program[],cInfo[])->subEnterCplr.cleanup #)
              #)[]->nc[];
              usageAst[]->nc.usageAst[];

              &exitCompiler
              (* this exit compiler only delegates, but 'subExitCplr' would
               * remain NONE at return time from this method, so we have
               * to construct an entity which will be able to look up
               * 'subExitCplr' when it gets assigned once in the future *)
              (# prepare::(# do (program[],cInfo[])->subExitCplr.prepare #);
                 more::(# do subExitCplr.more->value #);
                 generate::
                   (# do (program[],cInfo[])
                        ->subExitCplr.generate
                        ->stran[]
                   #);
                 cleanup::(# do (program[],cInfo[])->subExitCplr.cleanup #)
              #)[]->xc[];
              usageAst[]->xc.usageAst[]

           else
              'Unexpected kind of object specification'
                ->internalError
          if)
       #)

    // size=0 then
       (* no i/o lists possible *)
       &enterEmptyCompiler[]->nc[];
       &exitEmptyCompiler[]->xc[]

    else
       (* general case, includes merging ("&") *)
       (# subExitCplr: ^exitCompiler
       do
          &enterCompiler
          (# framePos: @integer;
             l2ospec: ^l2ObjectSpecification;
             l2desc: ^l2ObjectDescriptor;
             stocp: ^staticOCP;
             subEnterCplr: ^enterCompiler;
             prepare::
               (# do (* get the object *)
                  (context[],world[],usageAst[],program[],cInfo[],false)
                    ->generateGetTmpObject
                    ->stocp[];
                  (* the entry point is known iff last contribution is
                   * an obj.desc. because such one ends in the new mainpart;
                   * !! consider: does 'staticallyKnownBottom' already
                   * answer exactly this question? *)
                  (last).elm[]->l2ospec[];
                  (if l2ospec##<=l2ObjectDescriptor## then
                      l2ospec[]->l2desc[];
                      l2desc.MainPart[]
                        ->stocp.sptype.ast2Slice
                        ->stocp.destSlice[]
                  if);
                  (world[],(head).elm[],usageAst[])
                    ->stocp.getEnterExitCompiler
                    ->(subEnterCplr[],subExitCplr[]);
                  (program[],cInfo[])
                    ->subEnterCplr.prepare
               #);
             more::(# do subEnterCplr.more->value #);
             generate::
               (# do (program[],cInfo[])
                    ->subEnterCplr.generate
                    ->stran[]
               #);
             cleanup::(# do (program[],cInfo[])->subEnterCplr.cleanup #)
          #)[]->nc[];
          usageAst[]->nc.usageAst[];

          &exitCompiler
          (* this exit compiler only delegates, but 'subExitCplr' would
           * remain NONE at return time from this method, so we have
           * to construct an entity which will be able to look up
           * 'subExitCplr' when it gets assigned once in the future *)
          (# prepare::(# do (program[],cInfo[])->subExitCplr.prepare #);
             more::(# do subExitCplr.more->value #);
             generate::
               (# do (program[],cInfo[])
                    ->subExitCplr.generate
                    ->stran[]
               #);
             cleanup::(# do (program[],cInfo[])->subExitCplr.cleanup #)
          #)[]->xc[];
          usageAst[]->xc.usageAst[]
       #)
   if)

-- ObjectSpecificationListGenerateGetPattern:dopart --
do
   (if true
    // size=1 then
       (* no "&" used; simple expression *)
       (context[],world[],usageAst[],program[],cInfo[],noneAllowed)
         ->(head).elm.generateGetPattern
         ->gensptype[]

    // size=0 then
       (* an empty merge, means "object" *)
       'ibetaCommonlibbody.bet/812'
         ->(&getObjectPatternCode[]).init
         ->program.append;
       (context.getInitialSyntax,patternTypeKind)
         ->(&staticPatternType[]).init
         ->gensptype[]

    else
       (* general case, includes merging ("&") *)
       localStaticType->stype[];
       (if staticPushPatternFlag
           and stype.knownStatically
           and stype.hasExistingParts then
           (* get hold of the static pattern, then create the run-time ptn *)
           (context[],world[],usageAst[])->getStaticType->gensptype[];
           (if staticPredefinedPatternFlag and gensptype.isPredefined then
               program[]->gensptype.generateGetPredefinedPattern
            else
               ('ibetaCommonlibbody.bet/885',gensptype[])
                 ->(&getStaticPatternCode[]).init
                 ->program.append
           if)
        else
           (* push the first operand *)
           (context[],world[],usageAst[],program[],cInfo[],noneAllowed)
             ->(head).elm.generateGetPattern;
           (* get and merge each non-first operand *)
           this(l2ObjectSpecificationList).scan
           (# nonfirst: @boolean
           do (if nonfirst then
                  (context[],world[],usageAst[],program[],cInfo[],noneAllowed)
                    ->current.generateGetPattern;
                  'ibetaCommonlibbody.bet/987'
                    ->(&mergePatternCode[]).init
                    ->program.append
               else
                  true->nonfirst
              if)
           #);
           (* since this is a non-trivial merge the type is of pattern kind *)
           (context[],world[],usageAst[])
             ->getStaticType
             ->gensptype[]
       if)
   if)

-- ObjectSpecificationListGenerateGetObject:dopart --
do
   (if true
    // size=1 then
       (* no "&" used; simple expression *)
       (context[],world[],usageAst[],program[],cInfo[],noneAllowed,renew)
         ->(head).elm.generateGetObject
         ->gensptype[]

    // size=0 then
       (* an empty merge, means "object" *)
       'ibetaCommonlibbody.bet/917'
         ->(&getObjectPatternCode[]).init
         ->program.append;
       'ibetaCommonlibbody.bet/920'
         ->(&createObjectCode[]).init
         ->program.append;
       (objectTypeKind,usageAst[])
         ->((context[],world[],usageAst[])->getStaticType).coerce
         ->gensptype[];
       (* TYPE_COERCION: was a pattern, instance created; no adjustments *)

    else
       (* general case, includes merging ("&"); must denote a pattern *)
       localStaticType->stype[];
       (if staticCreateObjectFlag
           and stype.knownStatically
           and stype.hasExistingParts then
           (* get hold of the static pattern *)
           (context[],world[],usageAst[])->getStaticType->gensptype[];
           (* create run-time ptn from static pattern *)
           (if staticPredefinedPatternFlag and gensptype.isPredefined then
               program[]->gensptype.generateGetPredefinedObject
            else
               ('ibetaCommonlibbody.bet/944',gensptype[])
                 ->(&createStaticObjectCode[]).init
                 ->program.append
           if);
           (objectTypeKind,usageAst[])
             ->gensptype.coerce
             ->gensptype[]
           (* TYPE_COERCION: was a pattern, object created - no adjustments *)
        else
           (* push the first operand *)
           (context[],world[],usageAst[],program[],cInfo[],false)
             ->(head).elm.generateGetPattern;
           (* get and merge each non-first operand *)
           this(l2ObjectSpecificationList).scan
           (# nonfirst: @boolean
           do (if nonfirst then
                  (context[],world[],usageAst[],program[],cInfo[],false)
                    ->current.generateGetPattern;
                  'ibetaCommonlibbody.bet/1053'
                    ->(&mergePatternCode[]).init
                    ->program.append
               else
                  true->nonfirst
              if)
           #);
           (* all the contributions have been merged into one
            * pattern; now create and execute the object *)
           'ibetaCommonlibbody.bet/1062'
             ->(&createObjectCode[]).init
             ->program.append;

           (* get type of generated object, describe the created object *)
           (context[],world[],usageAst[])
             ->getStaticType
             ->gensptype[];
           (objectTypeKind,usageAst[])
             ->gensptype.coerce
             ->gensptype[];
           (* TYPE_COERCION: was a pattern, object created - no adjustments *)
       if)
   if)

-- ObjectSpecificationListGenerateGetTmpObject:dopart --
do
   (if true
    // size=1 then
       (* no "&" used; simple expression *)
       (context[],world[],usageAst[],program[],cInfo[],renew,false)
         ->(head).elm.generateGetTmpObject
         ->genstocp[]

    // size=0 then
       (* an empty merge, means "object" *)
       'ibetaCommonlibbody.bet/987'
         ->(&getObjectPatternCode[]).init
         ->program.append;
       (context[],world[],usageAst[])
         ->getStaticSubstance
         ->genstocp[];
       (Identity[],cInfo.allocateTmp)
         ->genstocp.createTmpVersion
         ->genstocp[];
       ('ibetaCommonlibbody.bet/996',cInfo.tmpLevel)
         ->(&createTmpCode[]).init
         ->program.append;

    else
       (* general case, includes merging ("&"); must denote a pattern *)
       localStaticType->stype[];
       (if staticCreateObjectFlag
           and stype.knownStatically
           and stype.hasExistingParts then
           (* get hold of the static pattern, then create the run-time ptn *)
           (# stocp: ^staticOCP;
              framePos: @integer
           do (context[],world[],usageAst[])
                ->getStaticSubstance
                ->stocp[];
              (Identity[],cInfo.allocateTmp->framePos)
                ->stocp.createTmpVersion
                ->genstocp[];
              (if staticPredefinedPatternFlag and stocp.sptype.isPredefined then
                  (framePos,program[])->stocp.sptype.generateGetPredefinedTmp
               else
                  ('ibetaCommonlibbody.bet/1025',framePos,stocp.sptype[])
                    ->(&createStaticTmpCode[]).init
                    ->program.append
              if)
           #)
        else
           (# sptype: ^staticPatternType
           do
              (* push the first operand *)
              (context[],world[],usageAst[],program[],cInfo[],false)
                ->(head).elm.generateGetPattern;
              (* get and merge each non-first operand *)
              this(l2ObjectSpecificationList).scan
              (# nonfirst: @boolean
              do (if nonfirst then
                     (context[],world[],usageAst[],program[],cInfo[],false)
                       ->current.generateGetPattern;
                     'ibetaCommonlibbody.bet/1136'
                       ->(&mergePatternCode[]).init
                       ->program.append
                  else
                     true->nonfirst
                 if)
              #);
              (* all the contributions have been merged into one
               * pattern; now describe and create the tmp-object *)
              (context[],world[],usageAst[])
                ->getStaticType
                ->sptype[];
              (context[],world[],usageAst[],Identity[],cInfo.allocateTmp)
                ->sptype.tmpInstantiate
                ->genstocp[];
              ('ibetaCommonlibbody.bet/1151',cInfo.tmpLevel)
                ->(&createTmpCode[]).init
                ->program.append
           #)
       if)
   if)

-- ObjectSpecificationListGeneratePutObject:dopart --
do
   (if true
    // size=1 then
       (* no "&" used; simple expression *)
       (# l2ospec: ^l2ObjectSpecification;
          l2aden: ^l2AttributeDenotation;
       do (head).elm[]->l2ospec[];
          (if true
           // l2ospec##<=l2AttributeDenotation## then
              (* simplest case: get hold of an existing object *)
              l2ospec[]->l2aden[];
              (context[],world[],usageAst[],program[],cInfo[])
                ->l2aden.generatePutObject
                ->(gensptype[],qualExact)

           // l2ospec##<=l2ObjectDescriptor## then
              (* inserted item *)
              (# msg: ^text
              do 'Attempt to reference-assign '->msg[];
                 (l2ospec.typename).withIndefArticle->msg.puttext;
                 (msg[]
                 ,'Use dynamic references as targets of reference assignments'
                 ,usageAst[])->staticError
              #)
           else
              'Unexpected kind of object specification'
                ->internalError
          if)
       #)

    // size=0 then
       (* an empty merge, but we cannot get this, can we? *)
       'Trying to \'generatePutObject\' for an empty merge'
         ->internalError

    else
       (* general case, includes merging ("&"); must denote a pattern *)
       ('Attempt to reference-assign to a merge of patterns (P&Q..)'
       ,'Use dynamic references as targets of reference assignments'
       ,usageAst[])->staticError
   if)

-- ObjectSpecificationListGeneratePutPattern:dopart --
do
   (if true
    // size=1 then
       (* no "&" used; simple expression *)
       (# l2ospec: ^l2ObjectSpecification;
          l2aden: ^l2AttributeDenotation;
       do (head).elm[]->l2ospec[];
          (if true
           // l2ospec##<=l2AttributeDenotation## then
              (* simplest case: get hold of an existing object *)
              l2ospec[]->l2aden[];
              (context[],world[],usageAst[],program[],cInfo[])
                ->l2aden.generatePutPattern
                ->gensptype[]

           // l2ospec##<=l2ObjectDescriptor## then
              (* inserted item *)
              (# msg: ^text
              do 'Attempt to pattern-assign '->msg[];
                 (l2ospec.typename).withIndefArticle->msg.puttext;
                 (msg[]
                 ,'Use pattern variables as targets of pattern assignments'
                 ,usageAst[])->staticError
              #)
           else
              'Unexpected kind of object specification'
                ->internalError
          if)
       #)

    // size=0 then
       (* an empty merge, but we cannot get this, can we? *)
       'Trying to \'generatePutPattern\' for an empty merge'
         ->internalError

    else
       (* general case, includes merging ("&"); must denote a pattern *)
       ('Attempt to pattern-assign to a merge of patterns (P&Q..)'
       ,'Use pattern var.s or object refs as targets of pattern assignments'
       ,usageAst[])->staticError
   if)

-- ObjectSpecificationLocalStaticSubstance:dopart --
do
   (# l2napl: ^l2NameApl;
      l2aden: ^l2AttributeDenotation;
      position: @runtimePath;
      context: ^staticContext
   do (NONE,NONE,scope.location)->position.init;
      this(l2ObjectSpecification)[]->scope.world.setAst;
      (position[],scope.world[],this(l2ObjectSpecification)[])
        ->scope.getInitialContext->context[];

      (* we could avoid this type-casing but it takes several
       * identical virtuals with only l2NameApl having
       * special treatment .. *)
      (if this(l2ObjectSpecification)##<=l2NameApl## then
          this(l2ObjectSpecification)[]->l2napl[];
          l2napl.findGlobalLookupNode->l2aden[];
          (context[],scope.world[],this(l2ObjectSpecification)[])
            ->l2aden.getStaticSubstance
            ->stsub[]
       else
          (context[],scope.world[],this(l2ObjectSpecification)[])
            ->getStaticSubstance
            ->stsub[]
      if)
   #)

-- ObjectDescriptorPrintShort:dopart --
do
   (dest[],indentation,false)->MainPart.printShort

-- ObjectDescriptorGetVDecl:dopart --
do
   (if father[]<>NONE then
       (if father##<=l2VDecl## then
           (* yes! *)
           father[]->l2vdcl[]
        else
           (* not part of a v.chain *)
           NONE->l2vdcl[]
       if)
    else
       'Bad syntax tree around an object descriptor'
         ->internalError
   if)

-- MainPartPrintShort:dopart --
do
   t.clear;
   '`'->t.puttext;
   mpsPosition->t.puttext;
   t[]->output

-- MainPartLocalStaticType:dopart --
do
   (if private.sptype_cache[]<>NONE then
       private.sptype_cache[]->sptype[];
    else
       (# l2desc: ^l2ObjectDescriptor;
          context: ^staticContext;
          stype: ^staticType;
          position: @runtimePath
       do
          (* init *)
          (NONE,NONE,this(l2MainPart)[])->position.init;
          this(l2MainPart)[]->theScopeNode.world.setAst;
          father[]->l2desc[];

          (* obtain the context, shifting it one step out, since
           * main parts are the borderline between scope nodes *)
          (l2desc.scope.location,false)->position.addStepOut;
          (position[],theScopeNode.world[],this(l2Mainpart)[])
            ->l2desc.scope.getInitialContext
            ->context[];

          (* get the local static type of the descriptor *)
          (context[],theScopeNode.world[],this(l2MainPart)[])
            ->l2desc.getStaticType
            ->stype[];
          (if stype##<=staticPatternType## then
              stype[]->sptype[];
              sptype.copy
                ->private.sptype_cache[]
                ->sptype[]
           else
              'Object descriptor had a non-pattern type'
                ->internalError
          if)
       #);
       (*test-obs  ('localStaticType of','l')->observe; *)
       (*test-obs  ('','l')->sptype.observe; *)
   if)

-- MainPartLocalStaticContext:dopart --
do
   (# position: @runtimePath;
   do (NONE,NONE,this(l2MainPart)[])->position.init;
      this(l2MainPart)[]->theScopeNode.world.setAst;
      (position[],theScopeNode.world[],this(l2MainPart)[])
        ->theScopeNode.getInitialContext
        ->stcon[]
   #)

-- MainPartDoDeclLists:dopart --
do
   (* Note that we extend the repetitions one by one; this has O(n^2)
    * costs for a length n repetition, but we really do not expect
    * to have main parts with more than a few specialized vdecls or
    * final static items *)
   (# push: (# inx,top: @integer do top+1->top; INNER #);
      spcVDclPush: @push
        (# l2svdcl: ^l2SpecializedVDecl
        enter l2svdcl[]
        do 1->private.spcVDcls.extend;
           l2svdcl[]->private.spcVDcls[top][];
           1->private.spcVDclInxs.extend;
           (l2svdcl.getTheNameDcl).offset->private.spcVDclInxs[top]
        #);
      finSItemsPush: @push
        (# l2sdcl: ^l2SimpleDecl;
           l2fsitem: ^l2FinalStaticItem
        enter (l2sdcl[],l2fsitem[])
        do 1->private.finSItems.extend;
           l2fsitem[]->private.finSItems[top][];
           1->private.finSItemInxs.extend;
           (l2sdcl.getTheNameDcl).offset->private.finSItemInxs[top]
        #);
   do Attributes.scan
      (# l2sdcl: ^l2SimpleDecl
      do (if true
          // current##<=l2SpecializedVDecl## then current[]->spcVDclPush
          // current##<=l2SimpleDecl## then
             current[]->l2sdcl[];
             (if l2sdcl.ReferenceSpecification##<=l2FinalStaticItem## then
                 (l2sdcl[],l2sdcl.ReferenceSpecification[])->finSItemsPush
             if)
         if)
      #)
      (* Debugging the declreps:
       *
       *  '\n>> ibetaCommonlibbody.bet/1187: VDecls << '->screen.puttext;
       *  (for inx:private.spcVDcls.range repeat
       *       newline; private.spcVDclInxs[inx]->putint; ': '->puttext;
       *       (screen[],0,false)->private.spcVDcls[inx].print
       *  for);
       *  (if private.spcVDclInxs.range<>private.spcVDcls.range then
       *      '\n***** NB: declRep.range<>inxRep.range!!'->puttext
       *  if);
       *  '\n>> ibetaCommonlibbody.bet/1195: FinStItems << '->screen.puttext;
       *  (for inx:private.finSItems.range repeat
       *       newline; private.finSItemInxs[inx]->putint; ': '->puttext;
       *       (screen[],0,false)->private.finSItems[inx].print
       *  for);
       *  (if private.finSItemInxs.range<>private.finSItems.range then
       *      '\n***** NB: declRep.range<>inxRep.range!!'->puttext
       *  if);
       *  '\n>> ibetaCommonlibbody.bet/1188: END << '->screen.puttext;
       *)
   #)

-- MainPartScanSpecializedVDecls:dopart --
do
   (if not private.declListsDone then
       doDeclLists;
       true->private.declListsDone
   if);
   (for inx:private.spcVDcls.range repeat
        private.spcVDcls[inx][]->current[];
        INNER scanSpecializedVDecls
   for)

-- MainPartScanSpecializedVDeclInxs:dopart --
do
   (if not private.declListsDone then
       doDeclLists;
       true->private.declListsDone
   if);
   (for inx:private.spcVDclInxs.range repeat
        private.spcVDclInxs[inx]->current;
        INNER scanSpecializedVDeclInxs
   for)

-- MainPartScanSpecializedVDeclsAndInxs:dopart --
do
   (if not private.declListsDone then
       doDeclLists;
       true->private.declListsDone
   if);
   (for inx:private.spcVDcls.range repeat
        private.spcVDcls[inx][]->currentVdcl[];
        private.spcVDclInxs[inx]->currentInx;
        INNER scanSpecializedVDeclsAndInxs
   for)

-- MainPartScanFinalStaticItems:dopart --
do
   (if not private.declListsDone then
       doDeclLists;
       true->private.declListsDone
   if);
   (for inx:private.finSItems.range repeat
        private.finSItems[inx][]->current[];
        INNER scanFinalStaticItems
   for)

-- MainPartScanFinalStaticItemInxs:dopart --
do
   (if not private.declListsDone then
       doDeclLists;
       true->private.declListsDone
   if);
   (for inx:private.finSItemInxs.range repeat
        private.finSItemInxs[inx]->current;
        INNER scanFinalStaticItemInxs
   for)

-- MainPartScanFinalStaticItemsAndInxs:dopart --
do
   (if not private.declListsDone then
       doDeclLists;
       true->private.declListsDone
   if);
   (for inx:private.finSItemInxs.range repeat
        private.finSItems[inx][]->currentItem[];
        private.finSItemInxs[inx]->currentInx;
        INNER scanFinalStaticItemsAndInxs
   for)

-- AttributeDenotationCheckContext:dopart --
do
   (* consistency check *)
   (if context.getSyntax<>scope.location then
       (if scope.location->context.setFocus then
           (* !! OK, inconsistency repaired; consider printing a warning *)
        else
           (* provide some information before stopping with an error message *)
           (# line: (# do newline; (for 60 repeat '%'->put for)#);
              msg: ^text
           do line;
              ('Analysis of',0)->this(l2AttributeDenotation).observe;
              ('   Location',0)->(scope.location).observe;
              ('    Context',0)->context.observe;
              line;
              'Inconsistency between "context" and analyzed syntax'
                ->internalError;
           #)
       if)
   if)

-- AttributeDenotationGetOCPByTransient:dopart --
do
   (# stsub: ^staticSubstance;
      stocp2: ^staticOCP;
      stran: ^staticTransient;
      sortran: ^staticORefTransient;
      path: ^runtimePath
   do
      (* premises *)
      (context[],world[],usageAst[])->check;

      (* get the transient object reference *)
      (context[],world[],this(l2AttributeDenotation)[])
        ->getStaticSubstance
        ->stsub[];
      (if stsub##<=staticOCP## then
          stsub[]->stocp2[];
          (if stocp2.sptype.kind
           // patternTypeKind // patternRefTypeKind then
              (* remote access into pattern [var]; statically-create object *)
              (generatingAst[],unknownStackPos)
                ->stocp2.createTmpVersion
                ->stsub[]
          if)
      if);
      (world[],this(l2AttributeDenotation)[])
        ->stsub.getStaticTransientOut
        ->stran[];

      (if stran##<=staticORefTransient## then
          (* was an object reference, deliver a description saying
           * "an object with structure as specified in 'stran',
           * located somewhere (at an unknown pos) on the tmp stack";
           * we use 'this(l2AttributeDenotation)' as the 'generatingAst' arg.
           * because the exit list which seems to be the direct generator
           * of the temporary may indeed be used elsewhere in the same
           * enclosing imperative, but 'this(l2AttributeDenotation)'
           * is unique *)
          stran[]->sortran[];
          (context[],world[],usageAst[]
          ,this(l2AttributeDenotation)[],unknownStackPos)
            ->sortran.sptype.tmpInstantiate
            ->stocp[]
       else
          (* it was not an object reference *)
          (# t: ^text
          do 'Attempt to dereference '->t[];
             (stran.typename).withIndefArticle->t.puttext;
             (t[]
             ,'Make this attribute denotation deliver a reference to an object'
             ,this(l2AttributeDenotation)[])->staticError
          #)
      if)
   #)

-- AttributeDenotationGenerateGetComputedObject:dopart --
do
   (# solution: (# exit  'Make it deliver exactly one object reference' #);
      subExitCplr: ^exitCompiler;
      path: ^runtimePath;
      stran: ^staticTransient;
      oref_stran: ^staticORefTransient;
      framePos: @integer;
      subSTran: ^staticTransient
   do
      (context[],world[],usageAst[])
        ->getExitCompiler
        ->subExitCplr[];
      (subExitCplr[],program[],cInfo[])->generateExitOneValue
      (# EmptyOutput::
           (# msg: ^text
           do 'This attribute denotation delivers nothing'->msg[];
              ' (it has an empty exit-list)'->msg.puttext;
              (msg[],solution,this(l2AttributeDenotation)[])->staticError
           #);
         MultipleOutputs::
           (# msg: ^text
           do 'This attribute denotation delivers'->msg[];
              ' more than one value'->msg.puttext;
              (msg[],solution,this(l2AttributeDenotation)[])->staticError
           #)
      #)->subSTran[];
      (if subSTran##<=staticORefTransient## then
          subSTran[]->oref_stran[]
       else
          (* does not deliver an object ref. *)
          (# msg: ^text
          do 'This attribute denotation delivers '->msg[];
             (subSTran.typename).withIndefArticle->msg.puttext;
             (msg[],solution,this(l2AttributeDenotation)[])->staticError
          #)
      if);
      (if oref_stran.sptype.kind<>objectTypeKind then
          (* objectRefTypeKind: ensure that the result is not NONE *)
          'ibetaCommonlibbody.bet/1435'
            ->(&checkNoneOrefCode[]).init
            ->program.append
      if);
      (* move the computed object to 'tmpObjs' *)
      cInfo.allocateTmp->framePos;
      ('ibetaCommonlibbody.bet/1441',framePos)
        ->(&moveObjectTmpCode[]).init
        ->program.append;
      (* create a description of this object using the given type *)
      (NONE,NONE,context.getInitialSyntax)
        ->(&runtimePath[]).init
        ->path[];
      (oref_stran.sptype[],this(l2AttributeDenotation)[],framePos)
        ->(&runtimeTmpStep[]).init
        ->path.append;
      (context[],path[],NONE,usageAst[])
        ->oref_stran.sptype.staticInstantiate
        ->computed_stocp[]
        ->world.enhance
   #)

-- NameAplFindGlobalLookupNode:dopart --
do
   (if father[]<>NONE then
       (if true
        // father##<=l2Remote## then
           (* could be first or last segment of the remote *)
           (# l2rem: ^l2Remote;
           do father[]->l2rem[];
              (if l2rem.NameApl[]=this(l2NameApl)[] then
                  l2rem[]->l2aden[]
               else
                  this(l2NameApl)[]->l2aden[]
              if)
           #)
        // father##<=l2ComputedRemote## then
           (* must be last segment of the computed remote *)
           father[]->l2aden[]
        else
           this(l2NameApl)[]->l2aden[]
       if)
    else
       (* !! this ought to be an internal error .. unless it could be a
        * perfectly reasonable situation with a SLOT?  So we just .. *)
       this(l2NameApl)[]->l2aden[]
   if)

-- ImperativeListExecute:dopart --
do
   scan(# do (thrd[],unwind##,dContext[])->current.execute #)

-- EvaluationGetOCPByTransient:dopart --
do
   (# stran: ^staticTransient;
      sortran: ^staticORefTransient;
      path: ^runtimePath
   do
      (* premises *)
      (context[],world[],usageAst[])->check;

      (* get the transient object reference *)
      (context[],world[])
        ->getStaticTransientOut
        ->stran[];

      (if stran##<=staticORefTransient## then
          (* was an object reference, deliver a description saying
           * "an object with structure as specified in 'stran',
           * located somewhere (at an unknown pos) on the tmp stack";
           * we use 'usageAst' as the 'generatingAst' arg. because the
           * exit list (which seems to be the direct generator of the
           * temporary) may indeed be used elsewhere in the same
           * enclosing imperative; this means that 'usageAst' must
           * be unique for this purpose, but that is also the case
           * as long as 'usageAst' is the enclosing 'l2ComputedRemote'
           * but it
           *                            !!!
           *
           * should be considered when using method this in other
           * contexts *)
          stran[]->sortran[];
          (context[],world[],usageAst[]
          ,generatingAst[],unknownStackPos)
            ->sortran.sptype.tmpInstantiate
            ->stocp[]
       else
          (* it was not an object reference *)
          (# t: ^text
          do 'Attempt to dereference '->t[];
             (stran.typename).withIndefArticle->t.puttext;
             (t[]
             ,'Make the evaluation deliver a reference to an object'
             ,usageAst[])->staticError
          #)
      if)
   #)

-- EvaluationLocalOCPByTransient:dopart --
do
   (# context: ^staticContext;
      position: @runtimePath
   do (NONE,NONE,scope.location)->position.init;
      this(l2Evaluation)[]->scope.world.setAst;
      (position[],scope.world[],this(l2Evaluation)[])
        ->scope.getInitialContext
        ->context[];
      (context[],scope.world[],usageAst[],generatingAst[])
        ->getOCPByTransient
        ->stocp[]
   #)

-- EvaluationLocalStaticTransientOut:dopart --
do
   (# context: ^staticContext;
      position: @runtimePath
   do (NONE,NONE,scope.location)->position.init;
      this(l2Evaluation)[]->scope.world.setAst;
      (position[],scope.world[],this(l2Evaluation)[])
        ->scope.getInitialContext
        ->context[];
      (context[],scope.world[])
        ->getStaticTransientOut
        ->stran[]
   #)

-- EvaluationLocalStaticTransientIn:dopart --
do
   (# context: ^staticContext;
      position: @runtimePath
   do (NONE,NONE,scope.location)->position.init;
      this(l2Evaluation)[]->scope.world.setAst;
      (position[],scope.world[],this(l2Evaluation)[])
        ->scope.getInitialContext
        ->context[];
      (context[],scope.world[])
        ->getStaticTransientIn
        ->stran[]
   #)

-- EvaluationCheckContext:dopart --
do
   (* consistency check *)
   (if context.getSyntax<>scope.location then
       (if scope.location->context.setFocus then
           (* !! OK, inconsistency repaired; consider printing a warning *)
        else
           (* provide some information before stopping with an error message *)
           (# line: (# do newline; (for 60 repeat '%'->put for)#);
              msg: ^text
           do line;
              ('Analysis of',0)->this(l2Evaluation).observe;
              ('   Location',0)->(scope.location).observe;
              ('    Context',0)->context.observe;
              line;
              'Inconsistency between "context" and analyzed syntax'
                ->internalError;
           #)
       if)
   if)

-- CoerceBaseLib:attributes --

addCode:
  (* maintain the invariant the 'insPos' is the
   * bytecode just before the insertion point,
   * and 'insPos=NONE' means insert at beginning
   * of 'program' *)
  (# bc: ^betaByteCode
  enter bc[]
  do (bc[],insPos[])->program.insertAfter->insPos[]
  #);

getKind:
  (# stran: ^staticTransient;
     kind: @integer (* one of .*byteCodeKind *)
  enter stran[]
  do (if true
      // stran##<=staticBooleanTransient## then
         booleanByteCodeKind->kind
      // stran##<=staticCharTransient## then
         charByteCodeKind->kind
      // stran##<=staticIntegerTransient## then
         integerByteCodeKind->kind
      // stran##<=staticRealTransient## then
         realByteCodeKind->kind
      // stran##<=staticStringTransient## then
         stringByteCodeKind->kind
         (* string1ByteCodeKind never occurs: not from a literal *)
      // stran##<=staticORefTransient##
      // stran##<=staticOQuaTransient## then
         orefByteCodeKind->kind
      // stran##<=staticPRefTransient##
      // stran##<=staticPQuaTransient## then
         ptnByteCodeKind->kind
      // stran##<=staticNoneTransient##
      // stran##<=staticRepeatedTransient## then
         'unexpected transient from a repetition'
           ->internalError
      // stran##<=staticSublistTransient## then
         (* general case, push objects and run program *)
         'ibetaCommonlibbody.bet/1477'->notyet; (* !!! *)
      else
         'unrecognized kind of transient from repetition'
           ->internalError
     if)
  exit kind
  #)

-- AssignmentCoerceLib:attributes --

fail:
  (# msg: ^text
  do
     'Cannot coerce '->msg[];
     (evSTran.typename).withIndefArticle->msg.puttext;
     ' into '->msg.puttext;
     (taSTran.typename).withIndefArticle->msg.puttext;
     (msg[]
     ,'Rewrite the assignment, perhaps using an auxiliary variable'
     ,usageAst[])->staticError
  #)

-- AssignmentCoerce:dopart --
do
   (if evSTran##<>taSTran## then
       (if true
        // evSTran##=staticCharTransient## then
           (if true
            // taSTran##=staticIntegerTransient## then
               'ibetaCommonlibbody.bet/1492'
                 ->(&coerceCharIntegerCode[]).init
                 ->addCode
            // taSTran##=staticStringTransient## then
               'ibetaCommonlibbody.bet/1496'
                 ->(&coerceCharStringCode[]).init
                 ->addCode
            else
               fail
           if)
        // evSTran##=staticIntegerTransient## then
           (if true
            // taSTran##=staticCharTransient## then
               'ibetaCommonlibbody.bet/1505'
                 ->(&coerceIntegerCharCode[]).init
                 ->addCode
            // taSTran##=staticRealTransient## then
               'ibetaCommonlibbody.bet/1509'
                 ->(&coerceIntegerRealCode[]).init
                 ->addCode
            else
               fail
           if)
        // evSTran##=staticRealTransient## then
           (if taSTran##=staticIntegerTransient## then
               'ibetaCommonlibbody.bet/1517'
                 ->(&coerceRealIntegerCode[]).init
                 ->addCode
            else
               fail
           if)
        // evSTran##=staticStringTransient## then
           (# toCRep:
                (# srTran: ^staticRepeatedTransient
                enter srtran[]
                do (if srTran.entrySTran##<=staticCharTransient## then
                       ('ibetaCommonlibbody.bet/1528'
                       ,srTran.pathTo[],srTran.l2rdecl[]
                       ,srTran.boundsPathTo[],srTran.lo[],srTran.hi[])
                         ->(&getStringCRepCode[]).init
                         ->addCode
                    else
                       fail
                   if)
                #);
              ssTran: ^staticStringTransient
           do evSTran[]->ssTran[];
              (if ssTran.singleton then
                  (if true
                   // taSTran##=staticCharTransient## then
                      'ibetaCommonlibbody.bet/1542'
                        ->(&coerceString1CharCode[]).init
                        ->addCode
                   // taSTran##=staticIntegerTransient## then
                      'ibetaCommonlibbody.bet/1546'
                        ->(&coerceString1IntegerCode[]).init
                        ->addCode
                   // taSTran##<=staticRepeatedTransient## then
                      (* str1 --> crep *)
                      taSTran[]->toCRep
                   else
                      fail
                  if)
               else
                  (if taSTran##<=staticRepeatedTransient## then
                      taSTran[]->toCRep
                   else
                      (* source is a string, not known to be a singleton,
                       * so we cannot coerce it *)
                      fail
                  if)
              if)
           #)
        // evSTran##=staticNoneTransient## then
           (if true
            // taSTran##=staticOQuaTransient## then
               'ibetaCommonlibbody.bet/1568'
                 ->(&noneObjectCode[]).init
                 ->addCode
            // taSTran##=staticPQuaTransient## then
               'ibetaCommonlibbody.bet/1572'
                 ->(&nonePatternCode[]).init
                 ->addCode
            else
               fail
           if)
        // evSTran##=staticORefTransient## then
           (# taOQTran: ^staticOQuaTransient;
              last_step: ^runtimeStep;
              maybe_ipCode: ^betaByteCode;
              ipCode: ^indexedPutCode
           do (if taSTran##<=staticOQuaTransient## then
                  (* oref->oqua: reference assignment; consider qua-check *)
                  taSTran[]->taOQTran[];
                  (if not (evSTran[]->taOQTran.orefCompatible) then
                      (* potential run-time error; warning given during check,
                       * but now we must insert a run-time check *)
                      (if not taOQTran.pathTo.empty then
                          taOQTran.pathTo.last->last_step[];
                          (if last_step##<=runtimeSelectStep## then
                              (* this is access into a rep. - "..->r[3][]" *)
                              (if inspos[]=NONE then
                                  program.first->maybe_ipCode[]
                               else
                                  inspos.succ[]->maybe_ipCode[]
                              if);
                              (if maybe_ipCode##<=indexedPutCode## then
                                  (* !!! this is a really ugly hack:
                                   * we look into the program to find
                                   * the evaluation; this will only work
                                   * because we know that the coercion
                                   * code will be inserted immediately
                                   * before the indexed..PutCode
                                   * instruction, so 'inspos' points to
                                   * such in instruction *)
                                  maybe_ipCode[]->ipCode[];
                                  ('ibetaCommonlibbody.bet/1763'
                                  ,ipCode.where[]
                                  ,ipCode.l2eval[]
                                  ,ipCode.evalWhere[]
                                  ,taOQTran.exact)
                                    ->(&checkIndexedObjectQualificationCode[])
                                  .init
                                    ->addCode
                               else
                                  'Unexpected byte code for rep.assign'
                                    ->internalError
                              if)
                           else
                              ('ibetaCommonlibbody.bet/1771'
                              ,taOQTran.pathTo[],taOQTran.exact)
                                ->(&checkObjectQualificationCode[]).init
                                ->addCode
                          if)
                       else
                          (* path is empty - must be object *)
                          ('ibetaCommonlibbody.bet/1778'
                          ,taOQTran.pathTo[],taOQTran.exact)
                            ->(&checkObjectQualificationCode[]).init
                            ->addCode
                      if)
                   (*else*)
                      (* statically safe ref. assignment - no action *)
                  if)
               else
                  fail
              if)
           #)
        // evSTran##=staticPRefTransient## then
           (# taPQTran: ^staticPQuaTransient;
              last_step: ^runtimeStep;
              maybe_ipCode: ^betaByteCode;
              ipCode: ^indexedPutCode
           do (if taSTran##<=staticPQuaTransient## then
                  (* pref->pqua: reference assignment; consider qua-check *)
                  taSTran[]->taPQTran[];
                  (if not (evSTran[]->taPQTran.prefCompatible) then
                      (* potential run-time error; warning given during check,
                       * but now we must insert a run-time check *)
                      (if not taPQTran.pathTo.empty then
                          taPQTran.pathTo.last->last_step[];
                          (if last_step##<=runtimeSelectStep## then
                              (* this is access into a rep. - "..->r[3]##" *)
                              (if inspos[]=NONE then
                                  program.first->maybe_ipCode[]
                               else
                                  inspos.succ[]->maybe_ipCode[]
                              if);
                              (if maybe_ipCode##<=indexedPutCode## then
                                  (* !!! this is a really ugly hack:
                                   * we look into the program to find
                                   * the evaluation; this will only work
                                   * because we know that the coercion
                                   * code will be inserted immediately
                                   * before the indexed..PutCode
                                   * instruction, so 'inspos' points to
                                   * such in instruction *)
                                  maybe_ipCode[]->ipCode[];
                                  ('ibetaCommonlibbody.bet/1841'
                                  ,ipCode.where[]
                                  ,ipCode.l2eval[]
                                  ,ipCode.evalWhere[])
                                    ->(&checkIndexedPatternQualificationCode[])
                                  .init
                                    ->addCode
                               else
                                  'Unexpected byte code for rep.assign'
                                    ->internalError
                              if)
                           else
                              (* does not end in select - is ordinary ptn *)
                              ('ibetaCommonlibbody.bet/1854'
                              ,taPQTran.pathTo[])
                                ->(&checkPatternQualificationCode[]).init
                                ->addCode
                          if)
                       else
                          (* path is empty - must be object *)
                          ('ibetaCommonlibbody.bet/1861',taPQTran.pathTo[])
                            ->(&checkPatternQualificationCode[]).init
                            ->addCode
                      if)
                   (*else*)
                      (* statically safe var.ptn. assignment - no action *)
                  if)
               else
                  fail
              if)
           #)
        // evSTran##=staticRepeatedTransient## then
           (# srTran: ^staticRepeatedTransient
           do evSTran[]->srTran[];
              (if srTran.entrySTran##<=staticCharTransient## then
                  (* crep --> string *)
                  ('ibetaCommonlibbody.bet/1770'
                  ,srTran.pathTo[],srTran.l2rdecl[]
                  ,srTran.boundsPathTo[],srTran.lo[],srTran.hi[])
                    ->(&putCRepStringCode[]).init
                    ->addCode
               else
                  fail
              if)
           #)
        else
           fail
       if)
    else
       (* evSTran##=taSTran## *)
       (if true
        // evSTran##=staticRepeatedTransient## then
           (* rep->rep *)
           (# evrepSTran,taRepSTran: ^staticRepeatedTransient;
              trepCode: ^transferRepCode;
              kind: @integer
           do evSTran[]->evrepSTran[];
              taSTran[]->tarepSTran[];
              (* set up the transfer code to
               * do the repeated transfers *)
              (if (evrepSTran.entrySTran[],usageAst[])
                    ->tarepSTran.entrySTran.compatible then
                  (if evrepSTran.byReference=tarepSTran.byReference then
                      ('ibetaCommonlibbody.bet/1631'
                      ,evrepSTran.pathTo[],evrepSTran.l2rdecl[]
                      ,tarepSTran.pathTo[],tarepSTran.l2rdecl[]
                      ,evrepSTran.lo[],evrepSTran.hi[]
                      ,evrepSTran.boundsPathTo[]
                      ,tarepSTran.lo[],tarepSTran.hi[]
                      ,tarepSTran.boundsPathTo[]
                      ,not evrepSTran.byReference
                      ,evrepSTran.entrySTran[]->getkind
                      ,evrepSTran.byReference
                      ,usageAst[])
                        ->(&transferRepHomCode[]).init
                        ->trepCode[]
                        ->addCode
                   else
                      (* byRef to non-byRef *)
                      'ibetaCommonlibbody.bet/1647'->notyet; (* !!! *)
                  if)
               else
                  (* coercion needed *)
                  'ibetaCommonlibbody.bet/1651'->notyet;(* !!! *)
              if)
           #)
        // evSTran##=staticORefTransient##
        // evSTran##=staticOQuaTransient##
        // evSTran##=staticPRefTransient##
        // evSTran##=staticPQuaTransient## then
           (* two same-pattern transients of these kinds would always
            * be a bug: the producer should not be ..Qua.. and the
            * consumer should not be ..Ref.. *)
           fail
        (* else *)
           (* same kind of transient, and not Rep or Ref/Qua: OK *)
       if)
   if)

-- CompareCoerceLib:attributes --

fail:
  (# msg: ^text
  do
     'Cannot coerce '->msg[];
     (evSTran.typename).withIndefArticle->msg.puttext;
     ' into something that matches '->msg.puttext;
     (taSTran.typename).withIndefArticle->msg.puttext;
     (msg[]
     ,'Rewrite the comparison, perhaps using an auxiliary variable'
     ,usageAst[])->staticError
  #)

-- CompareCoerce:dopart --
do
   (if evSTran##<>taSTran## then
       (if true
        // evSTran##=staticCharTransient## then
           (if true
            // taSTran##=staticIntegerTransient## then
               'ibetaCommonlibbody.bet/1855'
                 ->(&coerceCharIntegerCode[]).init
                 ->addCode
            // taSTran##=staticStringTransient## then
               'ibetaCommonlibbody.bet/1859'
                 ->(&coerceCharStringCode[]).init
                 ->addCode
            else
               fail
           if)
        // evSTran##=staticIntegerTransient## then
           (if true
            // taSTran##=staticCharTransient## then
               'ibetaCommonlibbody.bet/1868'
                 ->(&coerceIntegerCharCode[]).init
                 ->addCode
            // taSTran##=staticRealTransient## then
               'ibetaCommonlibbody.bet/1872'
                 ->(&coerceIntegerRealCode[]).init
                 ->addCode
            else
               fail
           if)
        // evSTran##=staticRealTransient## then
           (if taSTran##=staticIntegerTransient## then
               'ibetaCommonlibbody.bet/1880'
                 ->(&coerceRealIntegerCode[]).init
                 ->addCode
            else
               fail
           if)
        // evSTran##=staticStringTransient## then
           (# toCRep:
                (# srTran: ^staticRepeatedTransient
                enter srtran[]
                do (if srTran.entrySTran##<=staticCharTransient## then
                       ('ibetaCommonlibbody.bet/1891'
                       ,srTran.pathTo[],srTran.l2rdecl[]
                       ,srTran.boundsPathTo[],srTran.lo[],srTran.hi[])
                         ->(&getStringCRepCode[]).init
                         ->addCode
                    else
                       fail
                   if)
                #);
              ssTran: ^staticStringTransient
           do evSTran[]->ssTran[];
              (if ssTran.singleton then
                  (if true
                   // taSTran##=staticCharTransient## then
                      'ibetaCommonlibbody.bet/1905'
                        ->(&coerceString1CharCode[]).init
                        ->addCode
                   // taSTran##=staticIntegerTransient## then
                      'ibetaCommonlibbody.bet/1909'
                        ->(&coerceString1IntegerCode[]).init
                        ->addCode
                   // taSTran##<=staticRepeatedTransient## then
                      (* str1 --> crep *)
                      taSTran[]->toCRep
                   else
                      fail
                  if)
               else
                  (if taSTran##<=staticRepeatedTransient## then
                      taSTran[]->toCRep
                   else
                      (* source is a string, not known to be a singleton,
                       * so we cannot coerce it *)
                      fail
                  if)
              if)
           #)
        // evSTran##=staticNoneTransient## then
           (if true
            // taSTran##=staticORefTransient## then
               'ibetaCommonlibbody.bet/1931'
                 ->(&noneObjectCode[]).init
                 ->addCode
            // taSTran##=staticPRefTransient## then
               'ibetaCommonlibbody.bet/1935'
                 ->(&nonePatternCode[]).init
                 ->addCode
            else
               fail
           if)
        // evSTran##=staticRepeatedTransient## then
           (# srTran: ^staticRepeatedTransient
           do evSTran[]->srTran[];
              (if srTran.entrySTran##<=staticCharTransient## then
                  (* crep --> string *)
                  ('ibetaCommonlibbody.bet/1979'
                  ,srTran.pathTo[],srTran.l2rdecl[]
                  ,srTran.boundsPathTo[],srTran.lo[],srTran.hi[])
                    ->(&putCRepStringCode[]).init
                    ->addCode
               else
                  fail
              if)
           #)
        else
           fail
       if)
    else
       (* evSTran##=taSTran## *)
       (if true
        // evSTran##=staticORefTransient## then
           (* oref // oref; consider some kind of qua-check, otherwise OK *)
        // evSTran##=staticPRefTransient## then
           (* pref // pref; consider some kind of qua-check, otherwise OK *)
        // evSTran##=staticRepeatedTransient## then
           (* rep // rep; not yet supported *)
           'ibetaCommonlibbody.bet/1967'->notyet; (* !!! *)
        // evSTran##=staticOQuaTransient## then
           (* an oqua should never occur as a producer of a value *)
           'Encountered a staticOQuaTransient in compareCoerce'
             ->internalError
        // evSTran##=staticPQuaTransient## then
           (* a pqua should never occur as a producer of a value *)
           'Encountered a staticPQuaTransient in compareCoerce'
             ->internalError
        (* else *)
           (* same kind of transient, and not Rep or Ref/Qua: OK *)
       if)
   if)

-- EvaluationExitExecuteInternal:dopart --
do
   (* NBNB: if changing this then also change 'exitExecute' *)
   (if not compiled then exitCompile; true->compiled if);
   (*test-obs (NONE,'eval.exitexei','y')->observeSemAtt; *)
   (thrd[],unwind##,dContext[],program[])
     ->thrd.private.bvm.execute

-- EvaluationPrintExitCode:dopart --
do
   (if not compiled then exitCompile; true->compiled if);
   program.scan(# do (dest[],indentation,true)->current.printCode #);
   '\nRESETFRAME'->output

(*************************************************************
 *                                                           *
 *                       Static Types                        *
 *                                                           *
 *************************************************************)

-- PatternSliceObserve:dopart --
do
   (private.observeStream[],indentation,false)->print

(*************************************************************
 *                                                           *
 *                      l1PatternEntity                      *
 *                                                           *
 *************************************************************)

-- PatternEntityAddSlice:dopart --
do
   pSlice[]->private.slices.prepend

-- PatternEntityCopy:dopart --
do
   (&l1PatternEntity[]).init->theCopy[];
   private.slices.deliverCopy->theCopy.private.slices.assign;
   INNER

-- PatternEntityLib:attributes --

pSlicePair:
  (# s1,s2: ^patternSlice;
     init: (# enter (s1[],s2[]) exit this(pSlicePair)[] #)
  #);

pSlicePairList: list
  (# element::pSlicePair;
     observe: observeBase
       (#
       do ('1st',category)->observeString;
          scan(# do (headline[],category)->current.s1.observe #);
          ('2nd',category)->observeString;
          scan(# do (headline[],category)->current.s2.observe #)
       #)
  #)

-- PatternEntityMerge:dopart --
do
   (* Merge 'other' into this pattern entity.
    *
    * This is the basic operation which defines the notion
    * of correctness for the static merge operation; the
    * implementation here and there must be "equivalent",
    * so please check this when changing any of the two.
    *)
   (*test-trace  ('(pattern  merge','m')->trace; *)
   (*test-trace  ('           with','m')->other.trace; *)
   (*test-trace  'm'->traceIndent; *)
   (if (other[]=this(l1PatternEntity)[]) or
       (other.private.slices.empty) then
       (* merging with myself, or 'other'
        * is 'object', no action needed *)
    else
       (if private.slices.empty then
           (* I am 'object', just take over 'other' *)
           other.private.slices.deliverCopy->private.slices.assign
        else
           (* Both patterns are non-empty *)
           (# intail: @booleanValue
                (# me,other,other_pos: ^patternSlice
                enter (me[],other[])
                do other.succ[]->other_pos[];
                   L: (if other_pos[]<>NONE then
                          (if me[]->other_pos.equal then
                              true->value
                           else
                              other_pos.succ[]->other_pos[];
                              restart L
                          if)
                       else
                          (* 'other' exhausted *)
                          false->value
                      if)
                #);
              my_pos,my_last,other_pos,tmp_pos: ^patternSlice
           do
              (* initialize *)
              private.slices.deliver->(my_pos[],my_last[]);
              other.private.slices.firstlink[]->other_pos[];

              L: (if true
                  // (my_pos[]<>NONE) and (other_pos[]<>NONE) then
                     (if not ((other_pos[],my_pos[])->intail) then
                         (* 'other_pos' unshared, take it *)
                         (if my_pos[]->other_pos.equal then
                             (* same in both lists; skip in me, too *)
                             my_pos.succ[]->my_pos[]
                         if);
                         other_pos.copyLink->tmp_pos[];
                         tmp_pos[]->private.slices.append;
                         other_pos.succ[]->other_pos[];
                         restart L
                      else
                         (* 'other_pos' shared *)
                         (if not ((my_pos[],other_pos[])->intail) then
                             (* 'my_pos' unshared, take it *)
                             my_pos.succ[]->tmp_pos[];
                             my_pos[]->private.slices.append;
                             tmp_pos[]->my_pos[];
                             restart L
                          else
                             (* both shared, inconsistency *)
                             ('Merging incompatible patterns'
                             ,thrd[],unwind##)->patternMergeError
                         if)
                     if)
                  // (my_pos[]<>NONE) and (other_pos[]=NONE) then
                     (* just transfer the rest of 'me' *)
                     (my_pos[],my_last[])->private.slices.appendList
                  // (my_pos[]=NONE) and (other_pos[]<>NONE) then
                     (* just transfer a copy of the rest of 'other' *)
                     other.private.slices.lastLink.succ[]
                       ->other_pos.copyForwardTo
                       ->private.slices.appendList
                  (* else: *)
                     (* (my_pos[]=NONE) and (other_pos[]=NONE), done *)
                 if)
           #)
       if)
   if);
   (*test-trace  'm'->traceOutdent; *)
   (*test-trace  ('pattern  merge)','m')->trace; *)

-- PatternEntityEnsureComponent:dopart --
do
   (# isComponent: @boolean
   do false->isComponent;
      L: private.slices.scan
        (#
        do (if current##<=componentPatternSlice## then
               true->isComponent; leave L
           if)
        #);
      (if not isComponent then
          (* no component slices here; add one as the most general slice *)
          &componentPatternSlice[]->private.slices.append
      if)
   #)

(*************************************************************
 *                                                           *
 *                       l1ObjectEntity                      *
 *                                                           *
 *************************************************************)

-- ObjectEntityTrace:dopart --
do
   (this(interpreterBase).private.traceStream[],indentation,false,NONE)
     ->print

-- ObjectEntityExploit:dopart --
do
   (*test-trace  ('(exploiting obj','X')->trace; *)
   (*test-trace  'X'->traceIndent; *)
   (*test-trace  ('exploited other','X')->other.trace; *)
   (if private.slices.empty then
       (* no slices here; just steal 'other's slices *)
       (# l1pat: ^l1PatternEntity
       do other.private.slices.deliver->private.slices.assign;
          private.pattern[]->l1pat[];
          other.private.pattern[]->private.pattern[];
          l1pat[]->other.private.pattern[];
          private.slices.scan(# do this(l1ObjectEntity)[]->current.oid[] #)
       #)
    else
       (* we do have slices *)
       (# my_pos: ^objectSlice;
          first,last: ^objectSlice;
          l1pat: ^l1PatternEntity
       do
          (* let _other_ exploit _our_ slices .. *)
          private.slices.first->my_pos[];
          L: other.private.slices.scan
            (#
            do (if my_pos[]<>NONE then
                   (if my_pos.getSyntax=current.getSyntax then
                       (thrd[],unwind##,my_pos[])->current.exploit;
                       my_pos.succ[]->my_pos[]
                    (* else: *)
                       (* a slice in other that we do not have: OK, skip *)
                   if)
                else
                   (* my slices exhausted, no more to do *)
                   leave L
               if)
            #);

          (* .. and then steal all the improved slices from 'other'! *)
          other.private.slices.deliver->(first[],last[]);
          private.slices.deliver->other.private.slices.assign;
          (first[],last[])->private.slices.assign;

          (* .. and the type, too *)
          private.pattern[]->l1pat[];
          other.private.pattern[]->private.pattern[];
          l1pat[]->other.private.pattern[];

          (* .. and finally change the identity of all slices *)
          other.private.slices.scan(# do other[]->current.oid[] #);
          private.slices.scan(# do this(l1ObjectEntity)[]->current.oid[] #)
       #)
   if);
   (*test-trace  'X'->traceOutdent; *)
   (*test-trace  ('exploiting obj)','X')->trace; *)

(*
 * local variables:
 * ee-beta-main-file: "~/gbeta-0.9/src/main/gbeta.bet"
 * end:
 *)
