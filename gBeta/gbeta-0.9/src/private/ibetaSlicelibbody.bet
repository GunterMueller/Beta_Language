(* FILE "./private/ibetaSlicelibbody.bet"
 *
 * Copyright (C) 1997-2001 Erik Ernst
 *
 * This file is part of "gbeta" -- a generalized version of the
 * programming language BETA.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is destributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * Among other things, the copyright notice and this notice must be
 * preserved on all copies.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program, probably in a file named COPYING; if not,
 * write to the Free Software Foundation, Inc., 675 Mass Ave,
 * Cambridge, MA 02139, USA.
 *
 * To contact the author by email: eernst@cs.auc.dk
 *
 * To contact the author by snail-mail:
 *    Erik Ernst
 *    Department of Computer Science
 *    University of Aalborg
 *    DK-9220 Aalborg OE
 *    Denmark
 *
 * $Id: ibetaSlicelibbody.bet,v 1.114 2001/07/01 21:44:11 eernst Exp $
 *)

ORIGIN 'ibetaSlicelib';
INCLUDE 'basicinterplib';
INCLUDE 'ibetaCommonlib'

-- StaticSliceListPrint:dopart --
do
   before;
   scanReverse
   (#
   do current[]->beforeEach;
      (dest[],indentation,element_nl)->current.print;
      current[]->afterEach
   #);
   after

-- StaticSliceListPrintShort:dopart --
do
   before;
   scanReverse
   (#
   do current[]->beforeEach;
      (dest[],indentation,element_nl)->current.printShort;
      current[]->afterEach
   #);
   after

-- StaticSliceListObserve:dopart --
do
   (private.observeStream[],indentation,false,true)->print

-- StaticPatternTypeInsert:dopart --
do
   new[]->slices.prepend;
   check
   (# err:
        (# msg: ^text
        enter msg[]
        do ('\nBad type: ',0)->observe;
           msg[]->internalError;
           (msg[]
           ,'Reorganize the inheritance hierarchy or move some declarations'
           ,NONE)->staticError
        #);
      duplicateError::(# do 'Pattern contains duplicate slice'->err #);
      virtualError::(# do 'Pattern has ill-formed virtual chain'->err #)
   #)

-- StaticPatternTypeMixin:dopart --
do
   (# cSlice: ^compositeStaticSlice
   do
      (* add the new main part *)
      (context.getInitialSyntax,l2mpar[])
        ->(&compositeStaticSlice[]).init
        ->cSlice[];

      (* tell how to find its origin *)
      (cSlice.originPath[],l2mpar.scope.location)->context.assignPathToAst;

      (* add the new main part *)
      cSlice[]->insert
   #)

-- MainPartLib:attributes --

isPropagationSafe: booleanValue
  (* see isPropagationSafe for static pattern types below *)
  (#
  do (if private.propSafeDone then
         private.propSafe->value
      else
         (* check vdecls for unsafe contributions; value
          * is true until an unsafe decl is detected *)
         true->value;
         L: Attributes.scan
           (# where::(# do (current##<=l2VDecl##)->value #);
              l2vdcl: ^l2VDecl;
              l2ospec: ^l2ObjectSpecification;
              l2odesc: ^l2ObjectDescriptor;
              l2napl: ^l2NameApl
           do current[]->l2vdcl[];
              (if l2vdcl.ObjectSpecifications.size
               // 1 then
                  (* the right hand side has exactly one element *)
                  (l2vdcl.ObjectSpecifications.head).elm[]->l2ospec[];
                  (if true
                   // l2ospec##<=l2ObjectDescriptor## then
                      l2ospec[]->l2odesc[];
                      (if l2odesc.Prefix.empty then
                          (* this is just a main part on its own; check it *)
                          l2odesc.MainPart.isPropagationSafe->value
                       else
                          (* an object descriptor with a non-trivial
                           * super pattern; will generally not be
                           * single-mixin, so we must give up here *)
                          false->value; leave L
                      if)
                   // l2ospec##<=l2AttributeDenotation## then
                      (* the predefined patterns are all propagation
                       * safe; they are also name apls *)
                      (if l2ospec##<=l2NameApl## then
                          l2ospec[]->l2napl[];
                          (if (l2napl.decl.decl.location).scope[]
                              =predefinedSyntax.predefinedNames[] then
                              true->value; leave L
                           else
                              (* a nameapl which is not predef could
                               * be anything, so we must give up here *)
                              false->value; leave L
                          if)
                      if)
                   else
                      'Unexpected kind of o.spec.'
                        ->internalError
                  if)

               // 0 then true->value; leave L (* missing SLOT, is "object" *)
               else
                  (* non-trivial merge - give up *)
                  false->value; leave L 
              if)
           #);

         value->private.propSafe;
         true->private.propSafeDone
     if)
  #)

-- PatternStaticSliceLib:attributes --

isPropagationSafe: booleanValue
  (# cssli: ^compositeStaticSlice
  do (if true
      // this(patternStaticSlice)##<=basicStaticSlice## then
         (* boolean/char/integer/.. are all propagation safe *)
         true->value
      // this(patternStaticSlice)##<=compositeStaticSlice## then
         (* a userdefined mixin; check its main part *)
         this(patternStaticSlice)[]->cssli[];
         cssli.l2mpar.isPropagationSafe->value
      else
         'Unexpected kind of static slice (isPropagationSafe)'
           ->internalError
     if)
  #)

-- StaticPatternTypeLib:attributes --

isPropagationSafe: booleanValue
  (* Determine whether this static pattern is (1) "object", or (2a)
   * it is a single-mixin pattern, and (2b) it contains no vdecls
   * except possibly some vdecls with single-propagating right
   * hand sides; if this is the case then there is no danger of
   * direct or propagated merging operations failing, because
   * every merge operation with an arbitrary pattern will have
   * at least one operand which is a list of length 0 or 1;
   *
   * !!! Note that merging may actually still fail, in the sense
   * that the merging operation itself is successful, but the
   * resulting pattern contains two mixins with the same main
   * part; if we change the language to accept such patterns
   * then this will be safe; only problem with that is that
   * up-steps would then become even more expensive than they
   * are now...
   *)
  (#
  do (if not staticallyKnown then
         (* we can never promise anything about the propagation
          * with a pattern where an arbitrary set af mixins may
          * be statically unknown *)
         false->value
      else
         (* this is a statically known pattern *)
         (if true
          // slices.empty then
             (* "object" is propagation safe *)
             true->value
          // slices.size=1 then
             (* this is a single-mixin pattern; check nested virtuals *)
             (slices.first).isPropagationSafe->value
         if)
     if)
  #);

isRigid: booleanValue
  (* If a pattern is such that every mixin in it is associated with a
   * main part and each of these main parts have a statically known
   * type that includes all of the more general mixins (i.e., the
   * entire "superlist"), then the ordering of these mixins is completely
   * determined.  This means that an arbitrary pattern containing
   * any of these mixins must contain them in the same order, and that
   * implies that a merge operation with this pattern will succeed.
   * Note that a traditional Beta-style pattern (single inheritance
   * and compile-time constant superpatterns everywhere) will always
   * satisfy this criterion, and hence it is likely to be a very
   * important special case.  We use the term "rigid" to denote such
   * a pattern, because its mixins can only exist in the given order
   * (and the only possible subsets are prefixes of the list, i.e.,
   * we may delete elements but only from the most-specific end).
   *
   * !!! Note: as long as we prohibit all patterns containing two or
   * more mixins having the same main part, merging may still fail
   * as explained above in the comment on "isPropagationSafe".
   * 
   * !!!! Note: it seems to be safe to allow a non-mainpart-defined
   * mixin, e.g., integer, as the topmost mixin; consider this and
   * allow it if it is indeed safe.
   *)
  (# thisSize: @integer;
     sptype: ^staticPatternType
  do (if not staticallyKnown then
         (* cannot guarantee that a pattern which is
          * not a compile-time constant is rigid *)
         false->value
      else
         (* this is a statically known pattern; see how rigid it is *)
         slices.size->thisSize;
         (* success unless something prevents it: value starts as true *)
         true->value;
         L: slices.scan
           (# cssli: ^compositeStaticSlice
           do (if current##<=compositeStaticSlice## then
                  (* a main part defined mixin: check it *)
                  current[]->cssli[];
                  cssli.l2mpar.localStaticType->sptype[];
                  (if sptype.slices.size=thisSize then
                      (* the type of this main part with its
                       * accompanying superpattern always has
                       * at least 'thisSize' mixins; since
                       * the mixins in sptype are an example of
                       * a possible pattern, it leads to a
                       * contradiction to assume that any of
                       * these mixins can be left out - in
                       * other words, l2mpar _does_ depend
                       * specifically on all of the remaining
                       * mixins in this static pattern type;
                       * now update 'thisSize' to count the
                       * remaining mixins at the next step *)
                      thisSize-1->thisSize
                   else
                      (* since sptype describes a pattern that could
                       * exist and it does not include all of the
                       * remaining mixins in this static pattern type,
                       * we cannot rule out the possibility of the
                       * existence of a pattern with some mixins in
                       * common with this one and having them in a
                       * different order; so this pattern is not rigid
                       *)
                      false->value; leave L
                  if)
               else
                  (* not a main part defined mixin: give up *)
                  false->value; leave L
              if)
           #)
     if)
  #)

-- StaticPatternTypeMerge:dopart --
do
   (* Merge 'other' into this staticPatternType.
    *
    * The notion of correctness for this merge operation is
    * based upon the corresponding dynamic merge (defined
    * on l1PatternEntity); the implementation here and there
    * must be "equivalent", so please check this when changing
    * any of the two.
    *)
   (*test-trace  ('(pattern  merge','m')->trace; *)
   (*test-trace  ('           with','m')->other.trace; *)
   (*test-trace  'm'->traceIndent; *)
   (if (not staticallyKnown) or (not other.staticallyKnown) then
       (* at least one operand is not a compile-time constant; watch out! *)
       (if true
        // (this(staticPatternType)[]->other.lessEqual) or (other[]->lessEqual)
           then
           (* result is equal to one of the operands - always safe *)
        // isPropagationSafe or other.isPropagationSafe
        // isRigid or other.isRigid then
           (* OK, this merge will succeed
            * !!!!! remember snag about same mainpart, though
            *)
           (*   (usageAst[],this(staticPatternType)[],other[])
            *     ->dynMergeDupMainPartWarning
            *)
        else
           (* this is "the rest of the cases" and they are (yet)
            * considered beyond static safety guarantees *)
           (usageAst[],this(staticPatternType)[],other[])->dynMergeWarning
       if)
   if);
   (if (other[]=this(staticPatternType)[]) or (other.slices.empty) then
       (* merging with myself, or 'other'
        * is 'object', no action needed *)
    else
       (if slices.empty then
           (* I am 'object', just take over 'other' *)
           other.slices.deliverCopy->slices.assign
        else
           (* Both types are non-empty *)
           (# intail: @booleanValue
                (# me,other,other_pos: ^patternStaticSlice
                enter (me[],other[])
                do other.succ[]->other_pos[];
                   L: (if other_pos[]<>NONE then
                          (if me[]->other_pos.equal then
                              true->value
                           else
                              other_pos.succ[]->other_pos[];
                              restart L
                          if)
                       else
                          (* 'other' exhausted *)
                          false->value
                      if)
                #);
              my_first,my_pos,my_last,other_pos,tmp_pos: ^patternStaticSlice
           do
              (* initialize *)
              slices.deliver->(my_first[]->my_pos[],my_last[]);
              other.slices.firstlink[]->other_pos[];

              L: (if true
                  // (my_pos[]<>NONE) and (other_pos[]<>NONE) then
                     (if not ((other_pos[],my_pos[])->intail) then
                         (* 'other_pos' unshared, take it *)
                         (if my_pos[]->other_pos.equal then
                             (* same in both lists; skip in me, too *)
                             my_pos.succ[]->my_pos[];
                         if);
                         other_pos.copyLink->tmp_pos[];
                         tmp_pos[]->slices.append;
                         other_pos.succ[]->other_pos[];
                         restart L
                      else
                         (* 'other_pos' shared *)
                         (if not ((my_pos[],other_pos[])->intail) then
                             (* 'my_pos' unshared, take it *)
                             my_pos.succ[]->tmp_pos[];
                             my_pos[]->slices.append;
                             tmp_pos[]->my_pos[];
                             restart L
                          else
                             (* both shared, inconsistency *)
                             (# msg: ^text
                             do 'Merging incompatible patterns'->msg[];
                                (* ' -\n ptn1: '->msg.puttext;
                                (msg[],7,false)->print;
                                '\n ptn2: '->msg.puttext;
                                (msg[],7,false)->other.print;
                                '\n'->msg.puttext; *)
                                (msg[],'Don\'t merge these patterns'
                                ,l2dclast[])->staticError
                             #)
                         if)
                     if)
                  // (my_pos[]<>NONE) and (other_pos[]=NONE) then
                     (* just transfer the rest of 'me' *)
                     (my_pos[],my_last[])->slices.appendList
                  // (my_pos[]=NONE) and (other_pos[]<>NONE) then
                     (* just transfer a copy of the rest of 'other' *)
                     other.slices.lastLink.succ[]
                       ->other_pos.copyForwardTo
                       ->slices.appendList
                  (* else: *)
                     (* (my_pos[]=NONE) and (other_pos[]=NONE), done *)
                 if)
           #)
       if)
   if);

   (* if other were known-by-upper-bound, the merge must be so, too *)
   (if not other.staticallyKnown then makeNotKnownStatically if);

   (if other.rinfo[]<>NONE then
       (* take over and adjust that rinfo *)
       (# othersVinfo: ^relativeType
       do other.rinfo.copy->othersVinfo[];
          othersVinfo.scan(# do true->current.maybeless #);
          (if rinfo[]<>NONE then
              othersVinfo[]->rinfo.prepend
           else
              othersVinfo[]->rinfo[]
          if)
       #)
   if);
   
   (*test-trace  'm'->traceOutdent; *)
   (*test-trace  ('pattern  merge)','m')->trace; *)

   (* !! could be cheaper: check only after entire merge at call sites *)
   check
   (# err:
        (# msg: ^text
        enter msg[]
        do ('\nBad type: ',0)->observe;
           msg[]->internalError;
           (msg[]
           ,'Reorganize the inheritance hierarchy or move some declarations'
           ,NONE)->staticError
        #);
      duplicateError::(# do 'Pattern contains duplicate slice'->err #);
      virtualError::(# do 'Pattern has ill-formed virtual chain'->err #)
   #)

-- StaticPatternTypeMergeMustSucceed:dopart --
do
   (if stype##<=staticPatternType## then
       (stype[],l2dclast[],usageAst[])->merge
    else
       (# msg: ^text
       (* !! what syntax _created_ the problem? 'usageAst'? *)
       do 'Type merge failed: '->msg[];
          (stype.typename).withIndefArticle->msg.puttext;
          ' occurred'->msg.puttext;
          (msg[]
          ,'Merge only patterns'
          ,l2dclast[])->staticError
       #)
   if)

-- StaticPatternTypeRawLessEqual:dopart --
do
   L: (if otherSPType.slices.empty then
          (* other type is object##; me, too? *)
          slices.empty->value
       else
          (* other type < object##; check for sublistness *)
          otherSPType.slices.first->otherSlice[];
          slices.scan
          (#
          do M: (if otherSlice[]<>NONE then
                    (if current[]->otherSlice.equal then
                        (* equal at this slice, continue testing *)
                        otherSlice.next->otherSlice[]
                     else
                        (* not same, skip slice in 'other', retry *)
                        otherSlice.next->otherSlice[];
                        restart M
                    if)
                 else
                    (* 'other' exhausted, cannot be contain me *)
                    false->value;
                    leave L
                if);
          #);
          (* survived, register the success *)
          true->value
      if)

-- StaticPatternTypeCheck:dopart --
do
   (* Check that the static type is internally consistent,
    * i.e. that that no slice is repeated, and that all nested
    * virtual chains are well-formed (but as yet, _every_
    * virtual chain is correct, so this check is a no-op) *)

   (* duplicate slices *)
   L: slices.scan
     (# cur: ^staticSlice
     do current[]->cur[];
        (if cur.succ[]<>NONE then
            cur.succ.scanForward
            (#
            do
               (if cur[]->current.equal then
                   duplicateError;
                   leave L
               if)
            #)
        if)
     #)

-- StaticPatternTypeBadKind:dopart --
do
   (# t: ^text
   do 'staticPatternType(weird kindValue: '->t[];
      kindValue->t.putint;
      ')'->t.puttext;
      t[]->internalError
   #)

-- StaticPatternTypeGetTranOut:dopart --
do
   (* Let this if-imp enclose the middle part if the implicit []
    * support should be enabled (part 1):
    *
    * (if isDave then
    *     this(staticPatternType)[]
    *       ->(&staticORefTransient[]).init
    *       ->stran[]
    *  else
    *)

   (# sstran: ^staticSublistTransient
   do (&staticSublistTransient[]).init->sstran[];
      slices.scanReverse
      (#
      do (context[],world[],usageAst[])
           ->current.getStaticTransientOut
           ->sstran.add
      #);
      sstran.normalize->stran[]
   #)

   (* Let this if-imp enclose the middle part if the implicit []
    * support should be enabled (part 2):
    *
    * if);
    *)

   (*test-obs  ('exit-type of','T')->observe; *)
   (*test-obs  ('','T')->stran.observe; *)

-- StaticPatternTypeGetTranIn:dopart --
do
   (* Let this if-imp enclose the middle part if the implicit []
    * support should be enabled (part 1):
    *
    * (if isDave then
    *     this(staticPatternType)[]
    *       ->(&staticORefTransient[]).init
    *       ->stran[]
    *  else
    *)

   (# sstran: ^staticSublistTransient
   do (&staticSublistTransient[]).init->sstran[];
      slices.scanReverse
      (#
      do (context[],world[],usageAst[])
           ->current.getStaticTransientIn
           ->sstran.add
      #);
      sstran.normalize->stran[]
   #)

   (* Let this if-imp enclose the middle part if the implicit []
    * support should be enabled (part 2):
    *
    * if);
    *)

   (*test-obs  ('enter-type of','T')->observe; *)
   (*test-obs  ('','T')->stran.observe; *)

-- StaticPatternTypePrefixWithComponent:dopart --
do
   L: (#
      do slices.scan (* search from general end - comp. likely to be there *)
         (# do (if current##<=componentStaticSlice## then leave L if)#);

         (* not found, so we .. *)
         (# csSlice: ^componentStaticSlice;
            l2ast: ^l2AstNode
         do
            (* .. create it *)
            initialSyntax[]
              ->(&componentStaticSlice[]).init
              ->csSlice[];

            (* .. position it *)
            initialSyntax[]->l2ast[];
            L: (if l2ast[]<>predefinedSyntax[] then
                   l2ast.scope.location->l2ast[];
                   (l2ast[], l2ast##<=l2LabelledImp## )
                     ->csSlice.originPath.addStepOut;
                   restart L
               if);

            (* .. and insert it at the most general position: last *)
            csSlice[]->slices.append
         #)
      #)

-- StaticPatternTypeTmpInstantiate:dopart --
do
   (# path: ^runtimePath;
      sptype: ^staticPatternType
   do
      (if kind<>objectTypeKind then
          (objectTypeKind,usageAst[])
            ->coerce
            ->sptype[];
          (* TYPE_COERCION: we are obtaining an object from the entity
           * described by this static pattern type; we have to consider
           * various type kinds of this entity:
           *
           * patternTypeKind: create a new instance of this pattern;
           * the new instance will have a staticallyKnown pattern
           * if and only if this pattern is statically known; same
           * for staticallyKnownBottom
           *
           * patternRefTypeKind: create a new instance of this pattern,
           * which is never staticallyKnown; the new instance will
           * never have a staticallyKnown structure either, so this
           * is already correctly reflected in the attributes
           *
           * objectTypeKind: not possible (if..)
           *
           * objectRefTypeKind: the object described by this static
           * pattern type will have a staticallyKnown structure if
           * and only if it is obtained from a variable object attribute
           * with a staticallyKnown qualification and exact marker; in
           * that case, only, will the staticallyKnown[Bottom] attributes
           * already be correct
           *)
       else
          this(staticPatternType)[]->sptype[]
      if);

      (NONE,NONE,context.getInitialSyntax)
        ->(&runtimePath[]).init
        ->path[];
      (sptype[],generatingAst[],framePos)
        ->(&runtimeTmpStep[]).init
        ->path.append;
      (context[],path[],NONE,usageAst[])
        ->sptype.staticInstantiate
        ->tmpstocp[]
   #)

-- StaticPatternTypeIsDave:dopart --
do
   (* the pattern type is eligible iff every slice in it is *)
   true->value;
   L: slices.scan(# do (if not current.isDave then false->value; leave L if)#)

-- StaticPatternTypeAst2Slice:dopart --
do
   L: (#
      do slices.scan
         (#
         do (if l2ast[]=current.getSyntax then
                (* found *)
                current[]->pSlice[];
                leave L
            if)
         #);
         (* not found *)
         NONE->pSlice[]
      #)

-- StaticPatternTypeMakeNKS:dopart --
do
   false->staticallyKnown->staticallyKnownBottom;
   (* make sure that relative types invalidate the same kind of knowledge *)
   (if rinfo[]<>NONE then rinfo.scan(# do true->current.maybeLess #)if)

-- StaticPatternTypeMakeKS:dopart --
do
   true->staticallyKnown->staticallyKnownBottom

-- StaticPatternTypeGbcPrint:dopart --
do
   '\n'->output;
   (if kind
    // patternTypeKind then 'Pattern'->output
    // objectTypeKind then 'Object'->output
    else 'unexpected declared entity in gbcPrint'->internalError
   if);
   '('->output;
   INNER;
   slices.scanReverse
   (# do (dest[],indentation+indent_delta,true)->current.printCode #);
   '\n)'->output

-- StaticPatternTypeGbcMark:dopart --
do
   '"'->value[];
   (value[],0,false)->l2ndcl.printCode;
   '" in "`'->value.puttext;
   (l2ndcl.scope.location).mpsPosition->value.puttext;
   '"'->value.puttext

-- StaticPatternTypeGbcPrintDecl:dopart --
do
   l2ndcl[]->gbcMark->output

-- StaticPatternTypeGbcPrintInsertedItem:dopart --
do
   l2oden.mpsPosition->output;
   '"'->output
   
-- StaticPatternTypeCreatePattern:dopart --
do
   (&l1PatternEntity[]).init->l1pat[];
   slices.scan
   (# do (thrd[],unwind##,dContext[])
        ->current.createPatternSlice
        ->l1pat.private.slices.append
   #)

-- StaticPatternTypeCreateObject:dopart --
do
   (* create the pattern & object *) 
   (* NB: here we initialize l1obj with an empty
    * pattern - we fill in the pattern later *)
   (&l1PatternEntity[]).init
     ->l1pat[]
     ->(&l1ObjectEntity[]).init
     ->l1obj[];
   slices.scan
   (# pSlice: ^patternSlice
   do (thrd[],unwind##,dContext[])
        ->current.createPatternSlice
        ->pSlice[]
        ->l1pat.private.slices.append;
      l1obj[]
        ->pSlice.createObjectSlice
        ->l1obj.private.slices.append
   #);
   (* initialize the object attributes, in a frame *)
   (NONE,thrd[])->newStackableObject->oofo[];
   l1obj.private.slices.scan
   (# do (thrd[],unwind##)->current.fillInAttributes #);
   oofo[]->thrd.private.bvm.restoreFrame

-- StaticPatternTypeDoesNothing:dopart --
do
   (if staticallyKnown then
       (if true
        // slices.empty then
           true->value
        else
           (* approach: it does nothing until the opposite has been proved *)
           true->value;
           L: slices.scan
             (# csSlice: ^compositeStaticSlice
             do (if true
                 // current##<=basicStaticSlice## then 
                    (* OK, a basic pattern slice does nothing - not
                     * even component unless there is another slice
                     * that actually does something, and in that case
                     * that other slice will make value false *)
                 // current##<=compositeStaticSlice## then
                    (* even some composite object slices do nothing *)
                    current[]->csSlice[];
                    (if true
                     // csSlice.l2mpar.DoPartOpt.empty then
                        (* OK: e.g. Point: (# x,y: @integer #) does nothing *)
                     else
                        (* there is a do-part; check it *)
                        csSlice.l2mpar.DoPartOpt.scan
                        (# l2iimp: ^l2InnerImp
                        do (if true 
                            // current##<=l2InnerImp## then
                               (* there is an INNER in here, but that
                                * does nothing if the slices below
                                * this one do nothing - except for
                                * constructs like "INNER 2" where
                                * another object is involved *)
                               current[]->l2iimp[];
                               (* we depend on rtp, so it had better be there *)
                               l2iimp.localCheck;
                               (if not l2iimp.rtp.empty then
                                   (* "INNER x" for some non-trivial x *)
                                   false->value;
                                   leave L
                                   (*else*)
                                   (* simple "INNER" - still OK, continue *)
                               if)
                            else
                               (* any other imperative than INNER is assumed to
                                * "do something";
                                * !!! We could actually propagate here,
                                * because this might be a call to something
                                * _else_ that does nothing *)
                               false->value;
                               leave L
                           if)
                        #)
                    if)
                 else
                    'Unexpected kind of pattern slice in doesNothing'
                      ->internalError
                if)
             #)
       if)
    else
       (* not statically known - may always have some non-trivial do-part *)
       false->value
   if)

-- StaticPatternTypeIsComponent:dopart --
do
   false->value;
   L: slices.scan
     (# 
     do (if current##<=componentStaticSlice## then 
            true->value;
            leave L
        if)
     #)

-- StaticPatternTypeIsPredefined:dopart --
do
   (if staticallyKnown then
       (if true
        // slices.empty then true->value
        // slices.size=1 then slices.firstLink##<=basicStaticSlice## -> value
        else false->value
       if)
    else
       (* not staticallyKnown, could have any slices whatsoever *)
       false->value
   if)

-- StaticPatternTypePredefinedCases:dopart --
do
   (if slices.empty then onObject else
       (# pSlice: ^patternStaticSlice
       do slices.first->pSlice[];
          (if true
           // pSlice##<=booleanStaticSlice## then onBoolean
           // pSlice##<=charStaticSlice## then onChar
           // pSlice##<=integerStaticSlice## then onInteger
           // pSlice##<=realStaticSlice## then onReal
           // pSlice##<=stringStaticSlice## then onString
           // pSlice##<=componentStaticSlice## then onComponent
           // pSlice##<=semaphoreStaticSlice## then onSemaphore
           else
              'Unexpected kind of pattern static slice'
                ->internalError
          if)
       #)
   if)

-- StaticPatternTypeGenerateGetPredefinedPattern:dopart --
do
   predefinedCases
   (# onObject::
        (# 
        do 'ibetaSlicelibbody.bet/770'
             ->(&getObjectPatternCode[]).init
             ->program.append
        #);
      onBoolean::
        (# 
        do 'ibetaSlicelibbody.bet/776'
             ->(&getBooleanPatternCode[]).init
             ->program.append
        #);
      onChar::
        (# 
        do 'ibetaSlicelibbody.bet/782'
             ->(&getCharPatternCode[]).init
             ->program.append
        #);
      onInteger::
        (# 
        do 'ibetaSlicelibbody.bet/788'
             ->(&getIntegerPatternCode[]).init
             ->program.append
        #);
      onReal::
        (# 
        do 'ibetaSlicelibbody.bet/794'
             ->(&getRealPatternCode[]).init
             ->program.append
        #);
      onString::
        (# 
        do 'ibetaSlicelibbody.bet/800'
             ->(&getStringPatternCode[]).init
             ->program.append
        #);
      onComponent::
        (# 
        do 'ibetaSlicelibbody.bet/806'
             ->(&getComponentPatternCode[]).init
             ->program.append
        #);
      onSemaphore::
        (# 
        do 'ibetaSlicelibbody.bet/812'
             ->(&getSemaphorePatternCode[]).init
             ->program.append
        #)
   #)

-- StaticPatternTypeGenerateGetPredefinedObject:dopart --
do
   predefinedCases
   (# onObject::
        (# 
        do 'ibetaSlicelibbody.bet/823'
             ->(&getObjectObjectCode[]).init
             ->program.append
        #);
      onBoolean::
        (# 
        do 'ibetaSlicelibbody.bet/829'
             ->(&getBooleanObjectCode[]).init
             ->program.append
        #);
      onChar::
        (# 
        do 'ibetaSlicelibbody.bet/835'
             ->(&getCharObjectCode[]).init
             ->program.append
        #);
      onInteger::
        (# 
        do 'ibetaSlicelibbody.bet/841'
             ->(&getIntegerObjectCode[]).init
             ->program.append
        #);
      onReal::
        (# 
        do 'ibetaSlicelibbody.bet/847'
             ->(&getRealObjectCode[]).init
             ->program.append
        #);
      onString::
        (# 
        do 'ibetaSlicelibbody.bet/853'
             ->(&getStringObjectCode[]).init
             ->program.append
        #);
      onComponent::
        (# 
        do 'ibetaSlicelibbody.bet/859'
             ->(&getComponentObjectCode[]).init
             ->program.append
        #);
      onSemaphore::
        (# 
        do 'ibetaSlicelibbody.bet/865'
             ->(&getSemaphoreObjectCode[]).init
             ->program.append
        #)
   #)

-- StaticPatternTypeGenerateGetPredefinedTmp:dopart --
do
   predefinedCases
   (# onObject::
        (# 
        do ('ibetaSlicelibbody.bet/876',framePos)
             ->(&getObjectTmpCode[]).init
             ->program.append
        #);
      onBoolean::
        (# 
        do ('ibetaSlicelibbody.bet/882',framePos)
             ->(&getBooleanTmpCode[]).init
             ->program.append
        #);
      onChar::
        (# 
        do ('ibetaSlicelibbody.bet/888',framePos)
             ->(&getCharTmpCode[]).init
             ->program.append
        #);
      onInteger::
        (# 
        do ('ibetaSlicelibbody.bet/894',framePos)
             ->(&getIntegerTmpCode[]).init
             ->program.append
        #);
      onReal::
        (# 
        do ('ibetaSlicelibbody.bet/900',framePos)
             ->(&getRealTmpCode[]).init
             ->program.append
        #);
      onString::
        (# 
        do ('ibetaSlicelibbody.bet/906',framePos)
             ->(&getStringTmpCode[]).init
             ->program.append
        #);
      onComponent::
        (# 
        do ('ibetaSlicelibbody.bet/912',framePos)
             ->(&getComponentTmpCode[]).init
             ->program.append
        #);
      onSemaphore::
        (# 
        do ('ibetaSlicelibbody.bet/918',framePos)
             ->(&getSemaphoreTmpCode[]).init
             ->program.append
        #)
   #)

-- StaticPrimitiveEntityTypeTransferBasicState:dopart --
do
   initialSyntax[]->other.initialSyntax[];
   NameDcl[]->other.NameDcl[]

-- StaticOCPPrintShort:dopart --
do
   (dest[],indentation,false)->sptype.printShort

-- StaticOCPSameOriginScan:dopart --
do
   (* visit all slices, select those with known same origin *)
   sptype.slices.scanReverse
   (#
   do (if current.originPath[]->originPath.leadsToSame then
          current[]->this(sameOriginScan).current[];
          INNER SameOriginScan
      if)
   #)
   
-- StaticOCPLib:attributes --

checkDisownCase:
  (* The core of 'StaticOCPCheckFinal'; see the comment for that, too. 
   * When we enter this method, related_rinfo is a relativeType from 
   * this(staticOCP).sptype that describes a related virtual that is 
   * not necessarily identical to this(staticOCP).sptype; this could
   * be a virtual superpattern which might contain the virtual 
   * "V_l2fdcl" that is being final-bound by l2fdcl.  Now we must 
   * check whether this related virtual is open and contains V_l2fdcl.
   * If so, we can only avoid the error in two ways:
   * 
   *   (1) if this(staticOCP).sptype is the same virtual V_l2fdcl
   *   (2) if it is another virtual which has disowned V_l2fdcl
   *)
  (# fail:
       (# msg,solution: ^text
       do 'Attempt to final-bind a virtual which is '->msg[];
          'inherited from an open virtual'->msg.puttext;
          'Don\'t final-bind this virtual, '->solution[];
          'final-bind the virtual super-pattern, '->solution.putline;
          'or use a disown mark ("-")'->solution.puttext;
          (msg[],solution[],l2fdcl[])->staticError
       #);
     world: ^staticContextDB;
     usageAst: ^l2AstNode;
     l2fdcl: ^l2FinalDecl;
     related_rinfo: ^relativeType;
     related_vdecl: ^l2VDecl;
     related_sptype: ^staticPatternType;
     id_vdcl: ^l2VirtualDecl; (* ":<" of 'l2fdcl' *)
     id_target: ^l2AstNode;
     vchain: ^virtualChain
       
  enter (world[],usageAst[],l2fdcl[],related_rinfo[])
     
  do (* check whether that virtual is open and contains
      * the virtual associated with 'l2fdcl' *)
     related_rinfo.decl.decl.location->related_vdecl[];
     l2fdcl.getVirtualDecl->id_vdcl[];
     id_vdcl.scope.location->id_target[];
     (related_rinfo.enclosing[],world[],l2fdcl[])
       ->related_vdecl.theDeclNode.getStaticType
       ->related_sptype[];
     (if not related_sptype.staticallyKnown then
         (* yes, it is open or it inherits 
          * from an open virtual *)
         L: related_sptype.slices.scan
           (#
           do (if id_target[]->current.associated then
                  (* We _are_ trying to final-bind a virtual which has the same
                   * virtual-decl syntax as some virtual pattern in an open,
                   * virtual super-pattern; since it would be an error to 
                   * have two mixins with the same main part, that virtual 
                   * must be the same as the one available via l2fdcl.
                   * Hence, related_sptype contains V_l2fdcl *)
                  
                  (* This is OK if l2fdcl is itself located in that virtual
                   * super-pattern; since there could not be two mixins 
                   * with the same main part, on occurrence of l2fdcl in 
                   * related_sptype must be the same occurrence as the one
                   * in this(staticOCP).sptype (because that is a subpattern
                   * of related_sptype) *)
                  related_sptype.slices.scan
                  (# 
                  do (if l2fdcl.scope.location->current.associated then
                         (* yes! the related virtual is myself *)
                         leave L
                     if)
                  #);
                  (* did not leave - the related virtual is _not_ myself *)
                  
                  (* Last chance: check whether the related 
                   * virtual has disowned V_l2fdcl *)
                  related_sptype[]
                    ->id_vdcl.gatherVirtualChain
                    ->vchain[];
                  vchain.scan
                  (# otherDesc: ^l2ObjectDescriptor;
                     otherVDcl: ^l2VDecl;
                     otherIdDcl: ^l2VirtualDecl
                  do (if current.Disown then
                         (* disowned, see by whom *)
                         (current.scope.location).father[]->otherDesc[];
                         otherDesc.getVDecl->otherVDcl[];
                         (if otherVDcl[]<>NONE then
                             (* in another virtual *)
                             otherVDcl.getVirtualDecl->otherIdDcl[];
                             (if otherIdDcl[]=related_vdecl.getVirtualDecl 
                                 then
                                 (* yes! disowned *)
                                 leave L
                                 (* else: *)
                                 (* another virtual, continue search *)
                             if)
                             (* else: *)
                             (* static error, but that is discovered in
                              * VDeclGetType *)
                         if)
                     if)
                  #);
                  
                  (* not disowned, no way around it now *)
                  fail
              if)
           #)
     if)
  #)

-- StaticOCPCheckFinal:dopart --
do
   (* Roles played: '2fdcl' is a final decl which was found in some
    * syntax whose static substance is this StaticOCP.  So this St.OCP
    * represents the object of which the final bound virtual is an
    * attribute.
    *
    * We want to discover if that final decl. has been violated in this
    * St.OCP, and for that we, firstly, check the known types to discover
    * immediate statically known violations (which happens as part of the
    * computation of the static type of the decl), and, secondly, check
    * whether the virtual (of l2fdcl) is inherited from an open virtual
    * (in which case that open virtual would be unduly restricted for
    * usage in other contexts, except when it has promised to not use
    * the otherwise lost freedom, by means of a 'disown' mark) *)

   (* check for basic "compile-time-explicit" violations *)
   (this(StaticOCP)[],world[],usageAst[])
     ->(l2fdcl.getTheNameDcl).decl.getStaticType;

   (* check that we do not indirectly constrain other virtuals *)
   (if not sptype.staticallyKnown then
       (* we may inherit from an open virtual; in that
        * case we need to ensure that it is "me" *)
       (if sptype.rinfo[]<>NONE then
           sptype.rinfo.scan
           (# 
           do (if current.decl[]<>NONE then
                  (* yes, the relation is to a virtual *)
                  (if current.decl.decl.kind=vdeclDeclKind then
                      (if current.maybeless then
                          (* potential non-trivial specialization relation
                           * to a virtual which may be "non-me"; this is 
                           * the serious case *)
                          (world[],usageAst[],l2fdcl[],current[])
                            ->checkDisownCase
                       (* else: *)
                          (* that virtual is equal to "me": OK *)
                      if)
                   else
                      'Unexpected: Relative type relates to non-virtual'
                        ->internalError
                  if)
               (* else: *)
                  (* relation to object: not interesting here *)
              if)
           #)
        (* else: *)
           (* sptype.rinfo[]=NONE: no related types,
            * in particular no related virtuals *)
       if)
    (* else: *)
       (* sptype is statically known, i.e., it certainly
        * does not inherit from an open virtual *)
   if)

-- StaticOCPCheckFinalObject:dopart --
do
   (* If a final bound on an object is accepted by local
    * analysis (in localcheck), then the specialization
    * criterion is ensured (that the object must have type
    * at least as special as the intro promises).  So here
    * we just need to check that any given virt.obj. is at
    * most final bound once.  That is the case if no virtual
    * object final coexists with another one in the same
    * StaticOCP, so we just need to search for another one
    * with the same 'getVirtualDecl' and staticError if such
    * one exists.
    *
    * !! think about whether there is anything else we should check
    *)
   sptype.slices.scan
   (# otherFsit: ^l2FinalStaticItem;
      csSlice: ^compositeStaticSlice
   do (if current##<=compositeStaticSlice## then
          current[]->csSlice[];
          (if csSlice.l2mpar.private.hasFinalObjs then
              csSlice.l2mpar.scanFinalStaticItems
              (# l2sdcl: ^l2SimpleDecl;
                 l2rspc: ^l2ReferenceSpecification
              do (if current[]<>l2fsit[] then
                     (if current.getVirtualDecl=l2fsit.getVirtualDecl then
                         (* it binds the same virtual object decl *)
                         (# msg: ^text
                         do &text[]->msg[];
                            (msg[],0,false,verboseOutput)
                              ->current.printWithContextBase
                            (# title::(# do 'OTHER'->value[] #)#);
                            'Attempt to final bind a virtual object twice'
                              ->msg.puttext;
                            (msg[],'Remove one of the final bindings'
                            ,l2fsit[])->staticError
                         #)
                     if)
                 if)
              #)
          if)
      if)
   #)

-- StaticOCPCheckFinals:dopart --
do
   sptype.slices.scan
   (# csSlice: ^compositeStaticSlice
   do (if current##<=compositeStaticSlice## then
          current[]->csSlice[];
          (if csSlice.l2mpar.private.hasFinalPtns then
              csSlice.l2mpar.scanSpecializedVDecls
              (#
              do (if current##<=l2FinalDecl## then
                     (world[],usageAst[],current[])->checkFinal
                 if)
              #)
          if);
          (if csSlice.l2mpar.private.hasFinalObjs then
              csSlice.l2mpar.scanFinalStaticItems
              (# do (world[],usageAst[],current[])->checkFinalObject #)
          if)
      if)
   #)

-- StaticOCPCheckVirtuals:dopart --
do
   sptype.slices.scan
   (# csSlice: ^compositeStaticSlice
   do (if current##<=compositeStaticSlice## then
          current[]->csSlice[];
          csSlice.l2mpar.scanSpecializedVDecls
          (# sptype: ^staticPatternType
          do (if current.scope.location->setFocus then
                 (this(staticOCP)[],world[],usageAst[])
                   ->current.theDeclNode.getStaticType
                   ->sptype[]
              else
                 'Could not set focus during CheckVirtuals'
                   ->internalError
             if)
          #)
      if)
   #)

-- StaticOCPGetFinalStaticItem:dopart --
do
   NONE->l2fsit[]; (* "not yet found" *)
   L: sptype.slices.scan
     (# csSlice: ^compositeStaticSlice;
     do (if current##<=compositeStaticSlice## then
            current[]->csSlice[];
            (if csSlice.l2mpar.private.hasFinalObjs then
                csSlice.l2mpar.scanFinalStaticItems
                (#
                do (if current.getVirtualDecl=l2vsit[] then
                       current[]->l2fsit[];
                       (* done *)
                       leave L
                   if)
                #)
            if)
        if)
     #)

-- StaticOCPGenerateGetPattern:dopart --
do
   (if sptype.kind
    // patternTypeKind then
       (if staticPushPatternFlag
           and sptype.knownStatically
           and sptype.hasExistingParts then
           (if staticPredefinedPatternFlag and sptype.isPredefined then
               program[]->sptype.generateGetPredefinedPattern
            else
               ('ibetaSlicelibbody.bet/1100',sptype[])
                 ->(&getStaticPatternCode[]).init
                 ->program.append
           if)
        else
           ('ibetaSlicelibbody.bet/1020',pathTo[],sptype[])
             ->(&getPatternCode[]).init
             ->program.append
       if);
       sptype[]->gensptype[]

    // patternRefTypeKind then
       ('ibetaSlicelibbody.bet/437',pathTo[],sptype[])
         ->(&getPatternRefCode[]).init
         ->program.append;
       (if not noneAllowed then
           'ibetaSlicelibbody.bet/441'
             ->(&checkNonePrefCode[]).init
             ->program.append
       if);
       (patternTypeKind,usageAst[])
         ->sptype.coerce
         ->gensptype[];
       (* TYPE_COERCION: from pattern ref to pattern - only type kind changed *)

    // objectTypeKind then
       (if staticPushPatternFlag
           and sptype.knownStatically
           and sptype.hasExistingParts then
           (if staticPredefinedPatternFlag and sptype.isPredefined then
               program[]->sptype.generateGetPredefinedPattern
            else
               ('ibetaSlicelibbody.bet/1132',sptype[])
                 ->(&getStaticPatternCode[]).init
                 ->program.append
           if)
        else
           ('ibetaSlicelibbody.bet/1137',pathTo[],sptype[])
             ->(&getObjectCode[]).init
             ->program.append;
           'ibetaSlicelibbody.bet/1051'
             ->(&coerceObjectPatternCode[]).init
             ->program.append
       if);
       (patternTypeKind,usageAst[])
         ->sptype.coerce
         ->gensptype[];
       (* TYPE_COERCION: from object to pattern - only type kind changed *)

    // objectRefTypeKind then
       ('ibetaSlicelibbody.bet/1061',pathTo[],sptype[])
         ->(&getObjectRefCode[]).init
         ->program.append;
       'ibetaSlicelibbody.bet/1064'
         ->(&checkNoneOrefCode[]).init
         ->program.append;
       'ibetaSlicelibbody.bet/1067'
         ->(&coerceObjectPatternCode[]).init
         ->program.append;
       (patternTypeKind,usageAst[])
         ->sptype.coerce
         ->gensptype[];
       (* TYPE_COERCION: from objectRef to pattern - only type kind changed *)

    else
       'Unexpected kind of staticOCP'
         ->internalError
   if)

-- StaticOCPGenerateGetObject:dopart --
do
   (if sptype.kind
    // patternTypeKind then
       (if staticCreateObjectFlag
           and sptype.knownStatically
           and sptype.hasExistingParts then 
           (if staticPredefinedPatternFlag and sptype.isPredefined then
               program[]->sptype.generateGetPredefinedObject
            else
               ('ibetaSlicelibbody.bet/1285',sptype[])
                 ->(&createStaticObjectCode[]).init
                 ->program.append
           if)
        else
           ('ibetaSlicelibbody.bet/1089',pathTo[],sptype[])
             ->(&getPatternCode[]).init
             ->program.append;
           'ibetaSlicelibbody.bet/1092'
             ->(&createObjectCode[]).init
             ->program.append
       if);
       (objectTypeKind,usageAst[])
         ->sptype.coerce
         ->gensptype[];
       (* TYPE_COERCION: we are creating an object as an instance of the
        * pattern described by sptype; the pattern of this object will
        * be staticallyKnown if and only if the pattern described by
        * sptype is staticallyKnown *)

    // patternRefTypeKind then
       ('ibetaSlicelibbody.bet/1107',pathTo[],sptype[])
         ->(&getPatternRefCode[]).init
         ->program.append;
       'ibetaSlicelibbody.bet/1110'
         ->(&checkNonePrefCode[]).init
         ->program.append;
       'ibetaSlicelibbody.bet/1113'
         ->(&createObjectCode[]).init
         ->program.append;
       (objectTypeKind,usageAst[])
         ->sptype.coerce
         ->gensptype[];
       (* TYPE_COERCION: we are creating an object as an instance of
        * the variable pattern described by this sptype; it will
        * never be staticallyKnown[Bottom], and that is also correct
        * for the new object *)

    // objectTypeKind then
       ('ibetaSlicelibbody.bet/1125',pathTo[],sptype[])
         ->(&getObjectCode[]).init
         ->program.append;
       sptype[]->gensptype[]

    // objectRefTypeKind then
       ('ibetaSlicelibbody.bet/1131',pathTo[],sptype[])
         ->(&getObjectRefCode[]).init
         ->program.append;
       (if not noneAllowed then
           'ibetaSlicelibbody.bet/1135'
             ->(&checkNoneOrefCode[]).init
             ->program.append
       if);
       (* TYPE_COERCION: no coercion here - we should 
        * not forget that an objref could be NONE; used
        * to coerce into objectTypeKind, but that caused 
        * gbeta to incorrectly leave out a couple of 
        * CHK_NONE instructions. So, we just do this:
        *)
       sptype[]->gensptype[]

    else
       'Unexpected kind of staticOCP'
         ->internalError
   if)

-- StaticOCPGenerateGetTmpObject:dopart --
do
   (if sptype.kind
    // patternTypeKind then
       (if staticCreateObjectFlag
           and sptype.knownStatically
           and sptype.hasExistingParts then 
           (generatingAst[],cInfo.allocateTmp->framePos)
             ->createTmpVersion
             ->genstocp[];
           ('ibetaSlicelibbody.bet/1162',framePos,sptype[])
             ->(&createStaticTmpCode[]).init
             ->program.append
        else
           ('ibetaSlicelibbody.bet/1166',pathTo[],sptype[])
             ->(&getPatternCode[]).init
             ->program.append;
           (generatingAst[],cInfo.allocateTmp->framePos)
             ->createTmpVersion
             ->genstocp[];
           ('ibetaSlicelibbody.bet/1172',framePos)
             ->(&createTmpCode[]).init
             ->program.append
       if)

    // patternRefTypeKind then
       ('ibetaSlicelibbody.bet/1178',pathTo[],sptype[])
         ->(&getPatternRefCode[]).init
         ->program.append;
       'ibetaSlicelibbody.bet/1181'
         ->(&checkNonePrefCode[]).init
         ->program.append;
       (generatingAst[],cInfo.allocateTmp->framePos)
         ->createTmpVersion
         ->genstocp[];
       ('ibetaSlicelibbody.bet/1187',framePos)
         ->(&createTmpCode[]).init
         ->program.append;

    // objectTypeKind then
       (generatingAst[],cInfo.allocateTmp->framePos)
         ->createTmpVersion
         ->genstocp[];
       ('ibetaSlicelibbody.bet/1195',pathTo[],sptype[],framePos)
         ->(&getTmpCode[]).init
         ->program.append

    // objectRefTypeKind then
       (generatingAst[],cInfo.allocateTmp->framePos)
         ->createTmpVersion
         ->genstocp[];
       ('ibetaSlicelibbody.bet/1203',pathTo[],sptype[],framePos)
         ->(&getTmpRefCode[]).init
         ->program.append;
       'ibetaSlicelibbody.bet/1206'
         ->(&checkNoneOrefCode[]).init
         ->program.append;

    else
       'Unexpected kind of staticOCP'
         ->internalError
   if)

-- StaticOCPCreateTmpVersion:dopart --
do
   copy->tmpbased_stocp[];

   (* adjust tmpbased_stocp such that it describes "the same object
    * on the tmp stack (note that it may not be an object) *)
   (if tmpbased_stocp.sptype.kind
    // patternTypeKind then
       (* the tmp based object was created from a
        * pattern described by this staticOCP *)
       (objectTypeKind,generatingAst[])
         ->tmpbased_stocp.sptype.coerce
         ->tmpbased_stocp.sptype[];
       (* TYPE_COERCION: we are creating an object from a
        * pattern, so the new object will have that pattern
        * and hence staticallyKnown[Bottom] is correct;
        * however, we should remember the entry point *)
       (if (tmpbased_stocp.sptype.staticallyKnown
            or tmpbased_stocp.sptype.staticallyKnownBottom)
           and (not tmpbased_stocp.sptype.slices.empty) then
           tmpbased_stocp.sptype.slices.first->tmpbased_stocp.destSlice[]
       if)

    // patternRefTypeKind then
       (* the tmp based object was created from a
        * pattern described by this staticOCP *)
       (objectTypeKind,generatingAst[])
         ->tmpbased_stocp.sptype.coerce
         ->tmpbased_stocp.sptype[];
       (* TYPE_COERCION: we are creating an object as an instance of
        * a given variable pattern; that pattern is never
        * staticallyKnown[Bottom], and neither is the object; so
        * we need not adjust these attributes; a (paranoid) extra
        * thing to do is to ensure that there is no destSlice *)
       NONE->tmpbased_stocp.destSlice[]

    // objectRefTypeKind then
       (* this staticOCP already describes a variable object, so it
        * was just moved unto the tmp stack *)
       (objectTypeKind,generatingAst[])
         ->tmpbased_stocp.sptype.coerce
         ->tmpbased_stocp.sptype[];
       (* TYPE_COERCION: we are just moving a variable object unto
        * the tmp stack; this will not invalidate the properties
        * staticallyKnown[Bottom] *)

    // objectTypeKind then
       (* this staticOCP already describes an object, so it
        * was just moved unto the tmp stack; no coercion needed *)
    else
       'staticOCP with unexpected static type encountered'
         ->internalError
   if);

   (* tmpbased_stocp is found on the tmp stack - describe that *)
   tmpbased_stocp.pathTo.deliver; (* "clear" *)
   (tmpbased_stocp.sptype[],generatingAst[],framePos)
     ->(&runtimeTmpStep[]).init
     ->tmpbased_stocp.pathTo.append

(*************************************************************
 *                                                           *
 *                     Static Transients                     *
 *                                                           *
 *************************************************************)

-- CreateSingletonTransient:dopart --
do
   (&type[]).init->stran[]

-- CreateEmptyTransient:dopart --
do
   (&staticSublistTransient[]).init->sstran[]

-- ArithBinOpStaticCoercionBase:dopart --
do
   (if true
    // left##<=staticSublistTransient## then
       (* composite structure, "right" must also be composite *)
       (if true
        // right##<=staticSublistTransient## then
           (* both have composite structure, check recursively
            * NB: this is the somewhat weird case of things like
            * (1,'a')+(1.5,'b'); _perhaps_ supported later *)
           (# selfType: ##arithBinOpStaticCoercionBase;
              sstran_left,sstran_right: ^staticSublistTransient;
              succeeded: @boolean
           do this(arithBinOpStaticCoercionBase)##->selfType##;
              left[]->sstran_left[];
              right[]->sstran_right[];
              sstran_left.strlist[]->sstran_right.strlist.correlate
              (# foreach::
                   (# do (otherCurrent[],current[],usageAst[])
                        ->&selfType;
                      (* !!! collect the result;
                       * if we get this far, the coercion succeeded
                       * for this link of the list; tell`em *)
                      true->value
                   #)
              #)->succeeded;
              (if succeeded then
                  (* !!! should we compute a composite result? *)
                  'ibetaSlicelibbody.bet/453: '->notyet; (* !!! *)
               else
                  (* structural difference, or list-internal failure *)
                  (left[],right[],usageAst[])->impossibleStaticBinCoercion
              if)
           #)
        else
           (left[],right[],usageAst[])->impossibleStaticBinCoercion
       if)

    // left##<=staticCharTransient## then
       (if true
        // right##<=staticCharTransient##
        // right##<=staticIntegerTransient## then
           (&staticIntegerTransient[]).init->output[]
        // right##<=staticStringTransient## then
           (# sstran: ^staticStringTransient
           do right[]->sstran[];
              (if sstran.singleton then
                  (* right is literal char *)
                  (&staticIntegerTransient[]).init->output[]
               else
                  (* right is non-singleton string, fail *)
                  (left[],right[],usageAst[])->impossibleStaticBinCoercion
              if)
           #)
        else
           (left[],right[],usageAst[])->impossibleStaticBinCoercion
       if)

    // left##<=staticIntegerTransient## then
       (if true
        // right##<=staticCharTransient##
        // right##<=staticIntegerTransient## then
           (&staticIntegerTransient[]).init->output[]
        // right##<=staticRealTransient## then
           (&staticRealTransient[]).init->output[]
        // right##<=staticStringTransient## then
           (# sstran: ^staticStringTransient
           do right[]->sstran[];
              (if sstran.singleton then
                  (&staticIntegerTransient[]).init->output[]
               else
                  (* not like char case: we do not coerce integer to string *)
                  (left[],right[],usageAst[])->impossibleStaticBinCoercion
              if)
           #)
        else
           (left[],right[],usageAst[])->impossibleStaticBinCoercion
       if)

    // left##<=staticRealTransient## then
       (if true
        // right##<=staticIntegerTransient##
        // right##<=staticRealTransient## then
           (&staticRealTransient[]).init->output[]
        else
           (left[],right[],usageAst[])->impossibleStaticBinCoercion
       if)

    // left##<=staticStringTransient## then
       INNER arithBinOpStaticCoercionBase

    // left##<=staticRepeatedTransient## then
       (* we could do various '%' operations on two repetitions ('r1%r2'),
        * but it does not have high priority *)
       'ibetaSlicelibbody.bet/773'->notyet; (* !!! *)

    else
       (left[],right[],usageAst[])->impossibleStaticBinCoercion
   if)

-- ArithBinOpStaticCoercion:dopart --
do
   (* left is string *)
   (# left_sstran,right_sstran: ^staticStringTransient
   do left[]->left_sstran[];
      (if left_sstran.singleton then
          (* left _can_ deliver an integer, and must always *)
          (if true
           // right##<=staticCharTransient##
           // right##<=staticIntegerTransient## then
              (&staticIntegerTransient[]).init->output[]
           // right##<=staticStringTransient## then
              right[]->right_sstran[];
              (if right_sstran.singleton then
                  (* right can deliver an integer *)
                  (&staticIntegerTransient[]).init->output[]
               else
                  (* right cannot deliver an integer *)
                  (left[],right[],usageAst[])->impossibleStaticBinCoercion
              if)
           else
              (* right is boolean/real/... *)
              (left[],right[],usageAst[])->impossibleStaticBinCoercion
          if)
       else
          (* left is a proper string, cannot deliver an integer *)
          (left[],right[],usageAst[])->impossibleStaticBinCoercion
      if)
   #)

-- PlusBinOpStaticCoercion:dopart --
do
   (* left is string *)
   (if right##<=staticStringTransient## then
       (* two strings *)
       (# left_sstran,right_sstran: ^staticStringTransient
       do left[]->left_sstran[];
          right[]->right_sstran[];
          (if left_sstran.singleton and right_sstran.singleton then
              (* two literal chars add as integers *)
              (&staticIntegerTransient[]).init->output[]
           else
              (* at least one proper string: add as strings *)
              (&staticStringTransient[]).init->output[]
          if)
       #)
    else
       (* right is not a string *)
       (if true
        // right##<=staticCharTransient##
        // right##<=staticIntegerTransient## then
           (# sstran: ^staticStringTransient
           do left[]->sstran[];
              (if sstran.singleton then
                  (* left is literal char, coerce it to char,
                   * then coerce both to integer and add etc. *)
                  (&staticIntegerTransient[]).init->output[]
               else
                  (* left is non-singleton, fail *)
                  (left[],right[],usageAst[])->impossibleStaticBinCoercion
              if)
           #)
        else
           (left[],right[],usageAst[])->impossibleStaticBinCoercion
       if)
   if)

-- ModBinOpStaticCoercion:dopart --
do
   (if true
    // left##<=staticSublistTransient## then
       (* composite structure, "right" must also be composite *)
       (if true
        // right##<=staticSublistTransient## then
           (* both have composite structure, check recursively
            * NB: this is the somewhat weird case of things like
            * (7,8) mod (4,3); _perhaps_ supported later *)
           (# sstran_left,sstran_right: ^staticSublistTransient;
              succeeded: @boolean
           do left[]->sstran_left[];
              right[]->sstran_right[];
              sstran_left.strlist[]->sstran_right.strlist.correlate
              (# foreach::
                   (#
                   do (otherCurrent[],current[],usageAst[])
                        ->&modBinOpStaticCoercion;
                      (* !!! collect the result;
                       * if we get this far, the coercion succeeded
                       * for this link of the list; tell`em *)
                      true->value
                   #)
              #)->succeeded;
              (if succeeded then
                  (* !!! should we compute a composite result? *)
                  'ibetaSlicelibbody.bet/601: '->notyet; (* !!! *)
               else
                  (* structural difference, or list-internal failure *)
                  (left[],right[],usageAst[])->impossibleStaticBinCoercion
              if)
           #)
        else
           (left[],right[],usageAst[])->impossibleStaticBinCoercion
       if)

    // left##<=staticCharTransient## then
       (if true
        // right##<=staticCharTransient##
        // right##<=staticIntegerTransient## then
           (&staticIntegerTransient[]).init->output[]
        // right##<=staticStringTransient## then
           (# sstran: ^staticStringTransient
           do right[]->sstran[];
              (if sstran.singleton then
                  (&staticIntegerTransient[]).init->output[]
               else
                  (left[],right[],usageAst[])->impossibleStaticBinCoercion
              if)
           #)
        else
           (left[],right[],usageAst[])->impossibleStaticBinCoercion
       if)

    // left##<=staticIntegerTransient## then
       (if true
        // right##<=staticCharTransient##
        // right##<=staticIntegerTransient## then
           (&staticIntegerTransient[]).init->output[]
        // right##<=staticStringTransient## then
           (# sstran: ^staticStringTransient
           do right[]->sstran[];
              (if sstran.singleton then
                  (&staticIntegerTransient[]).init->output[]
               else
                  (left[],right[],usageAst[])->impossibleStaticBinCoercion
              if)
           #)
        else
           (left[],right[],usageAst[])->impossibleStaticBinCoercion
       if)

    // left##<=staticStringTransient## then
       (# left_sstran,right_sstran: ^staticStringTransient
       do left[]->left_sstran[];
          (if left_sstran.singleton then
              (* left is a literal char *)
              (if true
               // right##<=staticCharTransient##
               // right##<=staticIntegerTransient## then
                  (&staticIntegerTransient[]).init->output[]
               // right##<=staticStringTransient## then
                  right[]->right_sstran[];
                  (if right_sstran.singleton then
                      (* right is literal char, too *)
                      (&staticIntegerTransient[]).init->output[]
                   else
                      (left[],right[],usageAst[])->impossibleStaticBinCoercion
                  if)
               else
                  (left[],right[],usageAst[])->impossibleStaticBinCoercion
              if)
           else
              (left[],right[],usageAst[])->impossibleStaticBinCoercion
          if)
       #)

    // left##<=staticRepeatedTransient## then
       (* we could 'mod' two repetitions, but it does not have high prio *)
       'ibetaSlicelibbody.bet/947'->notyet; (* !!! *)

    else
       (left[],right[],usageAst[])->impossibleStaticBinCoercion
   if)

-- RdivBinOpStaticCoercion:dopart --
do
   (if true
    // left##<=staticSublistTransient## then
       (* composite structure, "right" must also be composite *)
       (if true
        // right##<=staticSublistTransient## then
           (* both have composite structure, check recursively
            * NB: this is the somewhat weird case of things like
            * (10,13.1)/(1.5,7); _perhaps_ supported later *)
           (# sstran_left,sstran_right: ^staticSublistTransient;
              succeeded: @boolean
           do left[]->sstran_left[];
              right[]->sstran_right[];
              sstran_left.strlist[]->sstran_right.strlist.correlate
              (# foreach::
                   (#
                   do (otherCurrent[],current[],usageAst[])
                        ->&rdivBinOpStaticCoercion;
                      (* !!! collect the result;
                       * if we get this far, the coercion succeeded
                       * for this link of the list; tell`em *)
                      true->value
                   #)
              #)->succeeded;
              (if succeeded then
                  (* !!! should we compute a composite result? *)
                  'ibetaSlicelibbody.bet/723: '->notyet; (* !!! *)
               else
                  (* structural difference, or list-internal failure *)
                  (left[],right[],usageAst[])->impossibleStaticBinCoercion
              if)
           #)
        else
           (left[],right[],usageAst[])->impossibleStaticBinCoercion
       if)

    // left##<=staticCharTransient## then
       (if true
        // right##<=staticCharTransient##
        // right##<=staticIntegerTransient## then
           (&staticRealTransient[]).init->output[]
        // right##<=staticStringTransient## then
           (# sstran: ^staticStringTransient
           do right[]->sstran[];
              (if sstran.singleton then
                  (* literal char *)
                  (&staticRealTransient[]).init->output[]
               else
                  (left[],right[],usageAst[])->impossibleStaticBinCoercion
              if)
           #)
        else
           (left[],right[],usageAst[])->impossibleStaticBinCoercion
       if)

    // left##<=staticIntegerTransient## then
       (if true
        // right##<=staticCharTransient##
        // right##<=staticIntegerTransient##
        // right##<=staticRealTransient## then
           (&staticRealTransient[]).init->output[]
        // right##<=staticStringTransient## then
           (# sstran: ^staticStringTransient
           do right[]->sstran[];
              (if sstran.singleton then
                  (* literal char *)
                  (&staticRealTransient[]).init->output[]
               else
                  (left[],right[],usageAst[])->impossibleStaticBinCoercion
              if)
           #)
        else
           (left[],right[],usageAst[])->impossibleStaticBinCoercion
       if)

    // left##<=staticRealTransient## then
       (if true
        // right##<=staticIntegerTransient##
        // right##<=staticRealTransient## then
           (&staticRealTransient[]).init->output[]
        else
           (left[],right[],usageAst[])->impossibleStaticBinCoercion
       if)

    // left##<=staticStringTransient## then
       (# left_sstran,right_sstran: ^staticStringTransient
       do left[]->left_sstran[];
          (if left_sstran.singleton then
              (* left is literal char *)
              (if true
               // right##<=staticCharTransient##
               // right##<=staticIntegerTransient## then
                  (&staticRealTransient[]).init->output[]
               // right##<=staticStringTransient## then
                  right[]->right_sstran[];
                  (if right_sstran.singleton then
                      (* right is literal char, too *)
                      (&staticRealTransient[]).init->output[]
                   else
                      (* right is non-singleton string *)
                      (left[],right[],usageAst[])->impossibleStaticBinCoercion
                  if)
               else
                  (left[],right[],usageAst[])->impossibleStaticBinCoercion
              if)
           else
              (* left is non-singleton string *)
              (left[],right[],usageAst[])->impossibleStaticBinCoercion
          if)
       #)

    // left##<=staticRepeatedTransient## then
       (* we could '/' two repetitions, but it does not have high prio *)
       'ibetaSlicelibbody.bet/1067'->notyet; (* !!! *)

    else
       (left[],right[],usageAst[])->impossibleStaticBinCoercion
   if)

-- EqneqBinOpStaticCoercion:dopart --
do
   (if true
    // left##<=staticSublistTransient## then
       (* composite structure, "right" must also be composite *)
       (if true
        // right##<=staticSublistTransient## then
           (* both have composite structure, check recursively *)
           (# sstran_left,sstran_right: ^staticSublistTransient;
              succeeded: @boolean
           do left[]->sstran_left[];
              right[]->sstran_right[];
              sstran_left.strlist[]->sstran_right.strlist.correlate
              (# foreach::
                   (#
                   do (otherCurrent[],current[],usageAst[])
                        ->&eqneqBinOpStaticCoercion;
                      (* we do not care about the result, it is always bool,
                       * but if we get this far, the coercion succeeded
                       * for this link of the list; tell`em *)
                      true->value
                   #)
              #)->succeeded;
              (if succeeded then
                  (&staticBooleanTransient[]).init->output[];
               else
                  (* structural difference, or list-internal failure *)
                  (left[],right[],usageAst[])->impossibleStaticBinCoercion
              if)
           #)
        else
           (left[],right[],usageAst[])->impossibleStaticBinCoercion
       if)

    // left##<=staticBooleanTransient## then
       (if right##<=staticBooleanTransient## then
           (&staticBooleanTransient[]).init->output[]
        else
           (left[],right[],usageAst[])->impossibleStaticBinCoercion
       if)

    // left##<=staticCharTransient## then
       (if true
        // right##<=staticCharTransient##
        // right##<=staticIntegerTransient##
        // right##<=staticRealTransient## then
           (&staticBooleanTransient[]).init->output[];
        // right##<=staticStringTransient## then
           (# sstran: ^staticStringTransient
           do right[]->sstran[];
              (if sstran.singleton then
                  (* literal char *)
                  (&staticBooleanTransient[]).init->output[]
               else
                  (left[],right[],usageAst[])->impossibleStaticBinCoercion
              if)
           #)
        else
           (left[],right[],usageAst[])->impossibleStaticBinCoercion
       if)

    // left##<=staticIntegerTransient## then
       (if true
        // right##<=staticCharTransient##
        // right##<=staticIntegerTransient##
        // right##<=staticRealTransient## then
           (&staticBooleanTransient[]).init->output[]
        // right##<=staticStringTransient## then
           (# sstran: ^staticStringTransient
           do right[]->sstran[];
              (if sstran.singleton then
                  (* literal char *)
                  (&staticBooleanTransient[]).init->output[]
               else
                  (left[],right[],usageAst[])->impossibleStaticBinCoercion
              if)
           #)
        else
           (left[],right[],usageAst[])->impossibleStaticBinCoercion
       if)

    // left##<=staticRealTransient## then
       (if true
        // right##<=staticCharTransient##
        // right##<=staticIntegerTransient##
        // right##<=staticRealTransient## then
           (&staticBooleanTransient[]).init->output[]
        // right##<=staticStringTransient## then
           (# sstran: ^staticStringTransient
           do right[]->sstran[];
              (if sstran.singleton then
                  (* literal char *)
                  (&staticBooleanTransient[]).init->output[]
               else
                  (left[],right[],usageAst[])->impossibleStaticBinCoercion
              if)
           #)
        else
           (left[],right[],usageAst[])->impossibleStaticBinCoercion
       if)

    // left##<=staticStringTransient## then
       (# left_sstran,right_sstran: ^staticStringTransient
       do left[]->left_sstran[];
          (if left_sstran.singleton then
              (* left is literal char *)
              (if true
               // right##<=staticCharTransient##
               // right##<=staticIntegerTransient##
               // right##<=staticRealTransient## then
                  (&staticBooleanTransient[]).init->output[]
               // right##<=staticStringTransient## then
                  (* when right is singleton, compare as chars,
                   * otherwise compare as strings; both are OK *)
                  (&staticBooleanTransient[]).init->output[]
               else
                  (left[],right[],usageAst[])->impossibleStaticBinCoercion
              if)
           else
              (* left is non-singleton string *)
              (if true
               // right##<=staticCharTransient## then
                  (* string=char? OK: coerce the char into a string *)
                  (&staticBooleanTransient[]).init->output[]
               // right##<=staticStringTransient## then
                  (* string=string *)
                  (&staticBooleanTransient[]).init->output[]
               else
                  (left[],right[],usageAst[])->impossibleStaticBinCoercion
              if)
          if)
       #)

    // left##<=staticNoneTransient## then
       (if true
        // right##<=staticNoneTransient##
        // right##<=staticORefTransient##
        // right##<=staticPRefTransient## then
           (&staticBooleanTransient[]).init->output[]
        else
           (left[],right[],usageAst[])->impossibleStaticBinCoercion
       if)

    // left##<=staticORefTransient## then
       (if true
        // right##<=staticNoneTransient##
        // right##<=staticORefTransient## then
           (&staticBooleanTransient[]).init->output[]
        else
           (left[],right[],usageAst[])->impossibleStaticBinCoercion
       if)

    // left##<=staticPRefTransient## then
       (if true
        // right##<=staticNoneTransient##
        // right##<=staticPRefTransient## then
           (&staticBooleanTransient[]).init->output[]
        else
           (left[],right[],usageAst[])->impossibleStaticBinCoercion
       if)

    // left##<=staticRepeatedTransient## then
       (* we could compare two repetitions, but it does not have high prio *)
       'ibetaSlicelibbody.bet/1236'->notyet; (* !!! *)

    else
       (left[],right[],usageAst[])->impossibleStaticBinCoercion
   if)

-- UneqBinOpStaticCoercion:dopart --
do
   (if true
    // left##<=staticSublistTransient## then
       (* composite structure, "right" must also be composite *)
       (if true
        // right##<=staticSublistTransient## then
           (* both have composite structure, check recursively *)
           (# sstran_left,sstran_right: ^staticSublistTransient;
              succeeded: @boolean
           do left[]->sstran_left[];
              right[]->sstran_right[];
              sstran_left.strlist[]->sstran_right.strlist.correlate
              (# foreach::
                   (#
                   do (otherCurrent[],current[],usageAst[])
                        ->&uneqBinOpStaticCoercion;
                      (* !!! collect the result;
                       * but if we get this far, the coercion succeeded
                       * for this link of the list; tell`em *)
                      true->value
                   #)
              #)->succeeded;
              (if succeeded then
                  (&staticBooleanTransient[]).init->output[]
               else
                  (* structural difference, or list-internal failure *)
                  (left[],right[],usageAst[])->impossibleStaticBinCoercion
              if)
           #)
        else
           (left[],right[],usageAst[])->impossibleStaticBinCoercion
       if)

    // left##<=staticBooleanTransient## then
       (if right##<=staticBooleanTransient## then
           (&staticBooleanTransient[]).init->output[]
        else
           (left[],right[],usageAst[])->impossibleStaticBinCoercion
       if)

    // left##<=staticCharTransient##
    // left##<=staticIntegerTransient##
    // left##<=staticRealTransient## then
       (if true
        // right##<=staticCharTransient##
        // right##<=staticIntegerTransient##
        // right##<=staticRealTransient## then
           (&staticBooleanTransient[]).init->output[]
        // right##<=staticStringTransient## then
           (# sstran: ^staticStringTransient
           do right[]->sstran[];
              (if sstran.singleton then
                  (* char/int/real < literalchar? *)
                  (&staticBooleanTransient[]).init->output[]
               else
                  (left[],right[],usageAst[])->impossibleStaticBinCoercion
              if)
           #)
        else
           (left[],right[],usageAst[])->impossibleStaticBinCoercion
       if)

    // left##<=staticStringTransient## then
       (# sstran: ^staticStringTransient
       do left[]->sstran[];
          (if sstran.singleton then
              (* left is literal char *)
              (if true
               // right##<=staticCharTransient##
               // right##<=staticIntegerTransient##
               // right##<=staticRealTransient## then
                  (&staticBooleanTransient[]).init->output[]
               // right##<=staticStringTransient## then
                  (* two cases: (1) right is literal char, too *)
                  (* (2) literalchar<string? OK: left is string after all *)
                  (&staticBooleanTransient[]).init->output[]
               else
                  (left[],right[],usageAst[])->impossibleStaticBinCoercion
              if)
           else
              (* left is non-singleton string *)
              (if true
               // right##<=staticCharTransient## then
                  (* string<char? OK: coerce the char into a string *)
                  (&staticBooleanTransient[]).init->output[]
               // right##<=staticStringTransient## then
                  (* string<string? OK, compare lexicographically *)
                  (&staticBooleanTransient[]).init->output[]
               else
                  (left[],right[],usageAst[])->impossibleStaticBinCoercion
              if)
          if)
       #)

    // left##<=staticPRefTransient## then
       (if true
        // right##<=staticPRefTransient## then
           (&staticBooleanTransient[]).init->output[]
        else
           (left[],right[],usageAst[])->impossibleStaticBinCoercion
       if)

    // left##<=staticRepeatedTransient## then
       (* we could compare two repetitions, but it does not have high prio *)
       'ibetaSlicelibbody.bet/1347'->notyet; (* !!! *)

    else
       (left[],right[],usageAst[])->impossibleStaticBinCoercion
   if)

-- AndorBinOpStaticCoercion:dopart --
do
   (if true
    // left##<=staticSublistTransient## then
       (* composite structure, "right" must also be composite *)
       (if true
        // right##<=staticSublistTransient## then
           (* both have composite structure, check recursively
            * NB: this is the somewhat weird case of things like
            * (false,true) and (true,true); _perhaps_ supported later *)
           (# sstran_left,sstran_right: ^staticSublistTransient;
              succeeded: @boolean
           do left[]->sstran_left[];
              right[]->sstran_right[];
              sstran_left.strlist[]->sstran_right.strlist.correlate
              (# foreach::
                   (#
                   do (otherCurrent[],current[],usageAst[])
                        ->&andorBinOpStaticCoercion;
                      (* we do not care about the result, it is always bool,
                       * but if we get this far, the coercion succeeded
                       * for this link of the list; tell`em *)
                      true->value
                   #)
              #)->succeeded;
              (if succeeded then
                  (* !!! should we create a composite transient? *)
                  'ibetaSlicelibbody.bet/1089: '->notyet; (* !!! *)
               else
                  (* structural difference, or list-internal failure *)
                  (left[],right[],usageAst[])->impossibleStaticBinCoercion
              if)
           #)
        else
           (left[],right[],usageAst[])->impossibleStaticBinCoercion
       if)

    // left##<=staticBooleanTransient## then
       (if right##<=staticBooleanTransient## then
           (&staticBooleanTransient[]).init->output[]
        else
           (left[],right[],usageAst[])->impossibleStaticBinCoercion
       if)

    // left##<=staticRepeatedTransient## then
       (* we could 'and'/'or' two repetitions, but it does not have high prio *)
       'ibetaSlicelibbody.bet/1399'->notyet; (* !!! *)

    else
       (left[],right[],usageAst[])->impossibleStaticBinCoercion
   if)

-- AddUnOpStaticCoercion:dopart --
do
   (if true
    // input##<=staticSublistTransient## then
       (* composite structure, check recursively *)
       (# sstran: ^staticSublistTransient
       do input[]->sstran[];
          sstran.strlist.scan
          (#
          do (current[],usageAst[])->&addUnOpStaticCoercion;
             (* !!! collect the result *)
          #);
          (* !!! deliver the result *)
          'ibetaSlicelibbody.bet/1144: '->notyet; (* !!! *)
       #)

    // input##<=staticCharTransient## then
       (&staticCharTransient[]).init->output[]
    // input##<=staticIntegerTransient## then
       (&staticIntegerTransient[]).init->output[]
    // input##<=staticRealTransient## then
       (&staticRealTransient[]).init->output[]

    // input##<=staticRepeatedTransient## then
       (* we could '+r' a repetition, but it does not have high prio *)
       'ibetaSlicelibbody.bet/1430'->notyet; (* !!! *)

    else
       (input[],usageAst[],'Use an integer value')
         ->impossibleStaticUnCoercion
   if)

-- NotUnOpStaticCoercion:dopart --
do
   (if true
    // input##<=staticSublistTransient## then
       (* composite structure, check recursively *)
       (# sstran: ^staticSublistTransient
       do input[]->sstran[];
          sstran.strlist.scan
          (#
          do (current[],usageAst[])->&notUnOpStaticCoercion;
             (* !!! collect the result *)
          #);
          (* !!! deliver the result *)
          'ibetaSlicelibbody.bet/1185: '->notyet; (* !!! *)
       #)

    // input##<=staticBooleanTransient## then
       (&staticBooleanTransient[]).init->output[]

    // input##<=staticRepeatedTransient## then
       (* we could 'not' a repetition, but it does not have high prio *)
       'ibetaSlicelibbody.bet/1458'->notyet; (* !!! *)

    else
       (input[],usageAst[],'Use a boolean value')
         ->impossibleStaticUnCoercion
   if)

-- ImpossibleStaticUnCoercion:dopart --
do
   (# msg: ^text
   do 'Cannot coerce '->msg[];
      (input.typeName).withIndefArticle->msg.puttext;
      ' into anything applicable for this operation'->msg.puttext;
      (msg[],solution[],usageAst[])->staticError
   #)

-- ImpossibleStaticBinCoercion:dopart --
do
   (# msg: ^text
   do 'Cannot coerce '->msg[];
      (left.typeName).withIndefArticle->msg.puttext;
      ' and '->msg.puttext;
      (right.typeName).withIndefArticle->msg.puttext;
      ' into anything applicable for this operation'->msg.puttext;
      (msg[]
      ,'Use other values, and of ("almost") the same type'
      ,usageAst[])->staticError
   #)

-- StaticTransientObserve:dopart --
do
   (private.observeStream[],indentation,false)->print

-- StaticTransientListPrint:dopart --
do
   before;
   scan
   (#
   do current[]->beforeEach;
      (dest[],indentation,element_nl)->current.print;
      current[]->afterEach
   #);
   after

-- StaticTransientListPrintShort:dopart --
do
   before;
   scan
   (#
   do current[]->beforeEach;
      (dest[],indentation,element_nl)->current.printShort;
      current[]->afterEach
   #);
   after

-- StaticTransientListObserve:dopart --
do
   (private.observeStream[],indentation,false,true)->print

-- StaticTransientListNormalize:dopart --
do
   (* since normalize _might_ (but does not have to) deliver
    * another object, we must take each element out of the
    * list and then insert the result again; this is a place
    * where a standard list would have been easier! *)
   (# tmp: @staticTransientList;
      stran: ^staticTransient
   do deliver->tmp.assign;
      L: (if not tmp.empty then
             (tmp.first->tmp.cutLink).normalize->append;
             restart L
         if)
   #)

-- StaticTransientListCorrelate:dopart --
do
   (if other.empty then
       (* correlate iff this list is also empty *)
       empty->value
    else
       (* 'other' is non-empty *)
       L: (if empty then
              (* this list is empty, 'other' is not, do not correlate *)
              false->value
           else
              (* both lists are non-empty, investigate element by element *)
              (# otherPos: ^staticTransient
              do other.first->otherPos[];
                 scan
                 (#
                 do (if otherPos[]=NONE then
                        (* other exhausted, this one not, no correlation *)
                        false->value;
                        leave L
                     else
                        (if (otherPos[],current[])->forEach then
                            (* OK until and including 'current'; continue *)
                            otherPos.next->otherPos[]
                         else
                            (* fails at this point => fails *)
                            false->value;
                            leave L
                        if)
                    if)
                 #);
                 (* did not leave, so the lists correlate; check lengths *)
                 (if otherPos[]<>NONE then
                     (* scanned all of this list, but 'other' has more *)
                     false->value
                  else
                     (* 'other' exhausted, and we did not leave, so this
                      * list is also exhausted, so they correlate *)
                     true->value
                 if)
              #)
          if)
   if)

-- StaticSublistTransientAdd:dopart --
do
   (if stran##<=staticSublistTransient## then
       (# sstran: ^staticSublistTransient
       do stran[]->sstran[];
          sstran.strlist.deliver->strlist.appendList
       #)
    else
       stran[]->strlist.append
   if)

-- StaticOQuaTransientORefCompatible:dopart --
do
   (if exact then
       (* 'other' only matches if equal *)
       L: (if other.sptype[]->sptype.equal
              (# maybe::
                   (# (* seem to be equal, but specialization and further
                       * binding of virtuals may make them different *)
                   do onBoundUnsafe;
                      false->this(orefCompatible).value;
                      leave L
                   #)
              #) then
              (* this is perfectly safe! *)
              true->value
           else
              (* not equal - dynamic qualification error possible *)
              (if true
               // sptype[]->other.sptype.lessEqual then
                  (* bigger[]->smaller[], i.e., a down-cast *)
                  onDownUnsafe;
                  false->value
               // other.sptype[]->sptype.lessEqual then
                  (* smaller[]->bigger[], i.e., an up-cast *)
                  onUpUnsafe;
                  false->value
               else
                  (* rest of cases: no particular relation - not much hope *)
                  onCrossUnsafe;
                  false->value
              if)
          if)
    else
       (* non-exact; 'other' must simply be special enough *)
       L: (if other.sptype[]->sptype.lessEqual
              (# maybe::
                   (# (* other seems to be lessEqual, but specialization 
                       * and further binding of virtuals may destroy this *)
                   do onBoundUnsafe;
                      false->this(orefCompatible).value;
                      leave L
                   #)
              #) then
              (* this is perfectly safe! *)
              true->value
           else
              (* not lessEqual - dynamic qualification error possible *)
              (if sptype[]->other.sptype.lessEqual then
                  (* bigger[]->smaller[] *)
                  onDownUnsafe;
                  false->value
               else
                  (* rest of cases: no particular relation - not much hope *)
                  onCrossUnsafe;
                  false->value
              if)
          if)
   if)

-- StaticPQuaTransientPRefCompatible:dopart --
do
   (* significantly simpler than orefCompatible since we do not have exact *)
   (if other.sptype[]->sptype.lessEqual then
       (if sptype.knownStatically then
           true->value
        else
           (* specializations may break the order other<=me *)
           onBoundUnSafe;
           false->value
       if)
    else
       (* not lessEqual - dynamic qualification error possible *)
       (if sptype[]->other.sptype.lessEqual then
           (* bigger## -> smaller## *)
           onDownUnsafe;
           false->value
        else
           (* rest of cases: no particular relation - not much hope *)
           onCrossUnsafe;
           false->value
       if)
   if)

(************************************************************
 *                                                          *
 *                   BETA Virtual Machine                   *
 *                                                          *
 ************************************************************)

-- BetaVirtualMachinePrint:dopart --
do
   '\n********** Beta Virtual Machine **********'->output;
   (dest[],indentation+indent_delta,true)->tmpObjs.print;
   (dest[],indentation+indent_delta,true)->tmpReps.print;
   (dest[],indentation+indent_delta,true)->booleans.print;
   (dest[],indentation+indent_delta,true)->chars.print;
   (dest[],indentation+indent_delta,true)->integers.print;
   (dest[],indentation+indent_delta,true)->reals.print;
   (dest[],indentation+indent_delta,true)->strings.print;
   (dest[],indentation+indent_delta,true)->objRefs.print;
   (dest[],indentation+indent_delta,true)->patterns.print;
   (dest[],indentation+indent_delta,true)->attributes.print;
   '\n******************************************'->output

-- BetaVirtualMachineObserve:dopart --
do
   (this(interpreterBase).private.observeStream[],indentation,false)
     ->print

(*************************************************************
 *                                                           *
 *                         Execution                         *
 *                                                           *
 *************************************************************)

-- ComponentObjectSlicePopObject:dopart --
do
   M: (# curOOF: ^stackable;
         curOOFO: ^stackableObject
      do (if not currentStack.empty then
             currentStack.pop
               ->curOOF[]
               ->thrd.private.bvm.restoreFrame;
             (if curOOF##<=stackableObject## then
                 curOOF[]->curOOFO[];
                 (if curOOFO.l1obj[]<>l1obj[] then
                     'Inconsistent stack (wrong object)'
                       ->internalError
                 if)
              else
                 (* if we jump out of a for- or labelled imp
                  * they do not get a chance to clean up; so
                  * we do it here *)
                 restart M
             if)
          else
             (* emptied the stack without finding me! *)
             'Inconsistent stack: current object not found'
               ->internalError
         if)
      #)

-- ComponentObjectSliceForkingExecute:dopart --
do
   (if not executing then
       (if suspended then
           (* not executing, but suspended *)
           ('Trying to fork a suspended component slice'
           ,thrd[],unwind##)->componentDoubleExecuteError
        else
           (* not executing, not suspended: fork a new execution *)
           (# doit: @|system
                (# onKilled::(# do threadCountDown #)
                do (if pred[]<>NONE then
                       unwindScope
                       (# (* Usually unwinding hereto is an error:
                           * 'exitLeave' and 'exitRestart' must
                           * have missed their 'target', and 'exitError'
                           * is of course an error already; only 'exitKill'
                           * is a "normal" event which should proceed
                           * quietly; in any case we cannot continue
                           * the stack unwinding because the stack ends
                           * here! *)
                          onLeave::
                            (# (* We do not want to unwind the stack now,
                                * but 'unwindError' wants a stack unwinder,
                                * and we want 'unwindError' to format the
                                * error message for us; so we give it a
                                * stack (non)unwinder that will transfer the
                                * error message (in an 'exitError') to 'ee'
                                * and just fall through.  Then we reach the
                                * next imperative which will print the
                                * error message *)
                               noUnwind: stackUnwinder(# do ec[]->ee[] #);
                               ee: ^exitError
                            do ('Trying to \'leave\' beyond a thread'
                               ,thrd[],noUnwind##)->unwindError;
                               ee.msg[]->private.errorStream.puttext
                            #);
                          onRestart::
                            (# noUnwind: stackUnwinder(# do ec[]->ee[] #);
                               ee: ^exitError
                            do ('Trying to \'restart\' beyond a thread'
                               ,thrd[],noUnwind##)->unwindError;
                               ee.msg[]->private.errorStream.puttext
                            #);
                          onKill::(# (* a no-op, no problems, no noise *) #);
                          onError::
                            (# (* just display the message *)
                            do ee.msg[]->private.errorStream.puttext
                            #)
                       do (thrd[],unwind##)->pred.execute;
                          (* finalize this thread *)
                          (oid[],thrd[])->stackPopObject;
                          (if thrd.private.popComponent
                              <>this(componentObjectSlice)[] then
                              'Inconsistent component stack detected'
                                ->internalError
                          if)
                       #)
                   if);
                   (* register that this thread is not executing *)
                   false->executing
                #)
           do this(componentObjectSlice)[]->thrd.private.pushComponent;
              (oid[],thrd[])
                ->newStackableObject
                ->currentStack.push;
              true->executing;
              threadCountUp;
              doit[]->new_impl_thread[]->fork;
              pause
           #)
       if)
    else
       (* executing *)
       ('Trying to fork a component slice which is already executing'
       ,thrd[],unwind##)->componentDoubleExecuteError
   if)

-- CompositeObjectSliceAttrsDefine:dopart --
do
   (l2ndcl[],l1ent[])
     ->(&localMapElement[]).init
     ->attrs[l2ndcl.offset][]

-- CompositeObjectSliceAttrsLookup:dopart --
do
   (thrd[],unwind##,l2ndcl[])->attrsLookupAttr->attr[];
   (if attr[]<>NONE then attr.to[]->l1ent[] else NONE->l1ent[] if)

-- CompositeObjectSliceAttrsLookupAttr:dopart --
do
   attrs[l2ndcl.offset][]->attr[]->target_attr[];
   L: (if attr.to[]
       // private.freshAttribute[] then
          (* attribute must be created first, wrapped in frame *)
          (NONE,thrd[])->newStackableObject->oofo[];
          (thrd[],unwind##,attr[])->attrsCompiledFillInAttribute;
          oofo[]->thrd.private.bvm.restoreFrame;
          (* interpret delegation, if present *)
          L2: (if target_attr.to##<=l1DelegateEntity## then
                  (* attribute delegates, use target *)
                  target_attr.to[]->l1del[];
                  l1del.target[]->target_attr[];
                  (* shortcut delegation *)
                  target_attr.to[]->attr.to[];
                  restart L2
              if);
          L2: (if target_attr.to[]=private.freshAttribute[] then
                  (* attribute must be created first *)
                  target_attr.context->target_oSlice[];
                  (if target_oSlice##<=compositeObjectSlice## then
                      target_oSlice[]->target_coSlice[];
                      (* .. wrapped in frame *)
                      (NONE,thrd[])->newStackableObject->oofo[];
                      (thrd[],unwind##,target_attr[])
                        ->target_coSlice.attrsCompiledFillInAttribute;
                      oofo[]->thrd.private.bvm.restoreFrame;
                      L3: (if target_attr.to##<=l1DelegateEntity## then
                              (* attribute delegates, use target *)
                              target_attr.to[]->l1del[];
                              l1del.target[]->target_attr[];
                              restart L3
                          if);
                      (* update, possibly shortcut delegation *)
                      target_attr.to[]->attr.to[];
                      restart L2
                   else
                      (* !! this may be useful to support later,
                       * but it should never happen for a virtual
                       * decl, which is the only current use
                       * of delegation *)
                      'Delegation leads to non-compositeObjectSlice'
                        ->internalError
                  if)
              if)

       // private.underConstructionAttribute[] then
          (* attribute is being created *)
          (# msg: ^text
          do 'Cyclic dynamic dependency during object construction ('
               ->msg[];
             (msg[],0,false)->target_attr.from.print;
             ')'->msg.puttext;
             (msg[],thrd[],unwind##)->cycleError
          #)
       else
          (* interpret delegation, if present *)
          L2: (if target_attr.to##<=l1DelegateEntity## then
                  (* attribute delegates, use target *)
                  target_attr.to[]->l1del[];
                  l1del.target[]->target_attr[];
                  (* shortcut delegation *)
                  target_attr.to[]->attr.to[];
                  restart L2
              if);
          L2: (if target_attr.to[]=private.freshAttribute[] then
                  (* attribute must be created first *)
                  target_attr.context->target_oSlice[];
                  (if target_oSlice##<=compositeObjectSlice## then
                      target_oSlice[]->target_coSlice[];
                      (* .. wrapped in frame *)
                      (NONE,thrd[])->newStackableObject->oofo[];
                      (thrd[],unwind##,target_attr[])
                        ->target_coSlice.attrsCompiledFillInAttribute;
                      oofo[]->thrd.private.bvm.restoreFrame;
                      L3: (if target_attr.to##<=l1DelegateEntity## then
                              (* attribute delegates, use target *)
                              target_attr.to[]->l1del[];
                              l1del.target[]->target_attr[];
                              restart L3
                          if);
                      (* update, possibly shortcut delegation *)
                      target_attr.to[]->attr.to[];
                      restart L2
                   else
                      (* !! this may be useful to support later,
                       * but it should never happen for a virtual
                       * decl, which is the only current use
                       * of delegation *)
                      'Delegation leads to non-compositeObjectSlice'
                        ->internalError
                  if)
              if)
      if)

-- CompositeObjectSliceAttrsFill:dopart --
do
   (if true
    // attr.to[]=private.freshAttribute[] then
       (* first mark it as "under construction" *)
       private.underConstructionAttribute[]->attr.to[];
       attr.from.decl.location->l2ast[];
       (if l2ast##<=l2AttributeDecl## then
           l2ast[]->l2adcl[];
           (* obtain the entity from the declaration, insert it *)
           (thrd[],unwind##,this(compositeObjectSlice)[],attr[])
             ->l2adcl.instantiate
             ->l1ent[]
        else
           'Encountered a non-AttributeDeclaration in a MainPart'
             ->internalError
       if)

    // attr.to[]=private.underConstructionAttribute[] then
       (* oops, dynamic cycle detected! *)
       (# msg: ^text
       do 'Cyclic dependency during object creation ('->msg[];
          (msg[],0,false)->attr.from.print;
          ')'->msg.puttext;
          (msg[],thrd[],unwind##)->cycleError
       #)

    else
       (if attr.to##<=l1DelegateEntity## then
           (# l1del: ^l1DelegateEntity;
              sSlice: ^substanceSlice;
              targetSlice: ^compositeObjectSlice
           do (* let the target of the delegation do the job *)
              attr.to[]->l1del[];
              l1del.target.context->sSlice[];
              (if sSlice##<=compositeObjectSlice## then
                  sSlice[]->targetSlice[];
                  (thrd[],unwind##,l1del.target[])
                    ->targetSlice.attrsFillInAttribute
                    ->l1ent[]
               else
                  'Delegation attribute with bad context'
                    ->internalError
              if)
           #)
        else
           attr.to[]->l1ent[]
       if)
   if)

-- CompositeObjectSliceAttrsCompiledFill:dopart --
do
   (*test-obs*) ('(init-attr','A')->attr.from.observe;
   (*test-obs*) 'A'->observeIndent;
   (if true
    // attr.to[]=private.freshAttribute[] then
       (* first mark it as "under construction" *)
       private.underConstructionAttribute[]->attr.to[];
       attr.from.decl.location->l2ast[];
       (if l2ast##<=l2AttributeDecl## then
           l2ast[]->l2adcl[];
           (* obtain the entity from the declaration, insert it *)
           (thrd[],unwind##,this(compositeObjectSlice)[],attr[])
             ->l2adcl.initialize
             ->l1ent[]
        else
           'Encountered a non-AttributeDeclaration in a MainPart'
             ->internalError
       if)

    // attr.to[]=private.underConstructionAttribute[] then
       (* oops, dynamic cycle detected! *)
       (# msg: ^text
       do 'Cyclic dependency during object creation ('->msg[];
          (msg[],0,false)->attr.from.print;
          ')'->msg.puttext;
          (msg[],thrd[],unwind##)->cycleError
       #)

    else
       (if attr.to##<=l1DelegateEntity## then
           (# l1del: ^l1DelegateEntity;
              sSlice: ^substanceSlice;
              targetSlice: ^compositeObjectSlice
           do (* let the target of the delegation do the job *)
              attr.to[]->l1del[];
              l1del.target.context->sSlice[];
              (if sSlice##<=compositeObjectSlice## then
                  sSlice[]->targetSlice[];
                  (NONE,thrd[])->newStackableObject->oofo[];
                  (thrd[],unwind##,l1del.target[])
                    ->targetSlice.attrsCompiledFillInAttribute
                    ->l1ent[];
                  oofo[]->thrd.private.bvm.restoreFrame
               else
                  'Delegation attribute with bad context'
                    ->internalError
              if)
           #)
        else
           attr.to[]->l1ent[]
       if)
   if);
   (*test-obs*) 'A'->observeOutdent;
   (*test-obs*) ('init-attr)','A')->attr.from.observe;

(*
 * local variables:
 * ee-beta-main-file: "~/gbeta-0.9/src/main/gbeta.bet"
 * end:
 *)
