\section{Syntax Definition}
The syntax that this compiler shall understand one day is taken
from the document "The Mjolner BETA System, BETA Compiler,
Reference Manual, August 1994, Appendix B: The BETA Grammar".
Currently, only part of that syntax is implemented, but the
syntactical terms were given the same names as in that document.

\section{Language, Scope}
The BETA compiler is itself written in BETA, with the only
exception being the parser, which was written with a flex/bison
combo and C.  The compiler is not strictly a compiler, rather, it
is a translator, and generates C as output.  I believe, that this
makes development easier in the beginning, as C output is much
easier to check for errors than assembler output.  I hope, that
the compiler will quite soon be able to translate itself into
C, so that it then can be ported to a variety of platforms.

\section{Source tree}
The source of the b2c freeware compiler is shipped in a tar
archive.  When unpacked, it will create a new directory called
\fq{b2c-x.y} or \fq{b2c-x.y.z} in the current directory,
with x.y respective x.y.z being the current version of the
compiler.  At the time of writing this, the current version
is 0.3.

Most file names referenced within this document are relative
to the main BETA source directory.  Inside that directory,
further subdirectories are created:
\begin{description}
\item[\fq{doc}] for storing various documentation.
\item[\fq{runtime}] holds a few C source files and C header files,
    which are needed for compiling and running the C programs
    generated by the b2c translator.
\item[\fq{test}] with example BETA programs.  There are also a
    few scripts, which will compile all the examples with the
    b2c translator, and test, if the compilation went ok, and
    the generated programs work as expected.
\item[\fq{basiclib}] holds basic library files, that are required
    for the compilation of beta programs.
\item[\fq{containers}] holds the container library.  These are
    patterns, that can be used to store lists, stacks, etc. of
    objects.
\item[\fq{src}] is the main source directory of the compiler.
    About one half of the source files are directly located in
    this directory, the other half is located in further
    subdirectories of \fq{src}.
\item[\fq{src/ad}] holds code for parsing Attribute Denotations.
    An Attribute Denotation is the use of a ``variable''.  For
    example, the expression \cq{x+y} contains two
    Attribute Denotations: one is \cq{x}, and one is \cq{y}.
\item[\fq{src/att}] defines functions, whose purpose is to
    handle Attributes.  BETA does not know any difference between
    declaration and definition of a symbol, therefore, the set
    of all possible declarations/definitions have been given
    a new, innocent term: Attributes.
\item[\fq{src/doc}] for documents about the compiler's source
    code, including this manual.
\item[\fq{src/ev}] contains those parts of the compiler, that
    handle the specifics of evaluations.  Evaluations are
    the most general expressions in BETA, which include
    assignments, arithmetic expressions, function calls, etc.
\item[\fq{src/imp}] holds routines for processing imperatives.
    Imperatives are those parts of the programming language,
    that contain the imperative: ``do it''.  So an Imperative
    in BETA is pretty much, what the term ``statement'' has
    been describing for quite some while.
\item[\fq{src/od}] contains auxiliary routines for compiling
    object descriptors.  In the BETA language, an object
    descriptor is the part of a pattern, which describes the
    pattern, which is everything between the \cq{(\#} and the
    \cq{\#)} markers.
\item[\fq{src/virt}] is there for handling virtuals
\end{description}
Please note, that the seperation of the object files into the
subdirectories has not yet been strictly enforced.  For example,
a few files, that process imperatives (like \fq{innerimp.bet}
or \fq{evaluationimp.bet}) are still located in the \fq{src}
directory, not in the appropriate \fq{src/imp} subdirectory.

\section{The main program fragment}
BETA programs can be split into various fragments by use of the
fragment system, and this program, the BETA compiler, uses the
fragment system quite a lot.  The topmost fragment, which must
be present in any BETA program, and which is comparable to the
main() function in a C or C++ program, is called
\frq{program}{ObjectDescriptor}.  In case of this BETA compiler,
it is stored in the file \fq{f2c.bet}.

This file is not long.  An object of type \cq{compiler} is
created.  All arguments, which have been given to b2c on the
command line, are passed to that \cq{compiler} object as
file names, that have to be compiled.

The next step is to traverse the list of file names, that have
to be compiled, and pass each name to the actual compiler.
Because any file may contain the names of further files to
be compiled, this step has to be repeated, until no files are
left.  It would be wrong to assume, that only the files given
on the command line shall be compiled.

The last step is to link all the object files generated during
compilation into an executable.

\section{The main pattern of the compiler: compiler}
The main pattern of the compiler, called \cq{compiler}, is found in
the file \fq{compiler.bet}.  It holds a few important attributes,
which represent the current state of the compiler:
\begin{description}
\item[fl] (\underline{f}ile \underline{l}ist) A list of files, that
        has already been compiled.
\item[ol] (\underline{o}bject \underline{l}ist) The list of object
        files, that will have to be linked in the last step.
\item[tl] (\underline{t}odo \underline{l}ist) The list of files,
        that needs to be compiled, but has not yet been processed.
\item[fc] No BETA file may be read twice, even, if it is accessed
	with two different filenames.  The FilenameConverter system,
	which is instantiated in the \cq{fc} item, keeps
	track of all files, that it has seen so far, and ensures,
	that it gives back the same pathname each time a given
	file is accessed.
\item[sl] (\underline{s}lot \underline{l}ist) A list of all slots
	in all input files.
\item[nameTable] A hashTable, which holds information about all the
	names declared in the various Attributes of the currently
	compiled BETA program.
\item[errstream] An output stream to that error messages can be
	printed.
\item[mainorigin] This is a reference to the file, which holds the
	\frq{BETAENV}{ObjectDescriptor} pattern, that is the
	common environment to all BETA programs.  Any BETA
	program instantiates one, and only one, object from this
	pattern.
\item[mainobject] A pointer to the object descriptor in the
	BETAENV fragment, which defines the \cq{Object} pattern.
\item[c\underline{\ }file] A pointer to the currently processed BETA source file.
\item[slotlist] A pointer to a list of all slots, that have been
	encountered by the compiler so far.
\item[cintf] This Attribute holds parameters about how the C output
	should look like.  It depends mostly on the C compiler, that
	you use.  See file cintf.bet for details.
\item[opt] Compiler options, see file \fq{option.bet}.
\item[od3] Pointer to an object descriptor.  This is used during
	phase 3 of the binding/checking algorithm (see
	section \ref{check-phase3}) for referencing the
	currently processed object descriptor.
\item[odserial] This counter is increased every time, that an
	object descriptor is found during parsing of a file.
\end{description}


\section{The Parser}
Actual compilation is performed by the routines in
\fq{compile.bet}.  They take a filename and a starting directory
as argument.  These two are combined into a standardized pathname
via the FilenameConverter.  If that file has not already been
processed, a new BETAfile object is generated for that filename,
and the parser is invoked.  The parser itself is divided in two
halfes: the FragmentLanguageParser (in \fq{fragparser.bet} and
\fq{fragparserbody.bet}) reads the fragment language headers of a
file and directly interprets them.  For example, an INCLUDE
directive results in a recursive call to the compiler, so that
the included file is read in and compiled before the main part of
the current file.

After the fragment headers have been processes, the main parser
(in \fq{parser.bet}, \fq{parserbody.bet}, \fq{parse.y} and
\fq{read.l}) may be invoked to read the rest of the file.  This
invocation is omitted, if b2c can find a more recent \fq{.o}
file, that corresponds to the current \fq{.bet}.  However, if
the current file is included by another source file, and that
other source file has to be recompiled, parsing the current
file cannot be left out.

The parser is rather simple, as it performs only syntax checking.
All grammatical checks are left for later.

\section{Binding and Checking Phases}
\label{check}
\label{check-phase3}
After a file has been parsed, the next step is to bind and
check the contents of that file.  Binding means to find free
slots for all the fragments, that were contained in a source
file.

Checking means to find and report all grammatical errors by
traversing the source code tree.  During the late phases of
checking, all BETA expressions, evaluations and imperatives are
reduced into an ordered list of C statements and expressions.

Due to the nature of the BETA language, the grammatical checking
is not a straightforward process like in C, which can be
performed token by token while the parser reads a source file.
Rather, checking is performed in a number of distinct phases.
Each phase traverses the source code tree in a different order.
During the reduce phase, it may happen, that some nodes of the
source code tree are hit more than once:

\begin{description}
\item[resolve] The first phase is to resolve all name references
    like attribute denotations or remotes.  This requires two
    actions:
    \begin{itemize}
    \item Whenever a pattern is first hit during the traversal
	of the syntax tree, all the names defined in its
	attribute section are entered into a global name
	table.  While this is done, those names, that have
	been declared twice, are detected and reported.
    \item Try to find the corresponding declaration for all
	attribute denotations and remotes.  Report all
	references to undeclared names.
    \end{itemize}
    While resolving name references, it is often required to
    jump forth and back in the source code tree:
    \begin{itemize}
    \item In case of a remote like \cq{P.Q}, we cannot resolve
	\cq{Q}, before we actually know, what type of object
	\cq{P} is.  That does not only require to resolve \cq{P},
	it also requires to resolve any denotation, that is
	contained in the declaration of \cq{P}:
	\begin{quote}\begin{verbatim}X: ^P.Q;
P: @pattern;
pattern: (# Q: (# x,y: @integer #) #);
\end{verbatim}\end{quote}
	In this example, resolving the topmost denotation
	\cq{P.Q} requires to process \cq{P} first.  Because
	\cq{P} is itself defined as a reference, that reference
	has to be resolved, too, or the part \cq{.Q} in the
	expression \cq{P.Q} would not be understood.  So, in
	order to check the declaration of \cq{X}, we are forced
	to also process the declarations of both \cq{P} and
	\cq{pattern}, which appear later in the source file.
	This is different to traditional computer languages like
	C++, Pascal or Fortran, where the syntactical checking is
	a straightforward process.  In case, that an object is
	used before it is defined, these languages require a
	forward declaration, which is neither possible nor
	necessary in BETA.

	For the most part, that feature is just convenient to the
	BETA user.  But there is also a new class of syntactical
	error introduced.  It shows up in incomplete
	declarations, where objects depend upon each other.  This
	will lead to an illegal recursion in the compiler's
	resolving function:
	\begin{quote}\begin{verbatim}A: ^B.obj;
B: ^A.obj;
\end{verbatim}\end{quote}
	Resolving \cq{A} requires to first process \cq{B}.
	Resolving \cq{B} requires to first process \cq{A}.  As a
	result, neither can be completed.  To detect such illegal
	recursions, each attribute denotation holds a tri-state
	flag, which tells, if resolving that attribute has not
	yet been done, is in progress, or has been completed.
    \item When a declaration for a name is not found in the
	pattern, that it was used in, it is next searched for in
	the superpattern of that pattern.  So that superpattern
	has to be found before we continue looking for that name.
	In case of normal patterns, the superpattern is defined
	by a prefix, which itself is an attribute denotation.
	This leads to another case, where resolving a denotation
	requires to first resolve another denotation.

	In case of virtual patterns another level of complexity
	may be added.  Finding the superpattern for a virtual
	binding declaration requires to search through the
	superpatterns of the pattern, that holds the virtual
	binding declaration.
    \end{itemize}

%\item[super] Find the super pattern for each pattern.  This is
%    a bit tricky, as looking up a superpattern changes the
%    name space, and thus affects the process of looking up the
%    superpattern.  See the following example:
%    \begin{quote}\verb+A: IntegerValue (# do 1->value #);\\
%	\verb+B: C (# V: A (# do value+1->value #) exit V #);+\\
%	\verb+C: (# A: IntegerValue (# do 2->value #) #);+
%    \end{quote}
%    It must be made sure, that B.V is derived from the method
%    C.A, not from the pattern A.  This is true, if the
%    superpattern of B is looked up before that of B.V.
%
%    If dynamic references are allowed in the Prefix part of an
%    object descriptor, the grammar may get ambigious:
%    \begin{quote}\verb+P: @A+\\
%	\verb+A: P.M (# M: X (# #) #);+
%	\verb+X: (# X: (# exit 2 #) exit 1 #);
%    \end{quote}
%    The question is: which pattern does the \cq{X} in \cqq{M: X
%    (\# \#)} refer to?  There are two solutions, and both lead
%    to a contradiction:
%    \begin{itemize}
%    \item The \cq{X} in \cqq{M: X} could refer to the pattern,
%	which is declared as \cq{X}.  But then, \cq{P.M} is a
%	subpattern of \cq{X}, so all references to \cq{X} in that
%	pattern, namely the \cqq{M: X}, should refer to \cq{X.X},
%	not \cq{X}.
%    \item The \cq{X} in \cqq{M: X} could refer to the method
%	\cq{X.X}.  But then, \cq{P.M} is a subpattern of
%	\cq{X.X}, and \cq{X} is undefined inside \cq{P.M}.
%	So the \cq{X} in \cqq{M: X} must refer to the global
%	pattern \cq{X}, not \cq{X.X}.
%    \end{itemize}
\item[follow] The next step during checking is to follow all
    static references and inserted items as well as
    superpatterns.  This is required to detect illegal recursions
    like the following:
    \begin{quote}\begin{verbatim}P: (# A: @P #);
\end{verbatim}\end{quote}
    In this case, the pattern \cq{P} contains a copy of itself.
    In particular, all the following static links are followed
    during the follow check:
    \begin{itemize}
    \item A static reference declarations like:
	\begin{quote}\tt\tq{name}: @\tq{pattern};\end{quote}
	creates a static link from the pattern, in whose
	attribute section it appears, to the \tq{pattern}
	used in the declaration.
    \item Inserted items in the do, enter or exit part of a
	pattern create static links from that pattern to the
	inserted item.
    \item The prefix of a pattern declaration:
	\begin{quote}\tt \tq{pattern}: \tq{prefix} (\# \ldots\ \#)
	\end{quote}
	statically links \tq{pattern} to \tq{prefix}.
    \end{itemize}
    Many of the properties of a pattern, like the list of
    pointers to enclosing objects, or the list of virtuals,
    depend on the superpattern of that pattern.  All these
    properties are set during the follow phase. Performing a
    follow check on a pattern requires to perform a follow check
    on the superpattern --- and after that has been completed, we
    can be sure, that the properties of the superpattern are up
    to date and may be copied to the pattern.

    Finally, the follow phase is used to create a set of ordered
    lists of all objects, functions, patterns, etc.\ in a BETA
    source tree.  These lists are used later to create correct
    C source code, where no object may be used before it has
    been declared respective defined.
\item[complete] This phase completes the check of the follow
    phase.  It traverses the source code tree in the syntactical
    order, and starts a follow phase check on all object
    descriptors, which have not been subject to that check, yet.
\item[reduce] All BETA expressions are reduced to "flat" C
    expressions during this phase. For example, an assignment
    \cq{A -> B} is split into several sub-actions, depending
    on the type of \cq{A} and \cq{B}:
    \begin{itemize}
    \item Create an object of type A.
    \item Call the do part of A.
    \item Create an object of type B.
    \item Assign all elements on the exit list of A to the
	    according enter list elements of B.
    \item Call the do part of B.
    \end{itemize}
    Further complication may result, if the exit part of A
    and/or enter part of B contain more references to
    non-simple objects or patterns.  In that case,
    reduction has to be performed recursively, and may
    result in an illegal recursion, if enter or exit lists
    of different objects contain references to each other.

    The reduce phase is also responsible for enforcing type
    safety in all assignments and reference computations.
    Qualification errors are reported, and run time qualification
    checks are inserted where appropriate.

    The reduce phase should also insert implicit checks for
    pointers to be non-null, whereever appropriate, so that
    compiled BETA programs will detect dereferencing a NONE
    reference at run time.

    The reduce phase is the first phase, which does not traverse
    the whole source tree.  Rather, a list of the expressions,
    that shall be reduced, is generated during one of the earlier
    checking phases.
\item[extra] Some special expressions (currently only calls to
    external functions) need one more level of checking after
    reduction has been completed.  Again, this check is performed
    only for those objects, that have been entered into a special
    todo list.
\end{description}

If two phases of the checking process do not interfere with each
other, they can be performed during the same traversal of the
source code tree.  In the current implementation, the complete
phase will also perform all resolve and follow checks.  You can
think of the complete phase of being a machine, that traverses
the source code tree, thereby triggering all necessary follow
and/or resolve checks.

Further versions of the compiler will do a number of optimization
phases after checking has been completed.

\section{Code generation}
If the checking phase found no errors, the next step is to actually
generate C output.  Special care has to be taken to emit the
various declarations in the correct order, so that all C
structures and functions are declared, before they are actually
used in another declaration.
That is achieved by using the follow phase of checking to create
ordered lists of the actions to be performed during code
generation.

Code is emitted into two files.  A \fq{.h} file holds the
declarations of the structures and functions for a given BETA
source file.  The beginning of a \fq{.h} file also holds the
\cq{\#include} directives, if necessary, for other generated
\fq{.h} files.

The actual definitions of the structures and functions are
written to a \fq{.c} file, which \cq{\#include}'s its own \fq{.h}
file.  After both files have been written, a C compiler is
invoked to compile the C source code into an object file.

If for a given \fq{.bet} source file, a \fq{.c} and \fq{.h} file
can be found, and have a modification date, which is newer than
that of the \fq{.bet} file, code generation is omitted.  If also
a \fq{.o} file is found, which is newer than the \fq{.c} and
\fq{.h} file, calling the C compiler is omitted, too.
